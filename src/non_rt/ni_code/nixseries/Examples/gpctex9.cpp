/*
 * gpctex9.cpp
 *   Continuous hardware-timed pulse train output with regeneration
 *
 * gpctex9 scales and generates a continuous pulse train using hardware timing
 * and transfers data to the device using DMA. After configuring the counter's
 * timing and gating parameters, gpctex9 creates a simple 'chirp' pulse train
 * to generate and configures and primes the DMA channel before sending a
 * software start trigger. For 10 seconds, data is regenerated from either the
 * host (using a circular DMA buffer) or the device (using its on-board FIFO).
 * The counter generates pulses, following the specified idle count with the
 * specified active count. The first pulse generated by the counter is not part
 * of the data set and is configurable to allow a custom start delay and an
 * initial pulse train. The first sample clock tick then loads the first pulse
 * train specification from the data set, and the counter will generate that
 * pulse continuously until the next sample clock tick. Each sample clock tick
 * causes the counter to load the next set of pulse train specifications.
 * After the 10 seconds have passed, gpctex9 disarms the counter and shuts
 * down DMA. Finally, gpctex9 restores the hardware's previous state.
 *
 * Example Features (! means highlighted, * means default)
 * Device
 *   Operation       : pulse train generation
 * Channel
 *   Channels        : ctr0 (*), ctr1, ctr2 or ctr3
 *   Scaling         : time (*) or raw counts
 *   Output terminal : PFI0
 *   Output polarity : active low (*) or active high
 *   Output state    : preserve on exit (*) or tristate
 * ! Start delay     : 500 ms idle
 * ! Initial pulse   : 100 ms idle, then 200 ms active
 * Timing
 * ! Sample mode     : continuous regeneration
 * ! Timing mode     : hardware-timed
 * ! Clock source    : PFI1
 *   Clock polarity  : rising edge (*) or falling edge
 * Trigger
 *   Start trigger   : software
 *   Reference trig  : not supported
 *   Pause trigger   : none
 * Write Buffer
 *   Data transfer   : DMA buffer
 *   DMA transfer    : linear buffer for device regeneration
                       circular buffer for host regeneration
 *   DMA buffer      : wait for new data
 * ! Regeneration    : from on-board FIFO (*) or from host memory
 * Behavior
 *   Runtime         : 10 seconds
 *
 * External Connections
 *   PFI0            : observe on an oscilloscope
 *   PFI1            : TTL sample clock
 *
 * Copyright 2011 National Instruments
 * License: NATIONAL INSTRUMENTS SOFTWARE LICENSE AGREEMENT
 *   Refer to "MHDDK License Agreement.pdf" in the root of this distribution.
 *
 */

#include <memory> // For auto_ptr<T>
#include <stdio.h>
#include <time.h>
#include <vector>

// OS Interface
#include "osiBus.h"

// Chip Objects
#include "tXSeries.h"

// Chip Object Helpers
#include "counterResetHelper.h"
#include "dataHelper.h"
#include "devices.h"
#include "pfiRtsiResetHelper.h"
#include "simultaneousInit.h"
#include "streamHelper.h"

// DMA Support
#include "CHInCh/dmaErrors.h"
#include "CHInCh/dmaProperties.h"
#include "CHInCh/tCHInChDMAChannel.h"

void test(iBus* bus)
{
   /*********************************************************************\
   |
   |   Example parameters
   |
   \*********************************************************************/

   //
   // Feature Parameters (modify these to exercise the example)
   //

   // Channel parameters
   const u32 counterNumber = 0;
   tBoolean printTime = kTrue;
   const nCounter::tGi_Polarity_t outputPolarity = nCounter::kActiveLow;
   tBoolean preserveOutputState = kTrue;
   const f32 triggerDelayTime  = 0.5F;
   const f32 initialActiveTime = 0.2F;
   const f32 initialIdleTime   = 0.1F;

   // Timing parameters
   const nCounter::tGi_Polarity_t sampClkPolarity = nCounter::kActiveHigh;

   // Buffer parameters
   tBoolean onboardRegen = kTrue;
   const u32 numberOfPulses = 10; // With on-board regeneration, all pulse specifications must fit in the FIFO (127 samples deep)

   // Behavior parameters
   const f64 runTime = 10;

   //
   // Fixed or calculated parameters (do not modify these)
   //

   // Device parameters
   tCounter* counter = NULL;
   tStreamCircuitRegMap* streamCircuit = NULL;

   // Channel parameters
   const u32 initialTimeSamples = 4;
   nNISTC3::nGPCTDataHelper::tPulseTrainScaler_t scaler;
   scaler.timebaseRate = 100000000;
   std::vector<f32> initialTimeSpecs(initialTimeSamples, 0);
   // initialTimeSpecs[0] doesn't matter since the counter will use initialActiveTime after the delay
   initialTimeSpecs[1] = triggerDelayTime;
   initialTimeSpecs[2] = initialActiveTime;
   initialTimeSpecs[3] = initialIdleTime;
   std::vector<u32> initialPulseSpecs(initialTimeSamples, 1);
   nNISTC3::nGPCTDataHelper::scaleData(initialTimeSpecs, initialTimeSamples,
                                       initialPulseSpecs, initialTimeSamples,
                                       scaler);

   // Buffer parameters
   const tBoolean allowRegeneration = kFalse;
   tBoolean dataRegenerated = kFalse; // Has the DMA channel regenerated old data?
   u32 bytesWritten = 0;   // Bytes written so far to the DMA buffer
   u32 availableSpace = 0; // Space in the DMA buffer
   nNISTC3::tDMAChannelNumber dmaChannel;
   u32 dmaBufferFactor;
   nNISTC3::tDMATopology dmaTopology;
   u32 streamFifoSize = 0;

   if (onboardRegen)
   {
      // Use a single-use DMA buffer that holds the entire waveform once
      dmaBufferFactor = 1;
      dmaTopology = nNISTC3::kNormal;
   }
   else
   {
      // Use a ring DMA buffer that holds 16 waveforms
      dmaBufferFactor = 16;
      dmaTopology = nNISTC3::kLinkChainRing;
   }

   const u32 sampleSizeInBytes = sizeof(u32);
   const u32 totalNumberOfSamples = 2*numberOfPulses; // Each pulse is a pair of samples: idle tick count and active tick count
   const u32 writeSizeInBytes = sampleSizeInBytes * totalNumberOfSamples;
   const u32 dmaSizeInBytes = dmaBufferFactor * writeSizeInBytes;

   std::vector<f32> timeSpecs(totalNumberOfSamples, 0.1F);
   std::vector<u32> pulseSpecs(totalNumberOfSamples, 1); // The counter must count at least two counts

   // Behavior parameters
   f64 elapsedTime = 0; // How long has the generation been running?
   clock_t start;
   const f64 rlpTimeout = 5; // Wait 5 seconds for a register operation before breaking
   clock_t rlpStart;
   f64 rlpElapsedTime;

   // Bookkeeping
   nMDBG::tStatus2 status;
   tBoolean gpctErrored = kFalse; // Did the counter subsystem have an error?
   u32 writesTooFastError = 0;
   u32 gateSwitchError = 0;
   u32 sampleClockOverrun = 0;
   u32 DRQ_Error = 0;
   tAddressSpace bar0;
   bar0 = bus->createAddressSpace(kPCI_BAR0);

   /*********************************************************************\
   |
   |   Initialize the generation
   |
   \*********************************************************************/

   //
   // Open, detect, and initialize the X Series device
   //

   tXSeries device(bar0, &status);

   const nNISTC3::tDeviceInfo* deviceInfo = nNISTC3::getDeviceInfo(device, status);
   if (status.isFatal())
   {
      printf("Error: Cannot identify device (%d).\n", status.statusCode);
      return;
   }

   if (deviceInfo->isSimultaneous) nNISTC3::initializeSimultaneousXSeries(device, status);

   switch (counterNumber)
   {
   case 0:
      dmaChannel = nNISTC3::kCounter0DmaChannel;
      counter = &device.Counter0;
      streamCircuit = &device.Counter0StreamCircuit;
      break;
   case 1:
      dmaChannel = nNISTC3::kCounter1DmaChannel;
      counter = &device.Counter1;
      streamCircuit = &device.Counter1StreamCircuit;
      break;
   case 2:
      dmaChannel = nNISTC3::kCounter2DmaChannel;
      counter = &device.Counter2;
      streamCircuit = &device.Counter2StreamCircuit;
      break;
   case 3:
      dmaChannel = nNISTC3::kCounter3DmaChannel;
      counter = &device.Counter3;
      streamCircuit = &device.Counter3StreamCircuit;
      break;
   default:
      printf("Error: Invalid counter.\n");
      status.setCode(kStatusBadSelector);
      return;
   }

   //
   // Create subsystem helpers
   //

   nNISTC3::pfiRtsiResetHelper pfiRtsiResetHelper(
      device.Triggers,              // Trigger subsystem for access to PFI and RTSI lines
      preserveOutputState,          // preserveOutputState
      status);

   nNISTC3::counterResetHelper counterResetHelper(
      *counter,                     // Counter used for this example
      preserveOutputState,          // preserveOutputState
      status);

   nNISTC3::streamHelper streamHelper(*streamCircuit, device.CHInCh, status);

   //
   // Validate the Feature Parameters
   //

   // Ensure that the FIFO can hold the pulse specifications for on-board regeneration
   streamFifoSize = streamHelper.getFifoSize();
   if (onboardRegen && (writeSizeInBytes > streamFifoSize))
   {
      printf("Error: Number of counter updates (%u) is greater than the FIFO size (%u).\n", totalNumberOfSamples, streamFifoSize/sampleSizeInBytes);
      status.setCode(kStatusBadParameter);
      return;
   }

   /*********************************************************************\
   |
   |   Program peripheral subsystems
   |
   \*********************************************************************/

   //
   // Configure and route PFI lines
   //

   switch (counterNumber)
   {
   case 0:
      device.Triggers.PFI_OutputSelectRegister_i[0].writePFI_i_Output_Select(nTriggers::kPFI_G0_Out, &status);
      break;
   case 1:
      device.Triggers.PFI_OutputSelectRegister_i[0].writePFI_i_Output_Select(nTriggers::kPFI_G1_Out, &status);
      break;
   case 2:
      device.Triggers.PFI_OutputSelectRegister_i[0].writePFI_i_Output_Select(nTriggers::kPFI_G2_Out, &status);
      break;
   case 3:
      device.Triggers.PFI_OutputSelectRegister_i[0].writePFI_i_Output_Select(nTriggers::kPFI_G3_Out, &status);
      break;
   }
   device.Triggers.PFI_Direction_Register.writePFI0_Pin_Dir(nTriggers::kPFI_Output, &status); // Pulse train output terminal
   device.Triggers.PFI_Direction_Register.writePFI1_Pin_Dir(nTriggers::kPFI_Input, &status);  // Sample clock terminal

   /*********************************************************************\
   |
   |   Program the counter subsystem
   |
   \*********************************************************************/

   //
   // Reset the counter subsystem
   //

   counterResetHelper.reset( /*initialReset*/ kTrue, status);

   //
   // Program the counter
   //

   counter->Gi_Mode_Register.setGi_Reload_Source_Switching(nCounter::kUseAlternatingLoadRegisters, &status);
   counter->Gi_Mode_Register.setGi_Loading_On_Gate(nCounter::kNoCounterReloadOnGate, &status);
   counter->Gi_Mode_Register.setGi_ForceSourceEqualToTimebase(kFalse, &status);
   counter->Gi_Mode_Register.setGi_Loading_On_TC(nCounter::kReloadOnTC, &status);
   counter->Gi_Mode_Register.setGi_Counting_Once(nCounter::kNoHardwareDisarm, &status);
   counter->Gi_Mode_Register.setGi_Output_Mode(nCounter::kToggle_Output_On_TC, &status);
   counter->Gi_Mode_Register.setGi_Load_Source_Select(nCounter::kLoad_From_Register_A, &status);
   // Gi_Stop_Mode doesn't matter
   counter->Gi_Mode_Register.setGi_Trigger_Mode_For_Edge_Gate(nCounter::kGateLoads, &status);
   // Gi_Gate_On_Both_Edges doesn't matter
   counter->Gi_Mode_Register.setGi_Gating_Mode(nCounter::kAssertingEdgeGating, &status);
   counter->Gi_Mode_Register.flush(&status);

   counter->Gi_Mode2_Register.setGi_Up_Down(nCounter::kCountDown, &status);
   // Gi_Bank_Switch_Enable doesn't matter
   counter->Gi_Mode2_Register.setGi_Bank_Switch_Mode(nCounter::kGate, &status);
   // Gi_WriteOnSwitchRequest doesn't matter
   counter->Gi_Mode2_Register.setGi_StopOnError(kTrue, &status);
   counter->Gi_Mode2_Register.setGi_CtrOutFifoRegenerationEn(static_cast<u16>(onboardRegen), &status);
   // Gi_HwArmSyncMode doesn't matter
   counter->Gi_Mode2_Register.flush(&status);

   // Gi_Prescale_Div_2 doesn't matter
   counter->Gi_Counting_Mode_Register.setGi_Prescale(kFalse, &status);
   // Gi_HW_Arm_Select doesn't matter
   counter->Gi_Counting_Mode_Register.setGi_HW_Arm_Enable(kFalse, &status);
   // Gi_Index_Phase doesn't matter
   counter->Gi_Counting_Mode_Register.setGi_Index_Mode(nCounter::kIndexModeCleared, &status);
   // Gi_HW_Arm_Polarity doesn't matter
   counter->Gi_Counting_Mode_Register.setGi_Counting_Mode(nCounter::kNormalCounting, &status);
   counter->Gi_Counting_Mode_Register.flush(&status);

   counter->Gi_SampleClockRegister.setGi_SampleClockGateIndependent(kFalse, &status);
   counter->Gi_SampleClockRegister.setGi_SampleClockSampleMode(nCounter::kSC_LastSaved, &status);
   // Gi_SampleClockPulse doesn't matter
   counter->Gi_SampleClockRegister.setGi_SampleClockMode(nCounter::kSC_Disabled, &status);
   // Gi_SampleClockLevelMode doesn't matter
   // Gi_SampleClockPolarity doesn't matter
   // Gi_SampleClockSelect doesn't matter
   counter->Gi_SampleClockRegister.flush(&status);

   // Gi_AuxCtrRegister doesn't matter

   // Gi_Autoincrement_Register doesn't matter

   // Gi_Second_Gate_Register doesn't matter

   counter->Gi_Input_Select_Register.setGi_Source_Polarity(nCounter::kActiveHigh, &status);
   counter->Gi_Input_Select_Register.setGi_Output_Polarity(outputPolarity, &status);
   counter->Gi_Input_Select_Register.setGi_Gate_Select_Load_Source(nCounter::kDisabled, &status);
   counter->Gi_Input_Select_Register.setGi_Gate_Select(nCounter::kGate_PFI1, &status);
   counter->Gi_Input_Select_Register.setGi_Source_Select(nCounter::kSrc_TB3, &status);
   counter->Gi_Input_Select_Register.setGi_Gate_Polarity(sampClkPolarity, &status);
   counter->Gi_Input_Select_Register.flush(&status);

   // Gi_ABZ_Select_Register doesn't matter

   // Load the trigger delay count
   counter->Gi_Load_A_Register.writeRegister(initialPulseSpecs[1], &status); // Idle
   counter->Gi_Command_Register.writeGi_Load(kTrue, &status);

   // Pre-load the initial pulse period to bank X
   counter->Gi_Load_A_Register.writeRegister(initialPulseSpecs[2], &status); // Active
   counter->Gi_Load_B_Register.writeRegister(initialPulseSpecs[3], &status); // Idle

   //
   // Program the FIFO
   //

   // Gi_DoneNotificationEnable doesn't matter
   counter->Gi_DMA_Config_Register.setGi_WrFifoEnable(kTrue, &status);
   // Gi_WaitForFirstEventOnGate doesn't matter
   counter->Gi_DMA_Config_Register.setGi_DMA_Reset(kTrue, &status);
   counter->Gi_DMA_Config_Register.setGi_DMA_Write(kTrue, &status);
   counter->Gi_DMA_Config_Register.setGi_DMA_Enable(kTrue, &status);
   counter->Gi_DMA_Config_Register.flush(&status);

   /*********************************************************************\
   |
   |   Program DMA
   |
   \*********************************************************************/

   //
   // Create, scale, and print output pulse specifications
   //

   // Generate a pulse train 'chirp' with ~%30 duty cycle
   for (u32 i=0; i<timeSpecs.size(); ++i)
   {
      timeSpecs[i] =   static_cast<f32>(0.05 + 0.02*(i%20)); // Active tick time
      timeSpecs[++i] = static_cast<f32>(0.02 + 0.01*(i%20)); // Idle tick time
   }
   nNISTC3::nGPCTDataHelper::scaleData(timeSpecs, totalNumberOfSamples,
                                       pulseSpecs, totalNumberOfSamples,
                                       scaler);

   nNISTC3::nGPCTDataHelper::printHeader("Pulse spec", "   Active        Idle");
   if (printTime)
   {
      nNISTC3::nGPCTDataHelper::printData(initialTimeSpecs, initialTimeSamples, 2);
      nNISTC3::nGPCTDataHelper::printData(timeSpecs, totalNumberOfSamples, 2);
   }
   else
   {
      nNISTC3::nGPCTDataHelper::printData(initialPulseSpecs, initialTimeSamples, 2);
      nNISTC3::nGPCTDataHelper::printData(pulseSpecs, totalNumberOfSamples, 2);
   }
   printf("\n");

   //
   // Configure DMA channel
   //

   std::auto_ptr<nNISTC3::tCHInChDMAChannel> dma(new nNISTC3::tCHInChDMAChannel(device, dmaChannel, status));
   if (status.isFatal())
   {
      printf("Error: DMA channel initialization (%d).\n", status);
      return;
   }
   dma->reset(status);

   dma->configure(bus, dmaTopology, nNISTC3::kOut, dmaSizeInBytes, status);
   if (status.isFatal())
   {
      printf("Error: DMA channel configuration (%d).\n", status);
      return;
   }

   //
   // Prime DMA buffer
   //

   for (u32 i=0; i<dmaBufferFactor; ++i)
   {
      dma->write(writeSizeInBytes, reinterpret_cast<u8 *>(&pulseSpecs[0]), &availableSpace, allowRegeneration, &dataRegenerated, status);
      if (status.isFatal())
      {
         printf("Error: DMA write (%d).\n", status);
         return;
      }

      bytesWritten += writeSizeInBytes;
   }

   //
   // Start DMA channel
   //

   dma->start(status);
   if (status.isFatal())
   {
      printf("Error: DMA channel start (%d).\n", status);
      return;
   }

   streamHelper.configureForOutput(onboardRegen, dmaChannel, status);
   if (onboardRegen)
   {
      streamHelper.modifyTransferSize(dmaSizeInBytes, status);
   }
   streamHelper.enable(status);

   /*********************************************************************\
   |
   |   Start the pulse train generation
   |
   \*********************************************************************/

   //
   // Wait for data to enter the FIFO
   //

   if (onboardRegen)
   {
      // Wait for all data to be placed in the counter FIFO
      rlpElapsedTime = 0;
      rlpStart = clock();
      while (counter->Gi_FifoStatusRegister.readRegister(&status) < totalNumberOfSamples)
      {
         // Spin until the counter FIFO has all of the data
         if (rlpElapsedTime > rlpTimeout)
         {
            printf("Error: Pulse specifications did not load into FIFO within timeout.\n");
            status.setCode(kStatusRLPTimeout);
            return;
         }
         rlpElapsedTime = static_cast<f64>(clock() - rlpStart) / CLOCKS_PER_SEC;
      }
   }
   else
   {
      // Wait for data to enter the counter FIFO
      rlpElapsedTime = 0;
      rlpStart = clock();
      while (counter->Gi_FifoStatusRegister.readRegister(&status) < 1)
      {
         // Spin until the counter FIFO is no longer empty
         if (rlpElapsedTime > rlpTimeout)
         {
            printf("Error: Counter FIFO did not receive data within timeout.\n");
            status.setCode(kStatusRLPTimeout);
            return;
         }
         rlpElapsedTime = static_cast<f64>(clock() - rlpStart) / CLOCKS_PER_SEC;
      }
   }

   //
   // Prime the counter
   //

   // Load the first pulse period to bank Y from the FIFO
   counter->Gi_Mode2_Register.writeGi_Bank_Switch_Enable(nCounter::kEnabled_If_Armed_Else_Write_To_Y, &status);
   counter->Gi_Command_Register.writeGi_WrLoadRegsFromFifo(kTrue, &status);
   rlpElapsedTime = 0;
   rlpStart = clock();
   while (counter->Gi_Status_Register.readGi_ForcedWrFromFifoInProgSt(&status))
   {
      // Wait for the counter to finish loading from the FIFO
      if (rlpElapsedTime > rlpTimeout)
      {
         printf("Error: Counter did not load data from FIFO within timeout.\n");
         status.setCode(kStatusRLPTimeout);
         return;
      }
      rlpElapsedTime = static_cast<f64>(clock() - rlpStart) / CLOCKS_PER_SEC;
   }

   //
   // Arm and start the counter subsystem
   //

   printf("Generating continuous pulse train from the %s for %.2f seconds.\n", onboardRegen ? "device" : "host", runTime);
   counter->Gi_Command_Register.writeGi_Arm(kTrue, &status);

   // Wait for the counter to arm
   rlpElapsedTime = 0;
   rlpStart = clock();
   while (counter->Gi_Status_Register.readGi_Armed_St(&status) == nCounter::kNot_Armed)
   {
      // Spin on the Gi Armed state
      if (rlpElapsedTime > rlpTimeout)
      {
         printf("Error: Counter did not arm within timeout.\n");
         status.setCode(kStatusRLPTimeout);
         return;
      }
      rlpElapsedTime = static_cast<f64>(clock() - rlpStart) / CLOCKS_PER_SEC;
   }

   /*********************************************************************\
   |
   |   Wait for the generation to complete
   |
   \*********************************************************************/

   start = clock();
   while (elapsedTime < runTime)
   {
      // Check for counter subsystem errors
      counter->Gi_Status_Register.refresh(&status);
      writesTooFastError = counter->Gi_Status_Register.getGi_WritesTooFastErrorSt(&status);
      gateSwitchError = counter->Gi_Status_Register.getGi_GateSwitchError_St (&status);
      sampleClockOverrun = counter->Gi_Status_Register.getGi_SampleClockOverrun_St(&status);
      DRQ_Error = counter->Gi_Status_Register.getGi_DRQ_Error(&status);

      if (writesTooFastError || gateSwitchError || sampleClockOverrun || DRQ_Error)
      {
         gpctErrored = kTrue;
         break;
      }

      // Wait for the run time to expire.
      //   For on-board regeneration, the FIFO will continually loop.
      //   For host regeneration, the DMA buffer will continually loop.
      // In either case, further writes are not necessary.
      elapsedTime = static_cast<f64>(clock() - start) / CLOCKS_PER_SEC;
   }

   /*********************************************************************\
   |
   |   Stop the pulse train generation
   |
   \*********************************************************************/

   //
   // Stop the counter subsystem
   //

   counter->Gi_Command_Register.writeGi_Disarm(kTrue, &status);

   // Wait for the counter to disarm
   rlpElapsedTime = 0;
   rlpStart = clock();
   while (counter->Gi_Status_Register.readGi_Armed_St(&status) == nCounter::kArmed)
   {
      // Spin on the Gi Armed state
      if (rlpElapsedTime > rlpTimeout)
      {
         printf("Error: Counter did not disarm within timeout.\n");
         status.setCode(kStatusRLPTimeout);
         return;
      }
      rlpElapsedTime = static_cast<f64>(clock() - rlpStart) / CLOCKS_PER_SEC;
   }

   //
   // Disable DMA on the device and stop the CHInCh DMA channel
   //

   streamHelper.disable(status);
   dma->stop(status);

   /*********************************************************************\
   |
   |   Finalize the generation
   |
   \*********************************************************************/

   //
   // Print run-time summary
   //

   if (writesTooFastError)
   {
      printf("Error: Counter updated before valid gate switch.\n");
      status.setCode(kStatusRuntimeError);
   }
   if (gateSwitchError)
   {
      printf("Error: Sample clock arrived before counter ready to switch.\n");
      status.setCode(kStatusRuntimeError);
   }
   if (sampleClockOverrun)
   {
      printf("Error: Sample clock overrun.\n");
      status.setCode(kStatusRuntimeError);
   }
   if (DRQ_Error)
   {
      printf("Error: DMA request error.\n");
      status.setCode(kStatusRuntimeError);
   }
   if (!gpctErrored)
   {
      printf("Finished generating continuous pulse train from the %s for %.2f seconds.\n", onboardRegen ? "device" : "host", runTime);
      printf("Generated %u-pulse pulse train (%u total samples) %s.\n",
         numberOfPulses,
         bytesWritten/sampleSizeInBytes,
         dataRegenerated ? "by regenerating old data" : "without regenerating old data");
   }

   //
   // Restore the state of the device
   //

   // Nothing else to do: the helpers' destructors safely unwind device state.
}
