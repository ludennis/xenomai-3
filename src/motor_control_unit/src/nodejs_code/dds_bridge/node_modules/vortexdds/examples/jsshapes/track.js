/*
 *                         Vortex OpenSplice
 *
 *   This software and documentation are Copyright 2006 to 2019 ADLINK
 *   Technology Limited, its affiliated companies and licensors. All rights
 *   reserved.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

/* This script demonstrates status conditions, query conditions and waitsets.
   It reads a blue circle from demo_ishapes and publishes a red square to the
   same position it read the blue circle from.
   Usage: 1. start demo_ishapes
          2. in ishapes demo, publish a blue circle
          3. in ishapes demo, subscribe to a square
          4. run 'node track.js'
*/

'use strict';

const dds = require('vortexdds');
const path = require('path');
const util = require('util');

main();

function main(){
  readCircleWriteSquare().then(() => {
    console.log('=== Track shapes end');
    process.exit(0);
  }).catch((error) => {
    console.log('Error: ' + error.message);
    process.exit(1);
  });
}

async function readCircleWriteSquare() {

  console.log('=== Track shapes start');

  let participant = null;
  try {
    participant = new dds.Participant();

    // set up our topic
    const idlName = 'ishape.idl';
    const idlPath = __dirname + path.sep + idlName;

    const typeSupports = await dds.importIDL(idlPath);
    const typeSupport = typeSupports.get('ShapeType');

    let topicqosprovider = null;
    let tqos = null;
    let circleTopic = null;
    let squareTopic = null;
    try {
      topicqosprovider = new dds.QoSProvider(
        __dirname + path.sep + 'DDS_PersistentQoS_All.xml',
        'DDS PersistentQosProfile'
      );

      tqos = topicqosprovider.getTopicQos();
      circleTopic = participant.createTopic(
        'Circle',
        typeSupport,
        tqos
      );

      squareTopic = participant.createTopic(
        'Square',
        typeSupport,
        tqos
      );
    } finally {
      if (topicqosprovider !== null){
        topicqosprovider.delete();
      }
    }

    let readerqosprovider = null;
    let rqos = null;
    let circleReader = null;
    try {
      // our blue circle reader reader has volatile qos
      readerqosprovider = new dds.QoSProvider(
        __dirname + path.sep + 'DDS_VolatileQoS_All.xml',
        'DDS VolatileQosProfile'
      );
      rqos = readerqosprovider.getReaderQos();

      // set up reader for the blue circle
      circleReader = participant.createReader(
        circleTopic,
        rqos
      );
    } finally {
      if (readerqosprovider !== null){
        readerqosprovider.delete();
      }
    }

    // our square writer has default QoS
    const squareWriter = participant.createWriter(squareTopic);

    let condition = null;
    let pubWaitset = null;
    try {
      // set up our status condition, which is for matching the publication
      // with the square topic
      condition = squareWriter
        .createStatusCondition(dds.StatusMask.publication_matched);
      pubWaitset = new dds.Waitset(condition);

      console.log('Waiting for demo_ishapes to subscribe to a square...');
      await pubWaitset.wait(dds.SEC_TO_NANO(10));
    } finally {
      if (pubWaitset !== null){
        pubWaitset.delete();
      }
    }

    console.log('Waiting for demo_ishapes to publish a blue circle...');
    await readBlueCircleWriteRedSquare(circleReader, squareWriter);

  } finally {
    console.log('=== Cleanup resources');
    if (participant !== null){
      participant.delete().catch((error) => {
        console.log('Error cleaning up resources: '
          + error.message);
      });
    }
  }

}

async function readBlueCircleWriteRedSquare(
  circleReader,
  squareWriter,
) {
  let queryCond = null;
  let queryWaitset = null;
  try {
    // set up a waitset on our circle reader for the query condition
    // (shape read = blue circle)
    const mask = dds.StateMask.sample.not_read;
    const sqlExpression = 'color=%0';
    const params = ['BLUE'];

    queryCond = circleReader.createQueryCondition(mask, sqlExpression, params);
    queryWaitset = new dds.Waitset(queryCond);

    for (let i = 0; i < 100; i++) {
      await queryWaitset.wait(dds.SEC_TO_NANO(10));
      let sampleArray = circleReader.takeCond(1, queryCond);
      if (sampleArray.length > 0 && sampleArray[0].info.valid_data) {
        let sample = sampleArray[0].sample;
        console.log(
          util.format(
            '%s %s of size %d at (%d,%d)',
            sample.color,
            'Circle',
            sample.shapesize,
            sample.x,
            sample.y
          )
        );
        await squareWriter.writeReliable({
          color: 'RED',
          x: sample.x,
          y: sample.y,
          shapesize: 45,
        });
      }
    }

  } finally {
    if (queryWaitset !== null){
      queryWaitset.delete();
    }
  }
}
