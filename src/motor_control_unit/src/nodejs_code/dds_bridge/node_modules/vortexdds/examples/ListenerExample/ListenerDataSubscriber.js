/*
 *                         Vortex OpenSplice
 *
 *   This software and documentation are Copyright 2006 to 2019 ADLINK
 *   Technology Limited, its affiliated companies and licensors. All rights
 *   reserved.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

/*
    Listener example.
    Instructions: 1. Run nodejs ListenerDataPublisher.js
                  2. Run nodejs ListenerDataSubscriber.js
                  You may run these in any order.
*/

'use strict';

const dds = require('vortexdds');
const path = require('path');

main();

function main() {
  subscribeData().then(() => {
    console.log('=== ListenerDataSubscriber end');
    process.exit(0);
  }).catch((error) => {
    console.log('Error: ' + error.message);
    process.exit(1);
  });
}

async function subscribeData() {

  console.log('=== ListenerDataSubscriber start');

  let participant = null;
  try {
    participant = new dds.Participant();

    const topicName = 'ListenerDataMsgTopic';
    const idlName = 'ListenerData.idl';
    const idlPath = __dirname + path.sep + idlName;
    const typeSupports = await dds.importIDL(idlPath);
    const typeSupport = typeSupports.get('ListenerData::Msg');

    const topic = participant.createTopic(topicName, typeSupport);

    let listenerSubMatchedTriggered = false;
    // eslint-disable-next-line no-unused-vars
    let reader = participant.createReader(
      topic,
      null,
      {
        onSubscriptionMatched: function(entity, status) {
          if (!listenerSubMatchedTriggered) {
            console.log('=== [ListenerDataSubscriber] ' +
            'onSubscriptionMatched triggered');
            console.log('    status.totalCount: ', status.totalCount);
            console.log('    status.totalCountChange: ',
              status.totalCountChange);
            listenerSubMatchedTriggered = true;
          }
        },
      }
    );
    console.log('reader created');

    // Creating a promise to run the program until the listener gets triggered
    let waitForWriterPromise = new Promise((resolve, reject) => {
      console.log('=== [ListenerDataSubscriber] promise created');
      let intervalObject = setInterval(function() {
        if (listenerSubMatchedTriggered) {
          clearInterval(intervalObject);
          resolve(0);
        }
      }, 1000);
    });
    await waitForWriterPromise;

  } finally {
    console.log('=== [ListenerDataSubscriber] cleanup resources');
    if (participant !== null) {
      participant.delete().catch((error) => {
        console.log('Error cleaning up resources: '
          + error.message);
      });
    }
  }
}
