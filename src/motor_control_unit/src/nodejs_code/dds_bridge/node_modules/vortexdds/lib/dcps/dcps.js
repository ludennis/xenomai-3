/*
 *                         Vortex OpenSplice
 *
 *   This software and documentation are Copyright 2006 to 2019 ADLINK
 *   Technology Limited, its affiliated companies and licensors. All rights
 *   reserved.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

'use strict';

/**
 * Module defining Vortex DDS API for Node JS.
 *
 * @module vortexdds
 */
const ddsc99 = require('./ddsc99');
const ddsqos = require('./qos');
const qosc99 = require('./qosc99');
const ddstopic = require('./ddstopic');
const ddserr = require('./ddserr');
const check = require('check-types');
const ref = require('ref');

/* Disable line-length check while we declare external
 * dependencies with long URLs
 */
/* eslint-disable max-len */
/**
 * The standard built-in Array type
 * @external Array
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array
 * @alias external:Array
 */
/* eslint-enable max-len */

// ///////////////// QoS Policy typedefs ///////////////////////
// / Moved from qos.js because they screw up jsdoc generation //
// /
/**
 * @typedef {Object} DataPolicy
 * A QoS policy that enables the programmer
 * to specified data to be included as part
 * of the QoS for Topic (TopicData),
 * Subscriber (GroupData)
 * and Reader (UserData) entities.
 * @property {string|external:Buffer} value - A string value
 * (which will be ISO-8859-1 encoded to a Buffer)
 * or a Buffer (which will be ininterpreted) that is
 * attached to the entity's QoS.
 * @alias module:vortexdds.DataPolicy
 */

/**
 * @typedef {Object} DurabilityPolicy
 * Defines the fields of the
 * {@link module:vortexdds.QoS#durability|durability}
 * QoS policy.
 * @property {module:vortexdds.DurabilityKind} kind - the kind
 * of durability to employ.
 *
 * @alias module:vortexdds.DurabilityPolicy
 */

/**
 * @typedef {Object} HistoryPolicy
 * Defines the fields of the
 * {@link module:vortexdds.QoS#history|history}
 * QoS policy.
 * @property {module:vortexdds.HistoryKind} kind - the kind
 * of history to maintain.
 * @property {number} depth - Applicable only if kind is KeepLast.
 *
 * @alias module:vortexdds.HistoryPolicy
 */

/**
 * @typedef {Object} ResourceLimitsPolicy
 * Defines the fields of the
 * {@link module:vortexdds.QoS#resourceLimits|resourceLimits}
 * QoS policy.
 * @property {number} maxSamples - specifies the maximum number of
 * data-samples the Writer (or
 * Reader) can manage across all
 * the instances associated with it.
 * Represents the maximum samples
 * the middleware can store for any
 * one Writer (or Reader). It
 * is inconsistent for this value to be
 * less than
 * *maxSamplesPerInstance*.
 * By default,
 * LENGTH_UNLIMITED.
 * @property {number} maxInstances - Represents the maximum number of
 * instances a Writer (or
 * Reader) can manage.
 * By default,
 * LENGTH_UNLIMITED.
 * @property {number} maxSamplesPerInstance - Represents the maximum number of
 * samples of any one instance a
 * Writer (or Reader) can manage. It is inconsistent for this
 * value to be greater than *maxSamples*. By default,
 * LENGTH_UNLIMITED.
 *
 * @alias module:vortexdds.ResourceLimitsPolicy
 */

/**
 * @typedef {Object} PresentationPolicy
 * Defines the fields of the
 * {@link module:vortexdds.QoS#presentation|presentation}
 * QoS policy.
 * @property {module:vortexdds.PresentationAccessScopeKind} accessScope - the
 * presentation access scope. Note that only *Instance* is supported by this
 * API.
 * @property {boolean} coherentAccess - Specifies support coherent access.
 * That is, the ability to group a set of changes as a unit on the publishing
 * end such that they are received as a unit at the subscribing end.
 * @property {boolean} orderedAccess - Specifies support for ordered access to
 * the samples received at the subscription end. That is, the ability of the
 * Subscriber to see changes in the same order as they occurred on the
 * publishing end.
 *
 * @alias module:vortexdds.PresentationPolicy
 */

/**
 * @typedef {Object} LifespanPolicy
 * Defines the fields of the
 * {@link module:vortexdds.QoS#lifespan|lifespan}
 * QoS policy.
 *
 * @property {number|string} lifespan - Expiration time (in nanoseconds)
 * relative to source timestamp beyond which the sample shall
 * be removed from the caches.
 *
 * @alias module:vortexdds.LifespanPolicy
 */

/**
 * @typedef {Object} DeadlinePolicy
 * Defines the fields of the
 * {@link module:vortexdds.QoS#deadline|deadline}
 * QoS policy.
 *
 * @property {number|string} deadline - Reader expects a new sample updating
 * the value of each instance at least once every deadline period.
 * Writer indicates that the application commits to write a new
 * value (using the Writer) for each instance managed by the Writer at least
 * once every deadline period.
 * It is inconsistent for a reader to have a *deadline* period less than
 * its {@link module:vortexdds.QoS#timebasedFilter|timebasedFilter}'s
 * *minimumSeparation*. The default value of the
 * deadline period is infinite.
 *
 * @alias module:vortexdds.DeadlinePolicy
 */

/**
 * @typedef {Object} LatencyBudgetPolicy
 * Defines the fields of the
 * {@link module:vortexdds.QoS#latencyBudget|latencyBudget}
 * QoS policy.
 * @property {number|string} duration - Specifies the maximum acceptable delay
 * (in nanoseconds) from the time the data is written until the data is
 * inserted in the receiver's application-cache and the receiving
 * application is notified of the fact
 *
 * @alias module:vortexdds.LatencyBudgetPolicy
 */

/**
 * @typedef {Object} OwnershipPolicy
 * Defines the fields of the
 * {@link module:vortexdds.QoS#ownership|ownership}
 * QoS policy.
 * @property {module:vortexdds.OwnershipKind} kind - selects
 * the kind of ownership to be implemented.
 *
 * @alias module:vortexdds.OwnershipPolicy
 */

/**
 * @typedef {Object} OwnershipStrengthPolicy
 * Defines the fields for the
 * {@link module:vortexdds.QoS#ownershipStrength|ownershipStrength}
 * QoS policy.
 * @property {number} value - Specifies the value of the
 * “strength” used to arbitrate among multiple DataWriter
 * objects that attempt to modify the same instance
 * of a data-object (identified by Topic + key).
 * This policy only applies if the
 * {@link module:vortexdds.QoS#ownership|ownership}
 * QoS policy is of *kind* *Exclusive*. The default
 * value of the ownership_strength is zero.
 */

/**
 * @typedef {Object} LivelinessPolicy
 * Defines the fields of the
 * {@link module:vortexdds.QoS#liveliness|liveliness}
 * QoS policy.
 * @property {module:vortexdds.LivelinessKind} kind - the
 * kind of livilness policy to implement.
 * @property {number|string} leaseDuration - the duration (in
 * nanoseconds) of the interval
 * within which liveliness must be reported.
 */

/**
 * @typedef {Object} TimebasedFilterPolicy
 * Defines the fields of the
 * {@link module:vortexdds.QoS#timebasedFilter|timebasedFilter}
 * QoS policy.
 * @property {number|string} minimumSeparation - the minimum amount of
 * time (in nanoseconds) by which the Reader wants samples it
 * receives to be separated, regardsless of how fast the changes occur.
 * It is inconsistent for a Reader to have a *minimumSeparation*
 * longer than its
 * {@link module:vortexdds.QoS#deadline|deadline}
 * policy period. By default minimumSeparation is zero,
 * indicating Reader is potentially interested in all values.
 *
 * @alias module:vortexdds.TimebasedFilterPolicy
 */

/**
 * @typedef {Object} PartitionPolicy
 * Defines the fields of the
 * {@link module:vortexdds.QoS#partition|partition}
 * QoS policy.

  * @property {string|string[]} names - A partiton name or an
  * array of partition names
  */

/**
 * @typedef {Object} ReliabilityPolicy
 * Defines the fields on the
 * {@link module:vortexdds.QoS#reliability|reliability}
 * QoS policy.
 * @property {module:vortexdds.ReliabilityKind} kind - the
 * reliability policy kind.
 * @property {number|string} maxBlockingTime - the maximum time the
 * operation Writer *write* operation is allowed to block if
 * the Writer does not have space to store the value written.
 * The default is 100ms (100,000,000ns).
 *
 * @alias module:vortexdds.ReliabilityPolicy
 */

/**
 * @typedef {Object} TransportPriorityPolicy
 * Defines the fields of the
 * {@link module:vortexdds.QoS#transportPriority|transportPriority}
 * QoS policy.
 * @property {number} value - a hint to the infrastructure as to how to
 * set the priority of the underlying transport used to send the data.
 * The default value is zero.
 */

/**
 * @typedef {Object} DestinationOrderPolicy
 * Defines the fields of the
 * {@link module:vortexdds.QoS#destinationOrder|destinationOrder}
 * QoS policy.
 * @property {module:vortexdds.DestinationOrderKind} kind - the
 * kind of ordering to use.
 *
 * @alias module:vortexdds.DestinationOrderPolicy
 */

/**
 * @typedef {Object} WriterDataLifecyclePolicy
 * Defines the fields of the
 * {@link module:vortexdds.QoS#writerDataLifecycle|
 * writerDataLifecyle} QoS policy.
 * @property {boolean} autodisposeUnregisteredInstances - Controls
 * whether a Writer will automatically dispose instances each time
 * they are unregistered. A value of *true* indicates that unregistered
 * instances will also be considered disposed.
 * The default value is *true*.
 */

/**
 * @typedef {Object} ReaderDataLifecyclePolicy
 * Defines the fields of the
 * {@link module:vortexdds.QoS#readerDataLifecycle|
 * readerDataLifecycle}
 * QoS policy.
 * @property {number} autopurgeNoWriterSamples - Indicates the duration
 * (in nanoseconds) the Reader must retain information regarding instances
 * that have the
 * {@link module:vortexdds.StateMask|instance state}
 * *not_alive_no_writers*.
 * The default value is infinite.
 * @property {number|string} autopurgeDisposedSamplesDelay - Indicates
 * the duration (in nanoseconds) the Reader must retain information
 * regarding instances that have the instance state
 * {@link module:vortexdds.StateMask|instance state}
 * *not_alive_disposed*.
 * The default value is infinite.
 */

/**
 * @typedef {Object} DurabilityServicePolicy
 * Defines the fields of the
 * {@link module:vortexdds.QoS#durabilityService|durabilityService}
 * QoS policy.
 * @property {number|string} serviceCleanupDelay - a time in nanoseconds
 * after which the durability
 * service can remove all information regarding a data-instance
 * @property {module:vortexdds.HistoryKind} historyKind - controls
 * the
 * {@link module:vortexdds.QoS#history|history}
 * QoS of the fictitious Reader that stores the data within the
 * durability service.
 * The default value is KeepLast.
 * @property {number} historyDepth - controls
 * the
 * {@link module:vortexdds.QoS#history|history}
 * QoS of the fictitious Reader that stores the data within the
 * durability service.
 * The default value is 1.
 * @property {number} maxSamples - Controls the
 * {@link module:vortexdds.QoS#resourceLimits|resourceLimits}
 * QoS of the durability server Reader.
 * The default value is LENGTH_UNLIMITED.
 * @property {number} maxInstances - Controls the
 * {@link module:vortexdds.QoS#resourceLimits|resourceLimits}
 * QoS of the durability server Reader.
 * The default value is LENGTH_UNLIMITED.
 * @property {number} maxSamplesPerInstance - Controls the
 * {@link module:vortexdds.QoS#resourceLimits|resourceLimits}
 * QoS of the durability server Reader.
 * The default value is LENGTH_UNLIMITED.
 */

/**
 * @typedef {Object} QosPolicies
 * Defines the availabe policies for a
 * {@link module:vortexdds.QoS|QoS} object.
 * @property {module:vortexdds~DataPolicy}
 * [userdata] - an object for defining userdata QoS policy
 * @property {module:vortexdds~DataPolicy}
 * [topicdata] - an object for defining topicdata QoS policy
 * @property {module:vortexdds~DataPolicy}
 * [groupdata] - an object for defining groupdata QoS policy
 * @property {module:vortexdds~DurabilityPolicy}
 * [durability] - an object for defining durability QoS policy
 * @property {module:vortexdds~HistoryPolicy}
 * [history] - an object for defining history QoS policy
 * @property {module:vortexdds~ResourceLimitsPolicy}
 * [resourceLimits] - an object for defining resource limits QoS policy
 * @property {module:vortexdds~PresentationPolicy}
 * [presentation] - an object for defining presentation QoS policy
 * @property {module:vortexdds~LifespanPolicy}
 * [lifespan] - an object for defining lifespan QoS policy
 * @property {module:vortexdds~DeadlinePolicy}
 * [deadline] - an object for defining deadline QoS policy
 * @property {module:vortexdds~LatencyBudgetPolicy}
 * [latencyBudget] - an object for defining latency budget QoS policy
 * @property {module:vortexdds~OwnershipPolicy}
 * [ownership] - an object for defining ownership QoS policy
 * @property {module:vortexdds~OwnershipStrengthPolicy}
 * [ownershipStrength] - an object for defining ownership strength QoS policy
 * @property {module:vortexdds~LivelinessPolicy}
 * [liveliness] - an object for defining liveliness QoS policy
 * @property {module:vortexdds~TimebasedFilterPolicy}
 * [timebasedFilter] - an object for defining time based filter QoS policy
 * @property {module:vortexdds~PartitionPolicy}
 * [partition] - an object for defining partition QoS policy
 * @property {module:vortexdds~ReliabilityPolicy}
 * [reliability] - an object for defining reliability QoS policy
 * @property {module:vortexdds~TransportPriorityPolicy}
 * [transportPriority] - an object for defining transport priority QoS policy
 * @property {module:vortexdds~DestinationOrderPolicy}
 * [destinationOrder] - an object for defining destination order QoS policy
 * @property {module:vortexdds~WriterDataLifecyclePolicy}
 * [writerDataLifecycle] - an object for defining writer data
 * lifecycle QoS policy
 * @property {module:vortexdds~ReaderDataLifecyclePolicy}
 * [readerDataLifecycle] - an object for defining reader data
 * lifecycle QoS policy
 * @property {module:vortexdds~DurabilityServicePolicy}
 * [durabilityService] - an object for defining durability service QoS policy
 *
 * @alias module:vortexdds.QoSPolices
 */

// // Other Typedefs

/**
 * Defines the information returned about a data sample returned by a
 * {@link module:vortexdds.Reader|Reader}.
 * @typedef {Object} SampleData
 * @property {Object} sample the sample. A full sample if *info.valid_data*
 * is *true*, otherwise contains key fields only.
 * @property {module:vortexdds~SampleInfo} info properties of the sample
 * @alias module:vortexdds.SampleData
 */

/**
 * A collection of constants use for expressing DDS 'state masks'.
 *
 * State masks are used to creating
 * {@link module:vortexdds.ReadCondition|ReadCondition}s
 * and
 * {@link module:vortexdds.QueryCondition|QueryCondition}s.
 * They are use returned as part of the
 * {@link module:vortexdds.SampleInfo|SampleInfo}
 * object returned by operations such as
 * by
 * {@link module:vortexdds.Reader#read|Reader.read()}
 * and
 * {@link module:vortexdds.Reader#take|Reader.take()}.
 *
 * The state of a DDS sample is the union of three substates:
 * sample, view and instance.
 * - Sample state indicates whether the sample has been previously
 * been returned by the DDS
 * {@link module:vortexdds.Reader|Reader}.
 * The sample state may be
 * either *read* or *not_read*.
 * - View state indicates whether the key values of the sample have
 * previously been returned by the DDS
 * {@link module:vortexdds.Reader|Reader}.
 * The view state may be
 * either *new* or *not_new*.
 * - Instance state indicates whether state of the instance represented
 * by the key values of the sample.
 * The instance state may be
 * one of *alive*, *not_alive_disposed* or *not_alive_no_writers*.
 *
 * A 'state mask' may be composed by indicate the sub-states that
 * your are interested in accepting. For example, a mask that would accept
 * disposed samples that had previously been seen by your data reader:
 *
 *     const dds = require('vortexdds');
 *     const disposeMask = dds.StateMask.sample.any
 *         | dds.StateMask.view.not_new
 *         | dds.StateMask.instance.not_alive_disposed;
 *
 * @constant
 * @property {object} sample  Sample State
 * @property {number} sample.read       Sample read
 * @property {number} sample.not_read   Sample not read
 * @property {number} sample.any        Either of the above
 * @property {object} view              View State
 * @property {number} view.new          First time the Data Reader has accessed
 *                                      samples of this instance
 * @property {number} view.not_new      The Data Reader has already accessed
 *                                      samples of this intance before
 * @property {number} view.any          Either of the above
 * @property {object} instance          Instance State
 * @property {number} instance.alive    Samples have been received for this
 *                                      instance, there are live data writers
 *                                      for this instance, and the instance is
 *                                      not disposed
 * @property {number} instance.not_alive_disposed   The instance has been
 *                                                  explicitly disposed
 * @property {number} instance.not_alive_no_writers There are no live Data
 *                                                  Writers
 * @property {number} instance.any                  Any of the above
 *
 * @alias module:vortexdds.StateMask
 */

const StateMask = Object.freeze({
  sample: Object.freeze({
    read: 1,
    not_read: 2,
    any: 1 | 2,
  }),
  view: Object.freeze({
    new: 4,
    not_new: 8,
    any: 4 | 8,
  }),
  instance: Object.freeze({
    alive: 16,
    not_alive_disposed: 32,
    not_alive_no_writers: 64,
    any: 16 | 32 | 64,
  }),
  any: (1 | 2) | (4 | 8) | (16 | 32 | 64),
});

/**
 * Constants representing DDS communication statuses.
 *
 * Status masks are a combination of one or more of these constants,
 * and are used to indicate to DDS which communication statuses
 * are of interest to you status listeners.
 *
 * @readonly
 * @enum {number}
 * @alias module:vortexdds.StatusMask
 */
const StatusMask = {
  /** New data available. Applies to Subscribers. */
  data_available: 1024,
  /** New data available. Applies to a Readers. */
  data_on_readers: 512,
  /**
   * Another topic with the same name but
   * different characteristics exists.
   * Applies to Topics.
   */
  inconsistent_topic: 1,
  /**
   * The liveliness QoS policy has been violated.
   * Applies to Writers.
   */
  liveliness_changed: 4096,
  /**
   * The liveliness QoS policy has been
   * violated. Applies to Writers.
   */
  liveliness_lost: 2048,
  /**
   * The deadline QoS policy has been
   * violated. Applies to Writers.
   */
  offered_deadline_missed: 2,
  /**
   * A QoS policy was incompatible with what was requested.
   * Applies to Writers.
   */
  offered_incompatible_qos: 32,
  /**
   * The number of matching Readers has changed.
   * Applies to Writers.
   */
  publication_matched: 8192,
  /**
   * The deadline that a Reader expected through a QoS policy
   * was violated. Applies to Readers.
   */
  requested_deadline_missed: 4,
  /**
   * A QoS policy was incompatible with what was offered.
   * Applies to Readers.
   */
  requested_incompatible_qos: 64,
  /**
   * A sample was never received.
   * Applies to Readers.
   */
  sample_lost: 128,
  /**
   * A sample was rejected.
   * Applies to Readers.
   */
  sample_rejected: 256,
  /**
   * The number of matching Writers has changed.
   * Applies to Readers.
   */
  subscription_matched: 16384,
};

/**
 * Constants representing reasons for a sample being rejected.
 * @enum {number}
 * @readonly
 * @alias module:vortexdds.SampleRejectedStatusKind
 */
const SampleRejectedStatusKind = {
  /**
   * The sample was not rejected
   */
  NOT_REJECTED: 0,
  /**
   * The limit imposed by the QoS
   * {@link module:vortexdds.QoS#resourceLimits|
   * resourceLimits} policy
   * *maxInstances*
   * has been exceeded.
   */
  BY_INSTANCES_LIMIT: 1,
  /**
   * The limit imposed by the QoS
   * {@link module:vortexdds.QoS#resourceLimits|
   * resourceLimits} policy
   * *maxSamples*
   * has been exceeded.
   */
  BY_SAMPLES_LIMIT: 2,
  /**
   * The limit imposed by the QoS
   * {@link module:vortexdds.QoS#resourceLimits|
   * resourceLimits} policy
   * *maxSamplesPerInstance*
   * has been exceeded.
   */
  BY_SAMPLES_PER_INSTANCE_LIMIT: 3,
};

/**
 * Miscellaneous DDS constants
 * @enum number
 * @readonly
 * @alias module:vortexdds.DDSConstants
 */
const DDSConstants = {
  /**
   * specified unlimited length in multiple QoS policies:
   * - {@link module:vortexdds.QoS#resourceLimits|resourceLimits}
   * fields: *maxInstances*, *maxSamples*, *maxInstancesPerSample*
   * - {@link module:vortexdds.QoS#history|history}
   * fields: *depth*
   * - {@link module:vortexdds.QoS#durabilityService|durabilityService}
   * fields: *maxInstances*, *maxSamples*, *maxInstancesPerSample*,
   * *historyDepth*
   */
  DDS_LENGTH_UNLIMITED: -1,
  /**
   * specifies the default domain when creating a
   * {@link module:vortexdds.Participant|Participant}.
   */
  DDS_DOMAIN_DEFAULT: 0x7FFFFFFF,
  /** DO NOT USE. */
  DDS_HANDLE_NIL: 0,
  /**
   * specifies an infinite duration in multiple QoS policies
   * and some method calls.
   */
  DDS_INFINITY: '0x7FFFFFFFFFFFFFFF',
  /**
   * DO NOT USE. Use {@link module:vortexdds.DDSErrorCode.TIMEOUT
   * DDSErrorCode.TIMEOUT}
   */
  DDS_RETCODE_TIMEOUT: ddserr.DDSErrorCode.TIMEOUT,
};

/**
 * Provides information on a sample read from a
 * {@link module:vortexdds.Reader|Reader}.
 * @typedef {Object} SampleInfo
 * @property {module:vortexdds.StateMask} sample_state whether the sample
 * is currently 'alive' or 'not alive'
 * @property {module:vortexdds.StateMask} instance_state whether this
 * key values of the sample have been previously read or not by the Reader.
 * @property {module:vortexdds.StateMask} view_state whether this
 * particular sample has been previously read or not by the Reader.
 * @property {boolean} valid_data if *true*, the sample returned contains
 * all fields defined by the topic type, otherwise, only the key fields
 * defined in the topic type have values.
 * @property {number|string} source_timestamp Timestamp provided by the
 * Writer at the time the sample was produced.
 * Represents a 64-bit value. May be a string
 * if the JavaScript numeric representation would result in
 * a loss of precision.
 * @property {number|string} instance_handle Instance handle of the sample.
 * Represents a 64-bit value. May be a string
 * if the JavaScript numeric representation would result in
 * a loss of precision.
 * @property {number|string} publication_handle Publication handle of
 * the sample.
 * Represents a 64-bit value. May be a string
 * if the JavaScript numeric representation would result in
 * a loss of precision.
 * @property {number} disposed_generation_count Number of times the instance
 * has become alive after it was disposed explicitly by a Writer
 * @property {number} no_writers_generation_count Number of times the instance
 * has become alive after it was disposed because there were to alive
 * Writers at the time the sample was received
 * @property {number} sample_rank Number of samples that follow this one, in
 * the array returned by read,take,readCond or takeCond
 * @property {number} generation_rank The generation difference between the
 * time this sample was received, and the time the latest sample in the array
 * returned by read,take,readCond and takeCond was received
 * @property {number} absolute_generation_rank The generation difference between
 * the time this sample was received, and the time the latest sample that the
 * Reader has received related to this instance
 * @property {number|string} reception_timestamp The time when the Reader has
 * received this sample.
 * Represents a 64-bit value. May be a string
 * if the JavaScript numeric representation would result in
 * a loss of precision.
 */

// //////////// DDS Status object definitions ////////////////////

/**
 * @typedef {Object} RequestedDeadlineMissedStatus
 * @property {number} totalCount total cumulative number of missed
 * deadlines detected for any instance read by the Reader.
 * Missed deadlines accumulate; that is, each deadline period
 * the totalCount will be incremented by one for each instance
 * for which data was not received.
 * @property {number} totalCountChange the incremental number of
 * deadlines detected since the last time the
 * listener was called or the status was read.
 * @property {number|string} lastInstanceHandle Handle to the last
 * instance in the Reader for which a deadline was detected.
 * Represents a 64-bit value. May be a string
 * if the JavaScript numeric representation would result in
 * a loss of precision.
 * @alias module:vortexdds.RequestedDeadlineMissedStatus
 */


/**
 * @typedef {Object} RequestedIncompatibleQosStatus
 * @property {number} totalCount Total cumulative number of times
 * the concerned Reader discovered a Writer for the same Topic with
 * an offered QoS that was incompatible with that requested by the Reader.
 * @property {number} totalCountChange The change in total_count since
 * the last time the listener was called or the status was read.
 * @property {module:vortexdds.QosPolicyID} lastPolicyId the identifier
 * of the last policy that was deemed incompatible
 * @alias module:vortexdds.RequestedIncompatibleQosStatus
 */

/**
 * @typedef {Object} SampleRejectedStatus
 * @property {number} totalCount Total cumulative count of samples
 * rejected by the Reader.
 * @property {number} totalCountChange The incremental number of
 * samples rejected since the last time the listener was called
 * or the status was read.
 * @property {module:vortexdds.SampleRejectedStatusKind} lastReason Reason
 * for rejecting the last sample rejected. If no samples have been rejected,
 * the reason is the special value *not_rejected*.
 * @property {number|string} lastInstanceHandle Handle to the last
 * instance in the Reader for which a deadline was detected.
 * Represents a 64-bit value. May be a string
 * if the JavaScript numeric representation would result in
 * a loss of precision.
 * @alias module:vortexdds.SampleRejectedStatus
 */

/**
 * @typedef {Object} LivelinessChangedStatus
 * @property {number} aliveCount The total number of currently
 * active Writers that write the Topic read by the Reader.
 * This count increases when a newly matched Writer asserts its
 * liveliness for the first time or when a Writer previously
 * considered to be not alive reasserts its liveliness.
 * The count decreases when a Writer considered alive fails to
 * assert its liveliness and becomes not alive, whether because
 * it was deleted normally or for some other reason.
 * @property {number} notAliveCount The total count of currently
 * Writers that write the Topic read by the Reader that are no longer
 * asserting their liveliness. This count increases when a Writer
 * considered alive fails to assert its liveliness and becomes not
 * alive for some reason other than the normal deletion of that Writer.
 * It decreases when a previously not alive Writer either reasserts
 * its liveliness or is deleted normally.
 * @property {number} aliveCountChange The change in the aliveCount
 * since the last time the listener was called or the status was read.
 * @property {number} notAliveCountChange The change in the
 * notAliveCount since the last time the listener was called or the
 * status was read.
 * @property {number|string} lastPublicationHandle Handle to the
 * last Writer whose change in liveliness caused this status to change.
 * Represents a 64-bit value. May be a string
 * if the JavaScript numeric representation would result in
 * a loss of precision.
 * @alias module:vortexdds.LivelinessChangedStatus
 */

/**
 * @typedef {Object} SubscriptionMatchedStatus
 * @property {number} totalCount Total cumulative count the concerned
 * Reader discovered a “match” with a Writer. That is, it found a
 * Writer for the same Topic with a requested QoS that is compatible
 * with that offered by the Reader.
 * @property {number} totalCountChange The change in totalCount since
 * the last time the listener was called or the status was read.
 * @property {number|string} lastPublicationHandle Handle to the last
 * Writer that matched the DataReader causing the status to change.
 * Represents a 64-bit value. May be a string
 * if the JavaScript numeric representation would result in
 * a loss of precision.
 * @property {number} currentCount The number of Writers currently
 * matched to the concerned Reader.
 * @property {number} currentCountChange The change in currentCount
 * since the last time the listener was called or the status was read.
 * @alias module:vortexdds.SubscriptionMatchedStatus
 */

/**
 * @typedef {Object} SampleLostStatus
 * @property {number} totalCount Total cumulative count of all samples
 * lost across of instances of data published under the Topic.
 * @property {number} totalCountChange The incremental number of
 * samples lost since the last time the listener was called or the
 * status was read.
 * @alias module:vortexdds.SampleLostStatus
 */

/**
 * @typedef {Object} InconsistentTopicStatus
 * @property {number} totalCount Total cumulative count of the Topics
 * discovered whose name matches the Topic to which this status is
 * attached and whose type is inconsistent with the Topic.
 * @property {number} totalCountChange The incremental number of
 * inconsistent topics discovered since the last time the listener
 * was called or the status was read.
 * @alias module:vortexdds.InconsistentTopicStatus
 */

/**
 * @typedef {Object} OfferedDeadlineMissedStatus
 * @property {number} totalCount Total cumulative number of offered
 * deadline periods elapsed during which a Writer failed to provide
 * data. Missed deadlines accumulate; that is, each deadline period
 * the totalCount will be incremented by one.
 * @property {number} totalCountChange The change in totalCount
 * since the last time the listener was called or the status was read.
 * @property {number|string} lastInstanceHandle Handle to the last
 * instance in the Writer for which an offered deadline was missed.
 * Represents a 64-bit value. May be a string
 * if the JavaScript numeric representation would result in
 * a loss of precision.
 * @alias module:vortexdds.OfferedDeadlineMissedStatus
 */

/**
 * @typedef {Object} OfferedIncompatibleQosStatus
 * @property {number} totalCount Total cumulative number of times
 * the concerned Writer discovered a Reader for the same Topic
 * with a requested QoS that is incompatible with that offered by
 * the Writer.
 * @property {number} totalCountChange The change in totalCount
 * since the last time the listener was called or the status was read.
 * @property {module:vortexdds.QosPolicyID} lastPolicyId The id of
 * one of the policies that was found to be incompatible the last
 * time an incompatibility was detected.
 * @alias module:vortexdds.OfferedIncompatibleQosStatus
 */

/**
 * @typedef {Object} LivelinessLostStatus
 * @property {number} totalCount Total cumulative number of times
 * that a previously-alive Writer became not alive due to a failure
 * to actively signal its liveliness within its offered liveliness
 * period. This count does not change when an already not alive
 * Writer simply remains not alive for another liveliness period.
 * @property {number} totalCountChange The change in totalCount
 * since the last time the listener was called or the status was read.
 * @alias module:vortexdds.LivelinessLostStatus
 *
 */

/**
 * @typedef {Object} PublicationMatchedStatus
 * @property {number} totalCount Total cumulative count the concerned
 * Writer discovered a “match” with a Reader. That is, it found a Reader
 * for the same Topic with a requested QoS that is compatible with that
 * offered by the Writer.
 * @property {number} totalCountChange The change in totalCount since
 * the last time the listener was called or the status was read.
 * @property {number|string} lastSubscriptionHandle Handle to the last
 * Reader that matched the Writer causing the status to change.
 * Represents a 64-bit value. May be a string
 * if the JavaScript numeric representation would result in
 * a loss of precision.
 * @property {number} current_count The number of Readers currently
 * matched to the concerned Writer.
 * @property {number} current_count_change The change in currentCount
 * since the last time the listener was called or the status was read.
 * @alias module:vortexdds.PublicationMatchedStatus
 */

// ///////////// DDS callback method definitions /////////////////
/**
 * Signature of ReaderListener *onRequestedDeadlineMissed*
 * callback.
 * @callback onRequestedDeadlineMissed
 * @param {module:vortexdds.Reader} reader the reader
 * upon which the callback was trigger
 * @param {module:vortexdds~RequestedDeadlineMissedStatus} status
 * the associated status information
 * @alias module:vortexdds.onRequestedDeadlineMissed
 */

/**
 * Signature of ReaderListener *onRequestedIncompatibleQos*
 * callback.
 * @callback onRequestedIncompatibleQos
 * @param {module:vortexdds.Reader} reader the reader
 * upon which the callback was trigger
 * @param {module:vortexdds~RequestedIncompatibleQosStatus} status
 * the associated status information
 * @alias module:vortexdds.onRequestedIncompatibleQos
 */

/**
 * Signature of ReaderListener *onSampleRejected*
 * callback.
 * @callback onSampleRejected
 * @param {module:vortexdds.Reader} reader the reader
 * upon which the callback was trigger.
 * @param {module:vortexdds~SampleRejectedStatus} status
 * the associated status information.
 * @alias module:vortexdds.onSampleRejected
 */

/**
 * Signature of ReaderListener *onLivelinessChanged*
 * callback.
 * @callback onLivelinessChanged
 * @param {module:vortexdds.Reader} reader the reader
 * upon which the callback was trigger
 * @param {module:vortexdds~LivelinessChangedStatus} status
 * the associated status information.
 * @alias  module:vortexdds.onLivelinessChanged
 */

/**
 * Signature of ReaderListener *onDataAvailable*
 * callback.
 * @callback onDataAvailable
 * @param {module:vortexdds.Reader} reader the reader
 * upon which the callback was trigger
 * @alias  module:vortexdds.onDataAvailable
 */

/**
 * Signature of ReaderListener *onSubscriptionMatched*
 * callback.
 * @callback onSubscriptionMatched
 * @param {module:vortexdds.Reader} reader the reader
 * upon which the callback was trigger
 * @param {module:vortexdds~SubscriptionMatchedStatus} status
 * the associated status information.
 * @alias  module:vortexdds.onSubscriptionMatched
 */

/**
 * Signature of ReaderListener *onSampleLost*
 * callback.
 * @callback onSampleLost
 * @param {module:vortexdds.Reader} reader the reader
 * upon which the callback was trigger
 * @param {module:vortexdds~SampleLostStatus} status
 * the associated status information.
 * @alias  module:vortexdds.onSampleLost
 */

/**
 * Signature of TopicListener *onInconsistentTopic*
 * callback.
 * @callback onInconsistentTopic
 * @param {module:vortexdds.Topic} topic the topic
 * upon which the callback was trigger
 * @param {module:vortexdds~InconsistentTopicStatus} status
 * the associated status information.
 * @alias  module:vortexdds.onInconsistentTopic
 */

/**
 * Signature of WriterListener *onOfferedDeadlineMissed*
 * callback.
 * @callback onOfferedDeadlineMissed
 * @param {module:vortexdds.Writer} writer the writer
 * upon which the callback was trigger
 * @param {module:vortexdds~OfferedDeadlineMissedStatus} status
 * the associated status information.
 * @alias  module:vortexdds.onOfferedDeadlineMissed
 */

/**
 * Signature of WriterListener *onOfferedIncompatibleQos*
 * callback.
 * @callback onOfferedIncompatibleQos
 * @param {module:vortexdds.Writer} writer the writer
 * upon which the callback was trigger
 * @param {module:vortexdds~OfferedIncompatibleQosStatus} status
 * the associated status information.
 * @alias  module:vortexdds.onOfferedIncompatibleQos
 */

/**
 * Signature of WriterListener *onLivelinessLost*
 * callback.
 * @callback onLivelinessLost
 * @param {module:vortexdds.Writer} writer the writer
 * upon which the callback was trigger
 * @param {module:vortexdds~LivelinessLostStatus} status
 * the associated status information.
 * @alias  module:vortexdds.onLivelinessLost
 */

/**
 * Signature of WriterListener *onPublicationMatched*
 * callback.
 * @callback onPublicationMatched
 * @param {module:vortexdds.Writer} writer the writer
 * upon which the callback was trigger
 * @param {module:vortexdds~PublicationMatchedStatus} status
 * the associated status information.
 * @alias  module:vortexdds.onPublicationMatched
 */
// //////// DDS Listener definitions ///////////
/**
 * @typedef {Object} TopicListener
 * Defines the availabe callbacks for a
 * {@link module:vortexdds.Topic|Topic}
 * listener.
 * @property {module:vortexdds~onInconsistentTopic}
 * [onInconsistentTopic]
 * callback to receive notice of inconsistent topic registrations.
 * Note that this callback is triggered only in hybrid DDS domains
 * in which Vortex DDS and another DDS implementation co-exist.
 *
 * @alias module:vortexdds.TopicListener
 */

/**
 * @typedef {Object} ReaderListener
 * Defines the availabe callbacks for a
 * {@link module:vortexdds.Reader|Reader}
 * listener.
 * @property {module:vortexdds~onRequestedDeadlineMissed}
 * [onRequestedDeadlineMissed]
 * callback to receive notice of missed deadlines by the reader.
 * @property {module:vortexdds~onRequestedIncompatibleQos}
 * [onRequestedIncompatibleQos]
 * callback to receive notice of changes in the number
 * writers with QoS incompatible with the reader.
 * @property {module:vortexdds~onSampleRejected} [onSampleRejected]
 * callback to receive notice of samples rejected by the reader.
 * @property {module:vortexdds~onLivelinessChanged} [onLivelinessChanged]
 * callback to receive notice of changes in liveliness of connected writers.
 * @property {module:vortexdds~onSubscriptionMatched} [onSubscriptionMatched]
 * callback to receive notice of changes in matched writers.
 * @property {module:vortexdds~onSampleLost} [onSampleLost]
 * callback to receive notice of changes on lost samples.
 * @property {module:vortexdds~onDataAvailable} [onDataAvailable]
 * callback to receive notice of data available.
 *
 * @alias module:vortexdds.ReaderListener
 */

/**
 * @typedef {Object} WriterListener
 * Defines the availabe callbacks for a
 * {@link module:vortexdds.Writer|Writer}
 * listener.
 * @property {module:vortexdds~onOfferedDeadlineMissed}
 * [onOfferedDeadlineMissed]
 * callback to receive notice of missed offered deadlines by
 * the writer.
 * @property {module:vortexdds~onOfferedIncompatibleQos}
 * [onOfferedIncompatibleQos]
 * callback to receive notice of Readers that are incompatible
 * with the writer's QoS.
 * @property {module:vortexdds~onLivelinessLost} [onLivelinessLost]
 * callback to receive notice of that the writer has not
 * adhered to its liveliness QoS.
 * @property {module:vortexdds~onPublicationMatched} [onPublicationMatched]
 * callback to receive notice of changes in matched readers.
 *
 * @alias module:vortexdds.WriterListener
 */

/**
 * Abstract base class for DDS entities.
 *
 * The class provides common  behavior for all entities,
 * in particular the method
 * {@link module:vortexdds.Entity#delete|delete()}
 * and the
 * {@link module:vortexdds.Entity#qos|qos}
 * property.
 *
 * Note that DDS resources and memory consumed by DDS entities
 * cannot be automatically reclaimed by the NodeJS engine.
 * Once your application is finished with an Entity, you must
 * call {@link module:vortexdds.Entity#delete|delete()}
 * to release these DDS resources.
 *
 * Instances of class are not created
 * by users.
 *
 * @alias module:vortexdds.Entity
 */
class Entity {
  /**
   * Internal use only.
   */
  constructor(c_handle) {
    this._c_handle = c_handle;
  }

  /**
   * Get the C99 handle to the entity.
   * @type {object}
   * @returns {object}
   * @ignore
   */
  get handle() {
    return this._c_handle;
  }

  /**
   * The existing QoS policies for the entity.
   *
   * @type {module:vortexdds.QoS}
   */
  get qos() {
    const cqos = qosc99.qosCreate();
    qosc99.qosGet(this._c_handle, cqos);
    return ddsqos.getQoSObjectAndDeleteHandle(cqos);
  }

  /**
   * Releases the DDS resources associated with
   * the entity and all its 'child' entities.
   *
   * In some cases, releasing DDS resources can take
   * several seconds. This methods returns a Promise
   * that enables you to do processing after all
   * the resources have been released.
   *
   * @returns {external:Promise}
   */
  delete() {
    let self = this;
    return new Promise(function(resolve, reject) {
      // resolve right away if the c99 handle is null
      if (self._c_handle === null) {
        resolve(null);
      }
      ddsc99.entityDelete(self._c_handle, function(err, res) {
        self._c_handle = null;
        if (err !== null) {
          reject(err);
        } else {
          resolve(res);
        }
      });
    });
  }

  /**
   * Return the DDS communication statuses that have changed since
   * this method was last called.
   *
   * @returns {module:vortexdds.StatusMask} a mask of statuses that
   * have changed
   */
  statusChanges() {
    return ddsc99.statusChanges(this.handle);
  }

  /**
   * Creates a StatusCondition for use in wait set.
   *
   * Omitting the *mask* value results in all
   * entity-appropriate status conditions being
   * enabled.
   *
   * Note that DDS resources and memory consumed by conditions
   * cannot be automatically reclaimed by the NodeJS engine.
   * Conditions are automatically
   * deleted when the parent entity is deleted.
   * Otherwise, when your application is finished with a Condition, you may
   * call {@link module:vortexdds.Condition#delete|Condition.delete()}
   * to release these DDS resources.
   *
   * @param {module:vortexdds.StatusMask} [mask] mask of StatusMask values
   * of interest
   * @returns {module:vortexdds.StatusCondition}
   * @throws {module:vortexdds.DDSError} if the status mask is invalid
   */
  createStatusCondition(mask = null) {
    check.assert.maybe.number(
      mask,
      ddserr.typeCheckMsgs.MASK_ERR_MSG_IFNOT_NULL
    );

    let statCond = new StatusCondition(this);
    if (mask !== null) {
      statCond.enable(mask);
    }
    return statCond;
  }
}

/**
 * A DDS domain participant, representing a connection by your program to
 * a DDS Domain.
 *
 * Typically, your application will create only one participant.
 * All other DDS entities are created through a participant or one of its child
 * entities via factory methods such as
 * {@link module:vortexdds.Participant#createPublisher|
 * Participant.createPublisher()}.
 *
 * At the end of your program, you can release all the entities owned directly
 * or indirectly by the participant by calling
 * {@link module:vortexdds.Entity#delete|Entity.delete()}.
 *
 * Note that DDS resources and memory consumed by DDS entities
 * cannot be automatically reclaimed by the NodeJS engine.
 * Once your application is finished with an Entity, you must
 * call {@link module:vortexdds.Entity#delete|delete()}
 * to release these DDS resources.
 *
 * @alias module:vortexdds.Participant
 * @extends module:vortexdds.Entity
 */
class Participant extends Entity {

  /* eslint-disable max-len */
  /**
   * Create a Participant instance.
   *
   * @param {number} [domainId] An integer between 0 and 230.
   * Must match the value specified in the OSPL configuration file
   * referenced by the OSPL_CONFIG environment variable.
   * @param {module:vortexdds.QoS} [
   * qos={@link module:vortexdds.QoS.participantDefault|QoS.participantDefault()}
   * ] A QoS object.
   *
   * Uses the {@link module:vortexdds.QoS.participantDefault|
   * QoS.participantDefault()} if qos is not provided.
   *
   * Note that there is no functional difference between passing no argument
   * and passing in null for qos while creating a participant.
   * @throws {module:vortexdds.DDSError} if a participant
   * cannot be created.
   */
  constructor(
    /* eslint-enable max-len */
    domainId = DDSConstants.DDS_DOMAIN_DEFAULT,
    qos = ddsqos.QoS.participantDefault()
  ) {
    check.assert.number(
      domainId,
      ddserr.typeCheckMsgs.INVALID_ARG_MSG +
      'domainId ' + ddserr.typeCheckMsgs.NUM_ERR_MSG
    );
    check.assert.maybe.instance(
      qos,
      ddsqos.QoS,
      ddserr.typeCheckMsgs.QOS_ERR_MSG
    );

    let cqos = qos !== null ? qos.asCQos() : null;
    let c_handle = ddsc99.participantCreate(
      domainId,
      cqos,
      null // no listener support, yet
    );
    if (cqos !== null) qosc99.qosDelete(cqos);
    super(c_handle);
  }

  /**
   * Creates a DDS Topic of the given name and type.
   *
   * Type information is encoded in a
   * {@link module:vortexdds.TypeSupport|TypeSupport}
   * object, typically returned by
   * {@link module:vortexdds.importIDL|importIDL()}.
   *
   * Topic creatation can fail if the DDS domain already
   * has an identically named topic, but with different
   * QoS or type information.
   *
   * The topic belongs to the participant from which it
   * is created, and is automatically deleted when the
   * participant is deleted.
   *
   * Note that DDS resources and memory consumed by DDS entities
   * cannot be automatically reclaimed by the NodeJS engine.
   * Once your application is finished with an Entity, you must
   * call {@link module:vortexdds.Entity#delete|delete()}
   * to release these DDS resources.
   *
   * @param {string} topicName a valid DDS topic name
   * @param {module:vortexdds.TypeSupport} typeSupport a object
   * defining the data type associated with the topic
   * @param {module:vortexdds.QoS}
   * [qos={@link module:vortexdds.QoS.topicDefault|QoS.topicDefault()}]
   * a specification of the quality-of-service properties for the topic.
   *
   * Uses the {@link module:vortexdds.QoS.topicDefault|QoS.topicDefault()}
   * if qos is not provided.
   *
   * Note that there is no functional difference between passing no argument
   * and passing in null for qos while creating a topic.
   * @param {module:vortexdds~TopicListener} [listener] an object defining
   * listener callbacks for the topic
   * @returns {module:vortexdds.Topic} a topic instnace
   * @throws {module:vortexdds.DDSError} if the topic already
   * exists, but with different type or QoS parameters
   */
  createTopic(
    topicName,
    typeSupport,
    qos = ddsqos.QoS.topicDefault(),
    listener = null
  ) {
    check.assert.string(
      topicName,
      ddserr.typeCheckMsgs.INVALID_ARG_MSG +
      'topicName ' + ddserr.typeCheckMsgs.STR_ERR_MSG
    );
    check.assert.instance(
      typeSupport,
      ddstopic.TypeSupport,
      ddserr.typeCheckMsgs.TYPE_SUPPORT_ERR_MSG
    );
    check.assert.maybe.instance(
      qos,
      ddsqos.QoS,
      ddserr.typeCheckMsgs.QOS_ERR_MSG
    );

    return new Topic(
      this,
      topicName,
      typeSupport.getTypename(),
      typeSupport.getKeys(),
      typeSupport.getXML(),
      null,
      typeSupport,
      qos,
      listener
    );
  }

  /**
   * Asyncrhonously search for an existing DDS topic.
   *
   * Return a Promise, whose resolved *value* is the
   * found topic. The Promise is rejected if the topic
   * cannot be found or another error occurs.
   *
   * @param {string} topicName the name of topic to find
   * @returns {external:Promise<module:vortexdds.Topic>} a
   * promise that resolves to the desired topic
   *
   * @example
   * const dds = require('vortexdds');
   * const dp = someAlreadyCreatedParticipant;
   * dp.findTopic('MyTopic')
   * .then(topic => {
   *     // do something with the found topic
   * })
   * .catch(err => {
   *     // process any exception
   * })
   * .then(_ => {
   *     // cleanup: do any processing necessary after both
   *     // success and failure
   * });
   */
  findTopic(topicName) {

    check.assert.string(
      topicName,
      ddserr.typeCheckMsgs.INVALID_ARG_MSG +
      'topicName ' + ddserr.typeCheckMsgs.STR_ERR_MSG
    );

    const self = this;
    const pHandle = self.handle;

    return new Promise(function(resolve, reject) {
      ddsc99.topicFind(
        pHandle,
        topicName,
        async function(err, topicHandle) {
          if (err !== null) {
            reject(err);
          }
          if (topicHandle === null) { // TODO resolve(null) ?
            reject(new Error('topic not found : ' + topicName));
          } else if (topicHandle < 0) {
            reject(new ddserr
              .DDSError(topicHandle, 'topic find failed: '));
          } else {
            // extract the typename, keys, xml metadescriptor and qos
            // from the found topic handle
            const typeName = ddsc99.topicGetTypeName(topicHandle);
            const keys = ddsc99.topicGetKeylist(topicHandle);
            const xml = ddsc99.topicGetMetadescriptor(topicHandle);
            const typeSupport = new ddstopic.TypeSupport(typeName, keys, xml);

            // put the qos from the participant into a QoS object
            const cqos = qosc99.qosCreate();
            qosc99.qosGet(topicHandle, cqos);
            const tqos = ddsqos.getQoSObjectAndDeleteHandle(cqos);

            //  create our new topic
            let createdTopic = self.createTopic(topicName, typeSupport, tqos);

            // no longer need foundTopicHandle -- delete it
            ddsc99.entityDelete(topicHandle, function(err, res) {
              if (err !== null) {
                reject(err);
              }
            });

            resolve(createdTopic);
          }
        }
      );
    });

  }

  /**
   * Creates a Reader for a topic on the 'default subscriber' of the
   * participant.
   *
   * Similar to
   * {@link module:vortexdds.Subscriber#createReader|Subscriber.createReader()}
   * except that a Reader created based in QoS properties of the
   * 'default subscriber' for the domain.
   *
   * The reader belongs to the participant from which it
   * is created, and is automatically deleted when the
   * participant is deleted.
   *
   * Note that DDS resources and memory consumed by DDS entities
   * cannot be automatically reclaimed by the NodeJS engine.
   * Once your application is finished with an Entity, you must
   * call {@link module:vortexdds.Entity#delete|delete()}
   * to release these DDS resources.
   *
   * @param {module:vortexdds.Topic} topic the topic from which
   * data will be read
   * @param {module:vortexdds.QoS}
   * [qos={@link module:vortexdds.QoS.readerDefault|QoS.readerDefault()}]
   * quality-of-service policies for the reader.
   *
   * If no argument is provided, then
   *  {@link module:vortexdds.QoS.readerDefault|QoS.readerDefault()} is used,
   * whereas passing in a null value results in the topic's qos to be used.
   * @param {module:vortexdds~ReaderListener} [listener] an object defining
   * listener callbacks for the reader
   * @returns {module:vortexdds.Reader} the Reader instance
   * @throws {module:vortexdds.DDSError} if the reader cannot be created
   */
  createReader(topic, qos = ddsqos.QoS.readerDefault(), listener = null) {
    check.assert.instance(
      topic,
      Topic,
      ddserr.typeCheckMsgs.TOPIC_ERR_MSG
    );
    check.assert.maybe.instance(
      qos,
      ddsqos.QoS,
      ddserr.typeCheckMsgs.QOS_ERR_MSG
    );

    return new Reader(this, topic, qos, listener);
  }

  /**
   * Creates a Reader for a topic on the 'default publisher' of
   * the participant.
   *
   * Similar to
   * {@link module:vortexdds.Publisher#createWriter|Publisher.createWriter()}
   * except that a Writer created based in QoS properties of the
   * 'default publisher' for the domain.
   *
   * The writer belongs to the participant from which it
   * is created, and is automatically deleted when the
   * participant is deleted.
   *
   * Note that DDS resources and memory consumed by DDS entities
   * cannot be automatically reclaimed by the NodeJS engine.
   * Once your application is finished with an Entity, you must
   * call {@link module:vortexdds.Entity#delete|delete()}
   * to release these DDS resources.
   *
   * @param {module:vortexdds.Topic} topic the topic to which
   * data will be written
   * @param {module:vortexdds.QoS}
   * [qos={@link module:vortexdds.QoS.writerDefault|QoS.writerDefault()}]
   * quality-of-service policies for the writer.
   *
   * If no argument is provided, then
   *  {@link module:vortexdds.QoS.writerDefault|QoS.writerDefault()} is used,
   * whereas passing in a null value results in the topic's qos to be used.
   *
   * @param {module:vortexdds~WriterListener} [listener] an object defining
   * listener callbacks for the writer
   * @returns {module:vortexdds.Writer} the Writer instance
   * @throws {module:vortexdds.DDSError} if the writer cannot be created
   */
  createWriter(topic, qos = ddsqos.QoS.writerDefault(), listener = null) {
    check.assert.instance(
      topic,
      Topic,
      ddserr.typeCheckMsgs.TOPIC_ERR_MSG
    );
    check.assert.maybe.instance(
      qos,
      ddsqos.QoS,
      ddserr.typeCheckMsgs.QOS_ERR_MSG
    );

    return new Writer(this, topic, qos, listener);
  }

  /**
   * Creates a {@link module:vortexdds.Publisher|DDS Publisher}
   * owned by this participant.
   *
   * Typically, you create a Publisher in order specify one or
   * more 'partitions' to which publisher-owned writers will
   * publish data. Partitions are specified via the partition policy
   * of a {@link module:vortex.QoS|QoS} object.
   *
   * Note that DDS resources and memory consumed by DDS entities
   * cannot be automatically reclaimed by the NodeJS engine.
   * Once your application is finished with an Entity, you must
   * call {@link module:vortexdds.Entity#delete|delete()}
   * to release these DDS resources.
   *
   * @example
   * // specify a partition policy via a QoS object
   * const dds = require('vortexdds');
   * const dp = somePreviouslyCreatedParticipant;
   * const qos = dds.QoS.publisherDefault();
   * qos.partition = { names: ['part1', 'part2']};
   * // Assuming dp is a Participant instance
   * const pub = dp.createPublisher(qos);
   * // ... use 'pub' object
   *
   * @param {module:vortexdds.QoS}
   * [qos={@link module:vortexdds.QoS.publisherDefault|QoS.publisherDefault()}]
   * quality-of-service policies for the publisher.
   *
   * Uses the {@link module:vortexdds.QoS.publisherDefault|
   * QoS.publisherDefault()} if qos is not provided.
   *
   * Note that there is no functional difference between passing no argument
   * and passing in null for qos while creating a publisher.
   * @returns {module:vortexdds.Publisher} the Publisher instance
   * @throws {module:vortexdds.DDSError} if the publisher cannot be created
   */
  createPublisher(qos = ddsqos.QoS.publisherDefault(), listener = null) {
    check.assert.maybe.instance(
      qos,
      ddsqos.QoS,
      ddserr.typeCheckMsgs.QOS_ERR_MSG
    );

    return new Publisher(this, qos, listener);
  }

  /**
   * Creates a {@link module:vortexdds.Subscriber|DDS Subscriber}
   * owned by this participant.
   *
   * Typically, you create a Publisher in order specify one or
   * more 'partitions' to which publisher-owned writers will
   * publish data. Partitions are specified via the partition policy
   * of a {@link module:vortex.QoS|QoS} object.
   *
   * Note that DDS resources and memory consumed by DDS entities
   * cannot be automatically reclaimed by the NodeJS engine.
   * Once your application is finished with an Entity, you must
   * call {@link module:vortexdds.Entity#delete|delete()}
   * to release these DDS resources.
   *
   * @example
   * // specify a partition policy via a QoS object
   * const dds = require('vortexdds');
   * const dp = somePreviouslyCreatedParticipant;
   * const qos = dds.QoS.subscriberDefault();
   * qos.partition = { names: ['part1', 'part2']};
   * // Assuming dp is a Participant instance
   * const sub = dp.createSubscriber(qos);
   * // ... use 'sub' object
   *
   * @param {module:vortexdds.QoS} [
   * qos={@link module:vortexdds.QoS.subscriberDefault|QoS.subscriberDefault()}
   * ] quality-of-service policies for the subscriber.
   *
   * Uses the {@link module:vortexdds.QoS.subscriberDefault|
   * QoS.subscriberDefault()} if qos is not provided.
   *
   * Note that there is no functional difference between passing no argument
   * and passing in null for qos while creating a subscriber.
   * @returns {module:vortexdds.Subscriber} the Subscriber instance
   * @throws {module:vortexdds.DDSError} if the subscriber cannot be created
   */
  createSubscriber(qos = ddsqos.QoS.subscriberDefault(), listener = null) {
    check.assert.maybe.instance(
      qos,
      ddsqos.QoS,
      ddserr.typeCheckMsgs.QOS_ERR_MSG
    );

    return new Subscriber(this, qos, listener);
  }

  /**
   * Creates the builtin subscriber on this participant.
   *
   * @returns {module:vortexdds.Subscriber}
   */
  getBuiltinSubscriber() {
    return new Subscriber(this, null, null,
      ddsc99.getBuiltinSubscriber(this.handle));
  }

};

/**
 * Class representing a dds topic descriptor.
 * Internal Use Class. Not published
 * @ignore
 */
class TopicDescriptor {
  /**
   * Create a Topic descriptor.
   * @param {string} typeName
   * @param {string} key (comma separated string)
   * @param {string} xml topic metadata
   * @returns {TopicDescriptor} topic descriptor instance
   */
  constructor(typeName, key, xml) {
    check.assert.string(
      typeName,
      ddserr.typeCheckMsgs.INVALID_ARG_MSG +
      'typeName ' + ddserr.typeCheckMsgs.STR_ERR_MSG
    );
    check.assert.string(
      key,
      ddserr.typeCheckMsgs.INVALID_ARG_MSG +
      'key ' + ddserr.typeCheckMsgs.STR_ERR_MSG
    );
    check.assert.string(
      xml,
      ddserr.typeCheckMsgs.INVALID_ARG_MSG +
      'xml ' + ddserr.typeCheckMsgs.STR_ERR_MSG
    );

    this._typeName = typeName;
    this._keyList = key;
    this._metaDescriptor = xml;
    this._cAddr = ddsc99.topicDescriptorCreate(
      typeName,
      key,
      xml
    );
  }

  /**
   * Get the dds topic descriptor handle.
   * @type {object}
   * @returns {object}
   */
  get cAddr() {
    if (this._cAddr === null) {
      throw new ReferenceError('TopicDescriptor has been deleted');
    }
    return this._cAddr;
  }

  /**
   * Get the type name of the topic descriptor.
   * @type {string}
   * @returns {string}
   */
  get typeName() {
    return this._typeName;
  }

  /**
   * Get the type key list, a commma separated string.
   * @type {string}
   * @returns {string}
   */
  get keyList() {
    return this._keyList;
  }

  /**
   * Get the metadescriptor associated with the type.
   * @type {string}
   * @returns {string}
   */
  get metaDescriptor() {
    return this._metaDescriptor;
  }

  /**
   * Delete the dds topic descriptor.
   */
  delete() {
    // Delete the topicDescriptor only if it hasn't been deleted
    if (this._cAddr !== null) {
      ddsc99.topicDescriptorDelete(this._cAddr);
      this._cAddr = null;
    }
  }
};

/**
 * Represents a DDS topic.
 *
 * A topic represents a globally named data type, along with quality-of-service
 * policies. The topic is available to all participants in a DDS domain,
 * and must be registered with the same data type definition and QoS policies.
 *
 * Class instances are created by the
 * {@link module:vortexdds.Participant#createTopic|
 * Participant.createTopic()} method.
 *
 * You must create a topic before you can create
 * {@link module:vortexdds.Reader|Reader} or
 * {@link module:vortexdds.Writer|Writer} instances.
 *
 * Note that DDS resources and memory consumed by DDS entities
 * cannot be automatically reclaimed by the NodeJS engine.
 * Once your application is finished with an Entity, you must
 * call {@link module:vortexdds.Entity#delete|delete()}
 * to release these DDS resources.
 *
 * @see {@link module:vortexdds.QoS.topicDefault|QoS.topicDefault()}
 * to create a default QoS object for a topic
 * @see {@link module:vortexdds.QoSProvider#getTopicQos|
 * QoSProvider.getTopicQos()} on retreiving an externally topic
 * QoS policy from a QoSProvider.
 *
 * @alias module:vortexdds.Topic
 * @extends module:vortexdds.Entity
 */
class Topic extends Entity {
  /**
   * Internal use only. Use
   * {@link module:vortexdds.Participant#createTopic|Participant.createTopic()}
   * instead.
   */
  /* TODO: rationalize the parameter list - it is completely crazy
   * @param {Participant} participant Participant to create the topic on
   * @param {string} topicName Topic name
   * @param {string} typeName Type name
   * @param {string} keys List of keys (comma separated string)
   * @param {string} xml XML topic metadescriptor
   * @param {module:vortexdds.TypeSupport} typeSupport Type Support on the topic
   * @param {module:vortexdds.QoS} qos QoS to set on the topic
   * @param {object} listener Listener to set on the topic
   * @throws {module:vortexdds.DDSError} On DDS failure
   */
  constructor(
    participant,
    topicName,
    typeName,
    keys,
    xml,
    topic_handle = null,
    typeSupport = null,
    qos = ddsqos.QoS.topicDefault(),
    listener = null
  ) {
    check.assert.maybe.instance(
      participant,
      Participant,
      ddserr.typeCheckMsgs.PARTICIPANT_ERR_MSG
    );
    check.assert.string(
      topicName,
      ddserr.typeCheckMsgs.INVALID_ARG_MSG +
      'topicName ' + ddserr.typeCheckMsgs.STR_ERR_MSG
    );
    check.assert.string(
      typeName,
      ddserr.typeCheckMsgs.INVALID_ARG_MSG +
      'typeName ' + ddserr.typeCheckMsgs.STR_ERR_MSG
    );
    check.assert.string(
      keys,
      ddserr.typeCheckMsgs.INVALID_ARG_MSG +
      'keys ' + ddserr.typeCheckMsgs.STR_ERR_MSG
    );
    check.assert.string(
      xml,
      ddserr.typeCheckMsgs.INVALID_ARG_MSG +
      'xml ' + ddserr.typeCheckMsgs.STR_ERR_MSG
    );
    check.assert.maybe.instance(
      typeSupport,
      ddstopic.TypeSupport,
      ddserr.typeCheckMsgs.TYPE_SUPPORT_ERR_MSG
      + ddserr.typeCheckMsgs.IFNOT_NULL_MSG
    );
    check.assert.maybe.instance(
      qos,
      ddsqos.QoS,
      ddserr.typeCheckMsgs.QOS_ERR_MSG
    );

    let topicDescriptor = new TopicDescriptor(typeName, keys, xml);
    let c_handle = topic_handle;
    if (c_handle === null) {
      let cqos = qos !== null ? qos.asCQos() : null;
      c_handle = ddsc99.topicCreate(
        participant.handle,
        topicDescriptor.cAddr,
        topicName,
        cqos,
        listener,
        () => this // map C99 entity to this in listeners
      );
      if (cqos !== null) qosc99.qosDelete(cqos);
    }
    super(c_handle);
    this._name = topicName;
    this._typeSupport = typeSupport;
    if (typeSupport === null) {
      this._typeSupport = new ddstopic.TypeSupport(typeName, keys, xml);
    }
    // delete c topic descriptor handle
    topicDescriptor.delete();
  }

  /**
   * the topic name.
   *
   * @type {string}
   */
  get name() {
    return this._name;
  }

  /**
   * the type support for the topic.
   *
   * @type {module:vortexdds.TypeSupport}
   */
  get typeSupport() {
    return this._typeSupport;
  }

  /**
   * Get the {@link module:vortexdds~InconsistentTopicStatus|
   * InconsistentTopicStatus} object of the topic.
   *
   * @type {module:vortexdds~InconsistentTopicStatus}
   */
  get inconsistentTopicStatus() {
    return ddsc99.getInconsistentTopicStatus(this.handle);
  }
};

/**
 * Represents a DDS publisher.
 *
 * A publisher typically owns one or more
 * {@link module:vortexdds.Writer|Writer} instances created via
 * the
 * {@link module:vortexdds.Publisher#createWriter|
 * Publisher.createWriter()} method.
 *
 * Class instances are created by the
 * {@link module:vortexdds.Participant#createPublisher|
 * Participant.createPublisher()} method.
 *
 * You typically create a Publisher because you require
 * quality-of-service parameters not available on the 'default publisher'.
 * Frequently, you wall want to specify a
 * {@link module:vortexdds.QoS#partition|QoS.partition}
 * policy so that non-default partitions are used by the
 * contained Writer instances.
 *
 * Note that DDS resources and memory consumed by DDS entities
 * cannot be automatically reclaimed by the NodeJS engine.
 * Once your application is finished with an Entity, you must
 * call {@link module:vortexdds.Entity#delete|delete()}
 * to release these DDS resources.
 *
 * @see {@link module:vortexdds.QoS.publisherDefault|QoS.publisherDefault()}
 * to create a QoS object for a publisher
 * @see {@link module:vortexdds.QoSProvider#getPublisherQos|
 * QoSProvider.getPubisherQos()} on retreiving an externally publisher
 * QoS policy from a QoSProvider.
 *
 * @alias module:vortexdds.Publisher
 * @extends module:vortexdds.Entity
 */
class Publisher extends Entity {
  /**
   * Internal use only. Use
   * {@link module:vortexdds.Participant#createPublisher|
   * Participant.createPublisher()}
   */
  constructor(
    participant,
    qos = ddsqos.QoS.publisherDefault(),
    listener = null
  ) {
    check.assert.instance(
      participant,
      Participant,
      ddserr.typeCheckMsgs.PARTICIPANT_ERR_MSG
    );
    check.assert.maybe.instance(
      qos,
      ddsqos.QoS,
      ddserr.typeCheckMsgs.QOS_ERR_MSG
    );

    let cqos = qos !== null ? qos.asCQos() : null;
    let c_handle = ddsc99.publisherCreate(
      participant.handle,
      cqos,
      listener
    );
    if (cqos !== null) qosc99.qosDelete(cqos);
    super(c_handle);
  }

  /**
   * Creates a Reader for a topic on the 'default publisher' of
   * the participant.
   *
   * Similar to
   * {@link module:vortexdds.Participant#createWriter|
   * Participant.createWriter()}
   * except that a Writer created based in QoS properties of this
   * publisher.
   *
   * The writer belongs to the publisher from which it
   * is created, and is automatically deleted when the
   * participant is deleted.
   *
   * Note that DDS resources and memory consumed by DDS entities
   * cannot be automatically reclaimed by the NodeJS engine.
   * Once your application is finished with an Entity, you must
   * call {@link module:vortexdds.Entity#delete|delete()}
   * to release these DDS resources.
   *
   * @param {module:vortexdds.Topic} topic the topic to which
   * data will be written
   * @param {module:vortexdds.QoS}
   * [qos={@link module:vortexdds.QoS.writerDefault|QoS.writerDefault()}]
   * quality-of-service policies for the writer.
   *
   * If no argument is provided, then
   *  {@link module:vortexdds.QoS.writerDefault|QoS.writerDefault()} is used,
   * whereas passing in a null value results in the topic's qos to be used.
   * @param {module:vortexdds~WriterListener} [listener] an object defining
   * listener callbacks for the writer
   * @returns {module:vortexdds.Writer} the Writer instance
   * @throws {module:vortexdds.DDSError} if the writer cannot be created
   */
  createWriter(topic, qos = ddsqos.QoS.writerDefault(), listener = null) {
    check.assert.instance(
      topic,
      Topic,
      ddserr.typeCheckMsgs.TOPIC_ERR_MSG
    );
    check.assert.maybe.instance(
      qos,
      ddsqos.QoS,
      ddserr.typeCheckMsgs.QOS_ERR_MSG
    );

    return new Writer(this, topic, qos, listener);
  }

}

/**
 * Represents a DDS data writer.
 *
 * A writer may be owned by either a
 * {@link module:vortexdds.Participant|Participant} or
 * {@link module:vortexdds.Publisher|Publisher}.
 * Using a Publisher to create a Writer allows the writer to benefit
 * from quality-of-service policies assigned the the Publisher,
 * in particular the
 * {@link module:vortexdds.QoS#partition|QoS.partition} policy.
 *
 * Class instances are created by the
 * {@link module:vortexdds.Participant#createWriter|Participant.createWriter()}
 * or
 * {@link module:vortexdds.Publisher#createWriter|Publisher.createWriter()}
 * methods.
 *
 * Note that DDS resources and memory consumed by DDS entities
 * cannot be automatically reclaimed by the NodeJS engine.
 * Once your application is finished with an Entity, you must
 * call {@link module:vortexdds.Entity#delete|delete()}
 * to release these DDS resources.
 *
 * @see {@link module:vortexdds.QoS.writerDefault|
 * QoS.writerDefault()}
 * to create a QoS object for a writer
 * @see {@link module:vortexdds.QoSProvider#getWriterQos|
 * QoSProvider.getWriterQos()} on retreiving an externally writer
 * QoS policy from a QoSProvider.
 *
 * @extends module:vortexdds.Entity
 * @alias module:vortexdds.Writer
 */
class Writer extends Entity {
  /**
   * Internal use only. Use
   * {@link module:vortexdds.Participant#createWriter|
   * Participant.createWriter()}
   * or
   * {@link module:vortexdds.Publisher#createWriter|
   * Publisher.createWriter()}.
   */
  constructor(
    dpOrPub,
    topic,
    qos = ddsqos.QoS.writerDefault(),
    listener = null
  ) {
    check.assert(
      check.any(
        [
          check.instance(dpOrPub, Participant),
          check.instance(dpOrPub, Publisher),
        ]
      ),
      ddserr.typeCheckMsgs.DP_OR_PUB_ERR_MSG,
      TypeError
    );
    check.assert.instance(
      topic,
      Topic,
      ddserr.typeCheckMsgs.TOPIC_ERR_MSG
    );
    check.assert.maybe.instance(
      qos,
      ddsqos.QoS,
      ddserr.typeCheckMsgs.QOS_ERR_MSG
    );

    let cqos = qos !== null ? qos.asCQos() : null;
    let handleLinfoPair = ddsc99.writerCreate(
      dpOrPub.handle,
      topic.handle,
      cqos,
      listener,
      () => this // map listener 'entity' to writer
    );
    if (cqos !== null) qosc99.qosDelete(cqos);
    super(handleLinfoPair.handle);
    this._linfo = handleLinfoPair.linfo;
    this._topic = topic;

    let tempQoS = this.qos;
    let isReliable =
      (tempQoS.reliability.kind === ddsqos.ReliabilityKind.Reliable);

    this._reliable = isReliable;

  }

  /**
   * The topic instance with which the
   * writer is associated.
   * @type {module:vortexdds.Topic}
   */
  get topic() {
    return this._topic;
  }

  /**
   * Write a DDS sample.
   *
   * Note: Cannot be used if the writer's
   * {@link module:vortexdds.QoS#reliability|reliability}
   * QoS policy is set to
   * {@link module:vortexdds.ReliabilityKind|kind} *Reliable*.
   * If this method is called on such a writer, a
   * {@link module:vortexdds.DDSError} is thrown with
   * the ddsErrCode field set to
   * {@link module:vortexdds.DDSErrorCode|DDSErrorCode} *ILLEGAL_OPERATION*.
   *
   * @param {object} data the data to write
   * @param {number|string} [timestamp=null] a source timestamp,
   * specified in nanoseconds since midnight, January 1, 1970.
   * Represents a 64-bit value. May be a string
   * if the JavaScript numeric representation would result in
   * a loss of precision.
   * @returns {number} Zero (0).
   * @throws {module:vortexdds.DDSError} if the sample
   * cannot be written
   */
  write(data, timestamp = null) {
    if (this.reliable) {
      throw new ddserr.DDSError(ddserr.DDSErrorCode.ILLEGAL_OPERATION,
        'Cannot call this method on Writer with Reliable QoS: ');
    }
    check.assert.assigned(data, ddserr.typeCheckMsgs.DATA_ERR_MSG);
    check.assert(
      check.any([
        check.number(timestamp),
        check.match(timestamp, ddsqos.HEX_OR_DEC_REGEX),
        check.not.assigned(timestamp),
      ]),
      ddserr.typeCheckMsgs.DUR_ERR_MSG,
      TypeError
    );

    let buffer = this.topic.typeSupport.copyin(data);
    if (check.not.assigned(timestamp)) {
      return ddsc99.write(this.handle, buffer);
    } else {
      return ddsc99.writeTs(this.handle, buffer, timestamp);
    }
  }

  /**
   * Asynchronously writer a DDS sample.
   *
   * This method returns a
   * {@link external:Promise|Promise} that
   * resolves with a value of zero (0) once the write has
   * completed. If an error occurs, the promise
   * rejects with a
   * {@link module:vortexdds.DDSError|DDSError}.
   *
   * When a writer's
   * {@link module:vortexdds.QoS#reliability|reliability}
   * QoS policy is set to
   * {@link module:vortexdds.ReliabilityKind|kind} *Reliable*
   * write operations my block while the DDS system attempts
   * to ensure delivery of the sample.
   * This method may be called on all writer's, regardless
   * of the specified
   * {@link module:vortexdds.QoS#reliability|reliability}
   * policy.
   *
   * @param {object} data the data to write
   * @param {number|string} [timestamp=null] a source timestamp,
   * specified in nanoseconds since midnight, January 1, 1970.
   * Represents a 64-bit value. May be a string
   * if the JavaScript numeric representation would result in
   * a loss of precision.
   * @returns {external:Promise<number>}
   *
   * @example
   * const dds = require('vortexdds');
   * const wr = somePreviouslyCreatedWriter;
   * const data = {
   *    id: 1,
   *    message: 'hello world!',
   * };
   * wr.writeReliable(data)
   * .then(_ => {
   *    // do any actions required after
   *    // a successful write
   * })
   * .catch(err => {
   *    // write was unsuccessful
   * });
   */
  writeReliable(data, timestamp) {
    check.assert.assigned(data, ddserr.typeCheckMsgs.DATA_ERR_MSG);
    check.assert(
      check.any([
        check.number(timestamp),
        check.match(timestamp, ddsqos.HEX_OR_DEC_REGEX),
        check.not.assigned(timestamp),
      ]),
      ddserr.typeCheckMsgs.DUR_ERR_MSG,
      TypeError
    );

    let self = this;
    return new Promise(function(resolve, reject) {
      const buffer = self.topic.typeSupport.copyin(data);
      const cb = function(err, res) {
        if (err) {
          reject(err);
        }
        if (res !== 0) {
          reject(new ddserr.DDSError(res, 'dds_write failed: '));
        }
        resolve(res);
      };
      if (check.not.assigned(timestamp)) {
        ddsc99.writeAsync(self.handle, buffer, cb);
      } else {
        ddsc99.writeTsAsync(self.handle, buffer, timestamp, cb);
      }
    });
  }

  /**
   * Write a dds sample with a given timestamp.
   *
   * @param {object} data data as a javascript object
   * @param {number} tstamp timestamp (nanoseconds since epoch)
   * @returns {number} status of dds_write_ts
   * @throws {Error} When the Writer has a reliable QoS, or there is a dds
   * error.
   *
   * @ignore
   */
  writeTs(data, tstamp) {
    return this.write(data, tstamp);
  }

  /**
   * Writes a dds sample with a timestamp asynchronously. Can be used on
   * Writers which have a Reliable QoS, in which case the write operation may
   * block. Returns a promise. Rejects on dds error, resolves with 0 otherwise.
   *
   * @param {object} data data as a javascript object
   * @returns {Promise}
   * @ignore
   */
  writeTsReliable(data, tstamp) {
    return this.writeReliable(data, tstamp);
  }

  /**
   * Dispose a DDS instance.
   *
   * Note: Cannot be used if the writer's
   * {@link module:vortexdds.QoS#reliability|reliability}
   * QoS policy is set to
   * {@link module:vortexdds.ReliabilityKind|kind} *Reliable*.
   * If this method is called on such a writer, a
   * {@link module:vortexdds.DDSError} is thrown with
   * the ddsErrCode field set to
   * {@link module:vortexdds.DDSErrorCode|DDSErrorCode} *ILLEGAL_OPERATION*.
   *
   * @param {object} data data specifying the instance; only
   * key field values are required.
   * @param {number|string} [timestamp=null] a source timestamp,
   * specified in nanoseconds since midnight, January 1, 1970.
   * Represents a 64-bit value. May be a string
   * if the JavaScript numeric representation would result in
   * a loss of precision.
   * @returns {number} Zero (0).
   * @throws {module:vortexdds.DDSError} if the sample
   * cannot be disposed
   */
  dispose(data, timestamp) {
    check.assert.assigned(data, ddserr.typeCheckMsgs.DATA_ERR_MSG);
    check.assert(
      check.any([
        check.number(timestamp),
        check.match(timestamp, ddsqos.HEX_OR_DEC_REGEX),
        check.not.assigned(timestamp),
      ]),
      ddserr.typeCheckMsgs.DUR_ERR_MSG,
      TypeError
    );

    if (this.reliable) {
      throw new ddserr.DDSError(ddserr.DDSErrorCode.ILLEGAL_OPERATION,
        'Cannot call this method on Writer with Reliable QoS: ');
    }
    let buffer = this.topic.typeSupport.copyin(data);

    if (check.not.assigned(timestamp)) {
      return ddsc99.instanceDispose(this.handle, buffer);
    } else {
      return ddsc99.instanceDisposeTs(this.handle, buffer, timestamp);
    }
  }

  /**
   * Asynchronously dispose of a DDS instance.
   *
   * This method returns a
   * {@link external:Promise|Promise} that
   * resolves with a value of zero (0) once the write has
   * completed. If an error occurs, the promise
   * rejects with a
   * {@link module:vortexdds.DDSError|DDSError}.
   *
   * When a writer's
   * {@link module:vortexdds.QoS#reliability|reliability}
   * QoS policy is set to
   * {@link module:vortexdds.ReliabilityKind|kind} *Reliable*
   * this operation my block while the DDS system attempts
   * to ensure delivery of the sample.
   * This method may be called on all writer's, regardless
   * of the specified
   * {@link module:vortexdds.QoS#reliability|reliability}
   * policy.
   *
   * @param {object} data data specifying the instance; only
   * key field values are required.
   * @param {number|string} [timestamp=null] a source timestamp,
   * specified in nanoseconds since midnight, January 1, 1970.
   * Represents a 64-bit value. May be a string
   * if the JavaScript numeric representation would result in
   * a loss of precision.
   * @returns {external:Promise<number>}
   *
   * @example
   * const dds = require('vortexdds');
   * const wr = somePreviouslyCreatedWriter;
   * const data = {
   *    id: 1, // only key fields required
   * };
   * wr.disposeReliable(data)
   * .then(_ => {
   *    // do any actions required after
   *    // a successful dispose
   * })
   * .catch(err => {
   *    // dispose was unsuccessful
   * });
   */
  disposeReliable(data, timestamp) {
    check.assert.assigned(data, ddserr.typeCheckMsgs.DATA_ERR_MSG);
    check.assert(
      check.any([
        check.number(timestamp),
        check.match(timestamp, ddsqos.HEX_OR_DEC_REGEX),
        check.not.assigned(timestamp),
      ]),
      ddserr.typeCheckMsgs.DUR_ERR_MSG,
      TypeError
    );

    let self = this;
    return new Promise(function(resolve, reject) {
      const buffer = self.topic.typeSupport.copyin(data);
      const cb = function(err, res) {
        if (err) {
          reject(err);
        }
        if (res !== 0) {
          reject(new ddserr.DDSError(res, 'dds_instance_dispose failed:'));
        }
        resolve(res);
      };
      if (check.not.assigned(timestamp)) {
        ddsc99.instanceDisposeAsync(self.handle, buffer, cb);
      } else {
        ddsc99.instanceDisposeTsAsync(self.handle, buffer, timestamp, cb);
      }
    });
  }

  /**
   * Dispose an instance with a timestamp, for Writers with a non-reliable QoS.
   *
   * @param {object} data data to dispose
   * @param {number} tstamp timestamp
   * @returns {number} 0 on success. Throws error otherwise.
   * @throws {DDSError} On a dds error
   * @ignore
   */
  disposeTs(data, tstamp) {
    return this.dispose(data, tstamp);
  }

  /**
   * Disposes a dds sample with a timestamp asynchronously.
   * Can be used on Writers which have a Reliable QoS, in which case the
   * dispose operation may block. Returns a promise. Rejects on dds error,
   * resolves with 0 otherwise.
   *
   * @param {object} data data as a javascript object
   * @returns {Promise}
   * @ignore
   */
  disposeTsReliable(data, tstamp) {
    return this.disposeReliable(data, tstamp);
  }

  /**
   * Unregister an instance.
   *
   * Note: Cannot be used if the writer's
   * {@link module:vortexdds.QoS#reliability|reliability}
   * QoS policy is set to
   * {@link module:vortexdds.ReliabilityKind|kind} *Reliable*.
   * If this method is called on such a writer, a
   * {@link module:vortexdds.DDSError} is thrown with
   * the ddsErrCode field set to
   * {@link module:vortexdds.DDSErrorCode|DDSErrorCode} *ILLEGAL_OPERATION*.
   *
   * @param {object} data data specifying the instance; only
   * key field values are required.
   * @param {number|string} [timestamp=null] a source timestamp,
   * specified in nanoseconds since midnight, January 1, 1970.
   * Represents a 64-bit value. May be a string
   * if the JavaScript numeric representation would result in
   * a loss of precision.
   * @returns {number} Zero (0).
   * @throws {module:vortexdds.DDSError} if the sample
   * cannot be unregistered   */
  unregister(data, timestamp) {
    check.assert.assigned(data, ddserr.typeCheckMsgs.DATA_ERR_MSG);
    check.assert(
      check.any([
        check.number(timestamp),
        check.match(timestamp, ddsqos.HEX_OR_DEC_REGEX),
        check.not.assigned(timestamp),
      ]),
      ddserr.typeCheckMsgs.DUR_ERR_MSG,
      TypeError
    );

    if (this.reliable) {
      throw new ddserr.DDSError(ddserr.DDSErrorCode.ILLEGAL_OPERATION,
        'Cannot call this method on Writer with Reliable QoS: ');
    }
    let buffer = this.topic.typeSupport.copyin(data);
    if (check.not.assigned(timestamp)) {
      return ddsc99.instanceUnregister(this.handle, buffer,
        DDSConstants.DDS_HANDLE_NIL);
    } else {
      return ddsc99.instanceUnregisterTs(this.handle, buffer,
        DDSConstants.DDS_HANDLE_NIL, timestamp);
    }
  }

  /**
   * Asynchronously unregister of a DDS instance.
   *
   * This method returns a
   * {@link external:Promise|Promise} that
   * resolves with a value of zero (0) once the write has
   * completed. If an error occurs, the promise
   * rejects with a
   * {@link module:vortexdds.DDSError|DDSError}.
   *
   * When a writer's
   * {@link module:vortexdds.QoS#reliability|reliability}
   * QoS policy is set to
   * {@link module:vortexdds.ReliabilityKind|kind} *Reliable*
   * this operation my block while the DDS system attempts
   * to ensure delivery of the sample.
   * This method may be called on all writer's, regardless
   * of the specified
   * {@link module:vortexdds.QoS#reliability|reliability}
   * policy.
   *
   * @param {object} data data specifying the instance; only
   * key field values are required.
   * @param {number|string} [timestamp=null] a source timestamp,
   * specified in nanoseconds since midnight, January 1, 1970.
   * Represents a 64-bit value. May be a string
   * if the JavaScript numeric representation would result in
   * a loss of precision.
   * @returns {external:Promise<number>}
   *
   * @example
   * const dds = require('vortexdds');
   * const wr = somePreviouslyCreatedWriter;
   * const data = {
   *    id: 1, // only key fields required
   * };
   * wr.unregisterReliable(data)
   * .then(_ => {
   *    // do any actions required after
   *    // a successful unregister
   * })
   * .catch(err => {
   *    // unregister was unsuccessful
   * });
   */
  unregisterReliable(data, timestamp) {
    check.assert.assigned(data, ddserr.typeCheckMsgs.DATA_ERR_MSG);
    check.assert(
      check.any([
        check.number(timestamp),
        check.match(timestamp, ddsqos.HEX_OR_DEC_REGEX),
        check.not.assigned(timestamp),
      ]),
      ddserr.typeCheckMsgs.DUR_ERR_MSG,
      TypeError
    );

    let self = this;
    return new Promise(function(resolve, reject) {
      const buf = self.topic.typeSupport.copyin(data);
      const cb = function(err, res) {
        if (err) {
          reject(err);
        }
        if (res !== 0) {
          reject(new ddserr.DDSError(ref, 'dds_instance_unregister failed'));
        }
        resolve(res);
      };
      if (check.not.assigned(timestamp)) {
        ddsc99.instanceUnregisterAsync(self.handle, buf,
          DDSConstants.DDS_HANDLE_NIL, cb);
      } else {
        ddsc99.instanceUnregisterTsAsync(self.handle, buf,
          DDSConstants.DDS_HANDLE_NIL, timestamp, cb);
      }
    });
  }

  /**
   * Unregister an instance with a timestamp, for Writers with a non-reliable
   * QoS.
   *
   * @param {object} data data to unregister
   * @param {number} tstamp timestamp
   * @returns {number} 0 on success. Throws error otherwise.
   * @throws {DDSError} On a dds error
   * @ignore
   */
  unregisterTs(data, tstamp) {
    return this.unregister(data, tstamp);
  }

  /**
   * Unregisters a dds sample asynchronously.
   * Can be used on Writers which have a Reliable QoS, in which case the
   * dispose operation may block. Returns a promise. Rejects on dds error,
   * resolves with 0 otherwise.
   *
   * @param {object} data data as a javascript object
   * @param {number} tstamp timestamp
   * @returns {Promise}
   * @ignore
   */
  unregisterTsReliable(data, tstamp) {
    return this.unregisterReliable(data, tstamp);
  }

  /**
   * reliable flag.
   * @type {boolean}
   * @ignore
   */
  get reliable() {
    return this._reliable;
  }

  /**
   * Get the {@link module:vortexdds~PublicationMatchedStatus|
   * PublicationMatchedStatus} object of the writer.
   *
   * @type {module:vortexdds~PublicationMatchedStatus}
   */
  get publicationMatchedStatus() {
    return ddsc99.getPublicationMatchedStatus(this.handle);
  }

  /**
   * Get the {@link module:vortexdds~LivelinessLostStatus|
   * LivelinessLostStatus} object of the writer.
   *
   * @type {module:vortexdds~LivelinessLostStatus}
   */
  get livelinessLostStatus() {
    return ddsc99.getLivelinessLostStatus(this.handle);
  }

  /**
   * Get the {@link module:vortexdds~OfferedDeadlineMissedStatus|
   * OfferedDeadlineMissedStatus} object of the writer.
   *
   * @type {module:vortexdds~OfferedDeadlineMissedStatus}
   */
  get offeredDeadlineMissedStatus() {
    return ddsc99.getOfferedDeadlineMissedStatus(this.handle);
  }

  /**
   * Get the {@link module:vortexdds~OfferedIncompatibleQosStatus|
   * OfferedIncompatibleQosStatus} object of the writer.
   *
   * @type {module:vortexdds~OfferedIncompatibleQosStatus}
   */
  get offeredIncompatibleQosStatus() {
    return ddsc99.getOfferedIncompatibleQosStatus(this.handle);
  }

};

/**
 * Represents a DDS subscriber.
 *
 * A subscriber typically owns one or more
 * {@link module:vortexdds.Reader|Reader} instances created via
 * the
 * {@link module:vortexdds.Subscriber#createReader|
 * Subscriber.createReader()} method.
 *
 * Class instances are created by the
 * {@link module:vortexdds.Participant#createSubscriber|
 * Participant.createSubscriber()} method.
 *
 * You typically create a Subscriber because you require
 * quality-of-service parameters not available on the 'default subscriber'.
 * Frequently, you wall want to specify a
 * {@link module:vortexdds.QoS#partition|QoS.partition}
 * policy so that non-default partitions are used by the
 * contained Reader instances.
 *
 * Note that DDS resources and memory consumed by DDS entities
 * cannot be automatically reclaimed by the NodeJS engine.
 * Once your application is finished with an Entity, you must
 * call {@link module:vortexdds.Entity#delete|delete()}
 * to release these DDS resources.
 *
 * @see {@link module:vortexdds.QoS.subscriberDefault|QoS.subscriberDefault()}
 * to create a QoS object for a subscriber
 * @see {@link module:vortexdds.QoSProvider#getSubscriberQos|
 * QoSProvider.getSubscriberQos()} on retreiving an externally subscriber
 * QoS policy from a QoSProvider.
 *
 * @alias module:vortexdds.Subscriber
 * @extends module:vortexdds.Entity
 */
class Subscriber extends Entity {
  /**
   * Internal use only. Use
   * {@link module:vortexdds.Participant#createSubscriber|
   * Participant.createSubscriber()}
   */
  constructor(
    participant,
    qos = ddsqos.QoS.subscriberDefault(),
    listener = null,
    subscriberHandle = null
  ) {
    check.assert.instance(
      participant,
      Participant,
      ddserr.typeCheckMsgs.PARTICIPANT_ERR_MSG
    );
    check.assert.maybe.instance(
      qos,
      ddsqos.QoS,
      ddserr.typeCheckMsgs.QOS_ERR_MSG
    );

    let cqos = qos !== null ? qos.asCQos() : null;
    let c_handle = null;
    if (subscriberHandle !== null) {
      c_handle = subscriberHandle;
    } else {
      c_handle = ddsc99.subscriberCreate(
        participant.handle,
        cqos,
        listener
      );
    }
    if (cqos !== null) qosc99.qosDelete(cqos);
    super(c_handle);
  }

  /**
   * Creates a Reader for a topic on this subscriber of the
   * participant.
   *
   * Similar to
   * {@link module:vortexdds.Participant#createReader|
   * Participant.createReader()}
   * except that a Reader is created based in QoS properties of this
   * subscriber.
   *
   * The reader belongs to the subscriber from which it
   * is created, and is automatically deleted when the
   * subscriber is deleted.
   *
   * Note that DDS resources and memory consumed by DDS entities
   * cannot be automatically reclaimed by the NodeJS engine.
   * Once your application is finished with an Entity, you must
   * call {@link module:vortexdds.Entity#delete|delete()}
   * to release these DDS resources.
   *
   * @param {module:vortexdds.Topic} topic the topic from which
   * data will be read
   * @param {module:vortexdds.QoS}
   * [qos={@link module:vortexdds.QoS.readerDefault|QoS.readerDefault()}]
   * quality-of-service policies for the reader.
   *
   * If no argument is provided, then
   *  {@link module:vortexdds.QoS.readerDefault|QoS.readerDefault()} is used,
   * whereas passing in a null value results in the topic's qos to be used.
   * @param {module:vortexdds~ReaderListener} [listener] an object defining
   * listener callbacks for the reader
   * @returns {module:vortexdds.Reader} the Reader instance
   * @throws {module:vortexdds.DDSError} if the reader cannot be created
   */
  createReader(topic, qos = ddsqos.QoS.readerDefault(), listener = null) {
    check.assert.instance(
      topic,
      Topic,
      ddserr.typeCheckMsgs.TOPIC_ERR_MSG
    );
    check.assert.maybe.instance(
      qos,
      ddsqos.QoS,
      ddserr.typeCheckMsgs.QOS_ERR_MSG
    );

    return new Reader(this, topic, qos, listener);
  }

  /**
   * Finds the builtin datareader on this subscriber, if the subcriber is
   * builtin.
   *
   * @param {string} topicName
   * @returns {module:vortexdds.Reader} The builtin reader
   * @throws {module.vortexdds.DDSError} If the reader is not builtin
   * or topicName does not correspond to a builtin topic.
   */
  findBuiltinDataReader(topicName) {
    let c99BuiltinReader = ddsc99.findDataReader(this.handle, topicName);
    let c99BuiltinTopic = ddsc99.getTopicFromEntity(c99BuiltinReader);

    let builtinTs = new ddstopic.TypeSupport(
      ddsc99.topicGetTypeName(c99BuiltinReader),
      ddsc99.topicGetKeylist(c99BuiltinReader),
      ddsc99.topicGetMetadescriptor(c99BuiltinReader));

    let builtinTopic = new Topic(null,
      topicName,
      '',
      '',
      '',
      c99BuiltinTopic,
      builtinTs);

    return new Reader(this, builtinTopic, null, null, c99BuiltinReader);
  }
}

/**
 * Represents a DDS data reader.
 *
 * A reader may be owned by either a
 * {@link module:vortexdds.Participant|Participant} or
 * {@link module:vortexdds.Subscriber|Subscriber}.
 * Using a Subscriber to create a Reader allows the reader to benefit
 * from quality-of-service policies assigned the the Subscriber,
 * in particular the
 * {@link module:vortexdds.QoS#partition|QoS.partition} policy.
 *
 * Class instances are created by the
 * {@link module:vortexdds.Participant#createReader|Participant.createReader()}
 * or
 * {@link module:vortexdds.Subscriber#createReader|Subscriber.createReader()}
 * methods.
 *
 * Note that DDS resources and memory consumed by DDS entities
 * cannot be automatically reclaimed by the NodeJS engine.
 * Once your application is finished with an Entity, you must
 * call {@link module:vortexdds.Entity#delete|delete()}
 * to release these DDS resources.
 *
 * @see {@link module:vortexdds.QoS.readerDefault|QoS.readerDefault()}
 * to create a QoS object for a reader
 * @see {@link module:vortexdds.QoSProvider#getReaderQos|
 * QoSProvider.getReaderQos()} on retreiving an externaly reader
 * QoS policy from a QoSProvider.
 *
 * @alias module:vortexdds.Reader
 * @extends module:vortexdds.Entity
 */
class Reader extends Entity {
  /**
   * Internal use only. Use
   * {@link module:vortexdds.Participant#createReader|
   * Participant.createReader()}
   * or
   * {@link module:vortexdds.Subscriber#createReader|
   * Subscriber.createReader()}.
   */
  constructor(
    dpOrSub,
    topic,
    qos = ddsqos.QoS.readerDefault(),
    listener = null,
    readerHandle = null
  ) {
    check.assert(
      check.any(
        [
          check.instance(dpOrSub, Participant),
          check.instance(dpOrSub, Subscriber),
        ]
      ),
      ddserr.typeCheckMsgs.DP_OR_SUB_ERR_MSG,
      TypeError
    );
    check.assert.instance(
      topic,
      Topic,
      ddserr.typeCheckMsgs.TOPIC_ERR_MSG
    );
    check.assert.maybe.instance(
      qos,
      ddsqos.QoS,
      ddserr.typeCheckMsgs.QOS_ERR_MSG
    );

    let cqos = null;
    let handleLinfoPair = null;

    if (readerHandle !== null) {
      handleLinfoPair = {handle: readerHandle, linfo: { l: null, flags: 0}};
    } else {
      cqos = qos !== null ? qos.asCQos() : null;
      handleLinfoPair = ddsc99.readerCreate(
        dpOrSub.handle,
        topic.handle,
        cqos,
        listener,
        () => this // map C99 handle to this in listeners
      );
      if (cqos !== null) qosc99.qosDelete(cqos);
    }

    super(handleLinfoPair.handle);
    this._linfo = handleLinfoPair.linfo;
    this._topic = topic;
    this._topicDesc = topic.descriptor;
  }

  /**
   * Create a Query Condition.
   *
   * A query condition may be attached to a
   * {@link module:vortexdds.Waitset|Waitset}
   * or as part of a conditional read via
   * {@link module:vortexdds.Reader#takeCond|Reader.takeCond()}
   * or
   * {@link module:vortexdds.Reader#readCond|Reader.readCond()}.
   *
   * Note that DDS resources and memory consumed by conditions
   * cannot be automatically reclaimed by the NodeJS engine.
   * Conditions are automatically
   * deleted when the parent entity is deleted.
   * Otherwise, when your application is finished with a Condition, you may
   * call {@link module:vortexdds.Condition#delete|Condition.delete()}
   * to release these DDS resources.
   *
   * @param {module:vortexdds.StateMask} mask a mask of instance, view and
   * sample state values to accept
   * @param {string} expression a SQL *where* expression, with optional
   * parameter substitution markers of the form *%n*, where *n* is a number.
   * Parameter numbers start at 0 and must be sequential.
   * @param {Array<string>} params an array of string substitutions for
   * parameter markers placed in *expression*.
   * @returns {module:vortexdds.QueryCondition}
   * @throws {module:vortexdds.DDSError} if the query condition could not
   * be created.
   */
  createQueryCondition(mask, expression, params) {

    check.assert.number(
      mask,
      ddserr.typeCheckMsgs.MASK_ERR_MSG
    );
    check.assert.string(
      expression,
      ddserr.typeCheckMsgs.INVALID_ARG_MSG +
      'expression ' + ddserr.typeCheckMsgs.STR_ERR_MSG
    );
    check.assert.array.of.string(params, ddserr.typeCheckMsgs.PARAMS_ERR_MSG);

    return new QueryCondition(this, mask, expression, params);
  }

  /**
   * Create a read condition.
   *
   * A read condition may be attached to a
   * {@link module:vortexdds.Waitset|Waitset}
   * or as part of a conditional read via
   * {@link module:vortexdds.Reader#takeCond|Reader.takeCond()}
   * or
   * {@link module:vortexdds.Reader#readCond|Reader.readCond()}.
   *
   * Note that DDS resources and memory consumed by conditions
   * cannot be automatically reclaimed by the NodeJS engine.
   * Conditions are automatically
   * deleted when the parent entity is deleted.
   * Otherwise, when your application is finished with a Condition, you may
   * call {@link module:vortexdds.Condition#delete|Condition.delete()}
   * to release these DDS resources.
   *
   * @param {module:vortexdds.StateMask} mask a mask of instance,
   * view and sample state values to accept
   * @returns {module:vortexdds.ReadCondition} a read condition
   */
  createReadCondition(mask) {

    check.assert.number(
      mask,
      ddserr.typeCheckMsgs.MASK_ERR_MSG
    );

    return new ReadCondition(this, mask);
  }

  /**
   * The topic instance with which the
   * reader is associated.
   * @type {module:vortexdds.Topic}
   */
  get topic() {
    return this._topic;
  }

  /**
   * Nulls out non-keyed fields when valid_data === false.
   * @param {Array} dataArray Array returned from read,take,
   * readCond or takeCond
   * @ignore
   */
  _validateData(dataArray) {
    // key list as an array
    let keyedFields = this.topic.typeSupport.keys.split(',');

    // loop through all samples
    for (let i = 0; i < dataArray.length; i++) {
      // loop through all field names in this sample, if the same is not valid
      if (!dataArray[i].info.valid_data) {
        for (let j = 0; j < Object.keys(dataArray[i].sample).length; j++) {
          // if the field name is not in the key-list, null it out the data
          // for that field
          let fieldName = Object.keys(dataArray[i].sample)[j];
          if (!keyedFields.includes(fieldName)) {
            dataArray[i].sample[fieldName] = null;
          }
        }
      }
    }
    return dataArray;
  }

  /**
   * Read samples available for the topic.
   *
   * Note that, in DDS, a 'read' operation returns all published samples
   * available for the topic, whether the Reader has previously seen them
   * or not. If you want to see only changed data, you should use a 'take'
   * operation, instead.
   *
   * @param {number} maxSample maximum number of samples to read
   * @returns {external:Array<module:vortexdds~SampleData>}
   * an array of sample and info pairs
   * @throws {module:vortexdds.DDSError} if the read operation fails.
   */
  read(maxSample) {
    check.assert.number(
      maxSample,
      ddserr.typeCheckMsgs.MAX_SAMPLE_ERR_MSG
    );

    let topicStruct = this.topic.typeSupport.getRefType();
    return this._validateData(ddsc99.read(
      this.handle,
      maxSample,
      topicStruct
    ));
  }

  /**
   * Conditionally Read samples available for the topic according to the
   * supplied
   * {@link module:vortexdds.ReadCondition|ReadCondition}
   * or
   * {@link module:vortexdds.QueryCondition|QueryCondition}.
   *
   * Note that, in DDS, a 'read' operation returns all published samples
   * available for the topic, whether the Reader has previously seen them
   * or not. If you want to see only changed data, you should use a 'take'
   * operation, instead.
   *
   * @param {number} maxSample maximum number of samples to read
   * @param {module:vortexdds.Condition} cond a condtion with with to
   * filter results
   * @returns {external:Array<module:vortexdds~SampleData>}
   * an array of sample and info pairs
   * @throws {module:vortexdds.DDSError} if the read operation fails.
   */
  readCond(maxSample, cond) {
    check.assert.number(
      maxSample,
      ddserr.typeCheckMsgs.MAX_SAMPLE_ERR_MSG
    );
    check.assert.instance(
      cond,
      Condition,
      ddserr.typeCheckMsgs.COND_ERR_MSG
    );

    let topicStruct = this.topic.typeSupport.getRefType();
    return this._validateData(ddsc99.readCond(
      this.handle,
      maxSample,
      topicStruct,
      cond.handle
    ));
  }

  /**
   * Take previously unseen samples available for the topic.
   *
   * Note that, in DDS, a 'take' operation returns only published samples
   * available for the topic not previously seen by this Reader.
   * If you want to see all available samples, you should use a 'read'
   * operation, instead.
   *
   * @param {number} maxSample maximum number of samples to take
   * @returns {external:Array<module:vortexdds~SampleData>}
   * an array of sample and info pairs
   * @throws {module:vortexdds.DDSError} if the take operation fails.
   */
  take(maxSample) {
    check.assert.number(maxSample, ddserr.typeCheckMsgs.MAX_SAMPLE_ERR_MSG);

    let topicStruct = this.topic.typeSupport.getRefType();
    return this._validateData(ddsc99.take(
      this.handle,
      maxSample,
      topicStruct
    ));
  }

  /**
   * Conditionally take samples not previously seen available for the topic
   * according to the supplied
   * {@link module:vortexdds.ReadCondition|ReadCondition}
   * or
   * {@link module:vortexdds.QueryCondition|QueryCondition}.
   *
   * Note that, in DDS, a 'take' operation returns only published samples
   * available for the topic not previously seen by this Reader.
   * If you want to see all available samples, you should use a 'read'
   * operation, instead.
   *
   * @param {number} maxSample maximum number of samples to take
   * @param {module:vortexdds.Condition} cond a condtion with with to
   * filter results
   * @returns {external:Array<module:vortexdds~SampleData>}
   * an array of sample and info pairs
   * @throws {module:vortexdds.DDSError} if the take operation fails.
   */
  takeCond(maxSample, cond) {
    check.assert.number(maxSample, ddserr.typeCheckMsgs.MAX_SAMPLE_ERR_MSG);
    check.assert.instance(
      cond,
      Condition,
      ddserr.typeCheckMsgs.COND_ERR_MSG
    );

    let topicStruct = this.topic.typeSupport.getRefType();
    return this._validateData(ddsc99.takeCond(
      this.handle,
      maxSample,
      topicStruct,
      cond.handle
    ));
  }

  /**
   * Asynchronously wait for historical data to be delivered
   * by the DDS Service.
   *
   * Returns a {@link external:Promise|Promise} to which
   * asynchronous listeners may be attached
   * once historical data has been retrieved.
   * If a timeout or error occurs, the promise is rejected.
   * Otherwise, the promise will resolve with
   * a value of 0.
   *
   * @param {number} timeout a timeout in nanoseconds
   * how long to wait for historical data before time out
   * @returns {external:Promise<number>}
   */
  waitForHistoricalData(timeout) {
    check.assert(
      check.any(
        [
          check.number(timeout),
          check.match(timeout, ddsqos.HEX_OR_DEC_REGEX),
        ]
      ),
      ddserr.typeCheckMsgs.DUR_ERR_MSG,
      TypeError
    );

    const reader = this;
    return new Promise(function(resolve, reject) {
      ddsc99.readerWaitForHistoricalData(
        reader.handle,
        timeout,
        function(err, result) {
          if (err !== null) {
            reject(err);
          }
          if (result < 0) {
            reject(new ddserr.DDSError(
              result,
              'Failed wait for historial data: '
            ));
          } else {
            resolve(result);
          }
        }
      );
    });

  }

  /**
   * Get the {@link module:vortexdds~SubscriptionMatchedStatus|
   * SubscriptionMatchedStatus} object of the reader.
   *
   * @type {module:vortexdds~SubscriptionMatchedStatus}
   */
  get subscriptionMatchedStatus() {
    return ddsc99.getSubscriptionMatchedStatus(this.handle);
  }

  /**
   * Get the {@link module:vortexdds~LivelinessChangedStatus|
   * LivelinessChangedStatus} object of the reader.
   *
   * @type {module:vortexdds~LivelinessChangedStatus}
   */
  get livelinessChangedStatus() {
    return ddsc99.getLivelinessChangedStatus(this.handle);
  }

  /**
   * Get the {@link module:vortexdds~SampleRejectedStatus|
   * SampleRejectedStatus} object of the reader.
   *
   * @type {module:vortexdds~SampleRejectedStatus}
   */
  get sampleRejectedStatus() {
    return ddsc99.getSampleRejectedStatus(this.handle);
  }

  /**
   * Get the {@link module:vortexdds~SampleLostStatus|
   * SampleLostStatus} object of the reader.
   *
   * @type {module:vortexdds~SampleLostStatus}
   */
  get sampleLostStatus() {
    return ddsc99.getSampleLostStatus(this.handle);
  }

  /**
   * Get the {@link module:vortexdds~RequestedDeadlineMissedStatus|
   * RequestedDeadlineMissedStatus} object of the reader.
   *
   * @type {module:vortexdds~RequestedDeadlineMissedStatus}
   */
  get requestedDeadlineMissedStatus() {
    return ddsc99.getRequestedDeadlineMissedStatus(this.handle);
  }

  /**
   * Get the {@link module:vortexdds~RequestedIncompatibleQosStatus|
   * RequestedIncompatibleQosStatus} object of the reader.
   *
   * @type {module:vortexdds~RequestedIncompatibleQosStatus}
   */
  get requestedIncompatibleQosStatus() {
    return ddsc99.getRequestedIncompatibleQosStatus(this.handle);
  }
};

/**
 * Abstract base class for Conditions.
 *
 * Not instantiated by clients.
 *
 * Note that DDS resources and memory consumed by conditions
 * cannot be automatically reclaimed by the NodeJS engine.
 * Conditions are automatically
 * deleted when the parent entity is deleted.
 * Otherwise, when your application is finished with a Condition, you may
 * call {@link module:vortexdds.Condition#delete|Condition.delete()}
 * to release these DDS resources.
 *
 * @alias module:vortexdds.Condition
 */
class Condition {
  /**
   * Internal use only. Use
   * {@link module:vortexdds.Reader#createReadCondition|
   * Reader.createReadCondition()}
   * or
   * {@link module:vortexdds.Reader#createQueryCondition|
   * Reader.createQueryCondition()}.
   */
  constructor(cond = null) {
    this._handle = cond;
  }

  /**
   * Gets the C99 handle of the condition.
   * @type {object}
   * @ignore
   */
  get handle() {
    return this._handle;
  }

  /**
   * Checks whether the condition is triggered or not.
   * @returns {boolean}
   */
  triggered() {
    return ddsc99.conditionTriggered(this._handle);
  }

  /**
   * Releases DDS resources associated with the condition.
   *
   * Once deleted, the condition can no longer be used.
   *
   * Note that DDS resources and memory consumed by conditions
   * cannot be automatically reclaimed by the NodeJS engine.
   * Conditions are automatically
   * deleted when the parent entity is deleted.
   * Otherwise, when your application is finished with a Condition, you may
   * call this method
   * to release these DDS resources.
   *
   */
  delete() {
    // only delete the condition if it has been added and not deleted
    if (this._handle !== null) {
      ddsc99.conditionDelete(this._handle);
      this._handle = null;
    }
  }
};

/**
 * Represents a condition on Reader input based on
 * samples, instances and view state.
 *
 * Note that DDS resources and memory consumed by conditions
 * cannot be automatically reclaimed by the NodeJS engine.
 * Conditions are automatically
 * deleted when the parent entity is deleted.
 * Otherwise, when your application is finished with a Condition, you may
 * call {@link module:vortexdds.Condition#delete|Condition.delete()}
 * to release these DDS resources.
 *
 * @extends module:vortexdds.Condition
 * @alias module:vortexdds.ReadCondition
 */
class ReadCondition extends Condition {
  /**
   * Internal use only. Use
   * {@link module:vortexdds.Reader#createReadCondition|
   * Reader.createReadCondition()}
   * instead.
   */
  constructor(reader, mask) {
    check.assert.instance(
      reader,
      Reader,
      ddserr.typeCheckMsgs.READER_ERR_MSG
    );
    check.assert.number(
      mask,
      ddserr.typeCheckMsgs.MASK_ERR_MSG
    );

    let condition = ddsc99.readConditionCreate(reader.handle, mask);
    super(condition);
  }
};

/**
 * A user-triggerable condition for interrupting
 * {@link module:vortexdds.Waitset|Waitsets}.
 *
 * A GuardCondition, when attached to a Waitset, enables you
 * to interrupt an asynchronous
 * {@link module:vortexdds.Waitset#wait|Waitset.wait()}
 * operation by calling the
 * {@link module:vortexdds.GuardCondition#trigger|
 * GuardCondition.trigger()} method.
 *
 * Note that DDS resources and memory consumed by conditions
 * cannot be automatically reclaimed by the NodeJS engine.
 * Conditions are automatically
 * deleted when the parent entity is deleted.
 * Otherwise, when your application is finished with a Condition, you may
 * call {@link module:vortexdds.Condition#delete|Condition.delete()}
 * to release these DDS resources.
 *
 * @example
 * const dds = require('vortexdds');
 * const ws = new dds.Waitset();
 * const guard = new dds.GuardCondition();
 * ws.attach(guard);
 * // ws.attach(other conditions);
 * ws.wait()
 * .then(triggeredConds => {
 *     for(const cond of triggeredConds) {
 *         if(cond === guard) {
 *             // guard was triggered
 *         }
 *     }
 * })
 * .catch(err => {
 *     // wait set error, including timeout
 * });
 *
 * // sometime later, cause the wait set to trigger.
 * guard.trigger();
 *
 * @extends module:vortexdds.Condition
 * @alias module:vortexdds.GuardCondition
 */
class GuardCondition extends Condition {
  /**
   * Create a guard condition.
   */
  constructor() {
    super(ddsc99.guardConditionCreate());
  }

  /**
   * Trigger the guard condition, forcing any
   * {@link module:vortexdds.Waitset#wait|Waitset.wait()}
   * operation to which the guard was attached
   * to complete.
   */
  trigger() {
    ddsc99.guardTrigger(this.handle);
  }

  /**
   * Resets the guard condition so that it is
   * no longer triggered..
   */
  reset() {
    ddsc99.guardReset(this.handle);
  }
};

/**
 * Represents a condition on Reader input based on
 * samples, instances and view state AND on values
 * found in the actual samples.
 *
 * Note that DDS resources and memory consumed by conditions
 * cannot be automatically reclaimed by the NodeJS engine.
 * Conditions are automatically
 * deleted when the parent entity is deleted.
 * Otherwise, when your application is finished with a Condition, you may
 * call {@link module:vortexdds.Condition#delete|Condition.delete()}
 * to release these DDS resources.
 *
 * @extends module:vortexdds.Condition
 * @alias module:vortexdds.QueryCondition
 */
class QueryCondition extends Condition {
  /**
   * Internal use only. Use
   * {@link module:vortexdds.Reader#createQueryCondition|
   * Reader.createQueryCondition()}
   * instead.
   */
  constructor(reader, mask, expression, params) {
    check.assert.instance(
      reader,
      Reader,
      ddserr.typeCheckMsgs.READER_ERR_MSG
    );
    check.assert.number(
      mask,
      ddserr.typeCheckMsgs.MASK_ERR_MSG
    );
    check.assert.string(
      expression,
      ddserr.typeCheckMsgs.INVALID_ARG_MSG +
      'expression ' + ddserr.typeCheckMsgs.STR_ERR_MSG
    );
    check.assert.array.of.string(params, ddserr.typeCheckMsgs.PARAMS_ERR_MSG);

    let condition = ddsc99.queryConditionCreateSql(
      reader.handle,
      mask,
      expression,
      params,
      params.length
    );
    super(condition);
  }
};

const entityStatuses = Object.freeze({
  Participant: StatusMask.data_available | StatusMask.data_on_readers
    | StatusMask.inconsistent_topic | StatusMask.liveliness_changed
    | StatusMask.liveliness_lost | StatusMask.offered_deadline_missed
    | StatusMask.offered_incompatible_qos | StatusMask.publication_matched
    | StatusMask.requested_deadline_missed
    | StatusMask.requested_incompatible_qos
    | StatusMask.sample_lost | StatusMask.sample_rejected
    | StatusMask.subscription_matched,
  Topic: StatusMask.inconsistent_topic,
  Subscriber: StatusMask.data_on_readers,
  Reader: StatusMask.sample_rejected |
    StatusMask.liveliness_changed | StatusMask.requested_deadline_missed |
    StatusMask.requested_incompatible_qos | StatusMask.data_available |
    StatusMask.sample_lost | StatusMask.subscription_matched,
  Writer: StatusMask.liveliness_lost |
    StatusMask.offered_deadline_missed |
    StatusMask.offered_incompatible_qos | StatusMask.publication_matched,
  Publisher: StatusMask.liveliness_lost |
    StatusMask.offered_deadline_missed |
    StatusMask.offered_incompatible_qos | StatusMask.publication_matched,
});

/**
 * Represents a condition on an Entities 'communication statuses'.
 *
 * Note that DDS resources and memory consumed by conditions
 * cannot be automatically reclaimed by the NodeJS engine.
 * Conditions are automatically
 * deleted when the parent entity is deleted.
 * Otherwise, when your application is finished with a Condition, you may
 * call {@link module:vortexdds.Condition#delete|Condition.delete()}
 * to release these DDS resources.
 *
 * @extends module:vortexdds.Condition
 * @alias module:vortexdds.StatusCondition
 */
class StatusCondition extends Condition {
  /**
   * Internal use only. Use
   * {@link module:vortexdds.Entity#createStatusCondition|
   * Entity.createStatusCondition()}
   * instead.
   */
  constructor(entity) {
    check.assert.instance(
      entity,
      Entity,
      ddserr.typeCheckMsgs.ENTITY_ERR_MSG
    );

    super(ddsc99.statusCondition(entity.handle));
    this._entity = entity;

    // enable all the statuses for this entity by default
    this._mask = entityStatuses[this._entity.constructor.name];
  }

  /**
   * Determines if the mask corresponds to the entity.
   * @param {number} mask
   * @returns {boolean} True if the mask corresponds to the entity. False
   * otherwise.
   * @ignore
   */
  _checkMask(mask) {
    // the bits in disallowedBits must be off in mask, otherwise
    // mask does not correspond to the entity
    let entityStatus = entityStatuses[this._entity.constructor.name];
    let disallowedBits = ~entityStatus;

    if ((disallowedBits & mask) !== 0) {
      return false;
    }
    return true;
  }

  /**
   * Change the 'communication statuses' monitored by this
   * status condition.
   *
   * @param {module:vortexdss.StatusMask} mask a mask of communication
   * status that should trigger this condition.
   * @throws {module:vortexdds.DDSError} if the mask is
   * invalid with respect to the parent entity
   */
  enable(mask) {
    check.assert.number(mask, ddserr.typeCheckMsgs.MASK_ERR_MSG);

    if (!this._checkMask(mask)) {
      throw new ddserr.DDSError(ddserr.DDSErrorCode.BAD_PARAMETER,
        'Mask includes values not supported by '
        + this._entity.constructor.name);
    }
    this._mask = mask;
    ddsc99.enableStatus(this._entity.handle, mask);
  }

  /**
   * the mask 'communication statuses' selected by this condition.
   * @type {module:vortexdds.StatusMask}
   */
  get mask() {
    return this._mask;
  }
};

/**
 * Represent a collection of
 * {@link module:vortexdds.Condition|Conditions}
 * upon which you can wait.
 *
 * Note that DDS resources and memory consumed by waitsets
 * cannot be automatically reclaimed by the NodeJS engine.
 * When your application is finished with a Waitset, you may
 * call {@link module:vortexdds.Waitset#delete|Waitset.delete()}
 * to release these DDS resources.
 *
 * @alias module:vortexdds.Waitset
 */
class Waitset {
  /**
   * Create a new Waitset.
   *
   * @param {module:vortexdds.Condition} [cond] a condition to attach
   * to the waitset.
   * @throws {module:vortexdds.DDSError} if the wait set cannot be
   * created or if the optional condition cannot be attached.
   */
  constructor(cond = null) {
    check.assert.maybe.instance(
      cond,
      Condition,
      ddserr.typeCheckMsgs.COND_ERR_MSG + ddserr.typeCheckMsgs.IFNOT_NULL_MSG
    );

    this._handle = ddsc99.waitsetCreate();
    this._attachedConditions = new Map();
    if (cond !== null) {
      this.attach(cond);
    }
  }

  /**
   * Releases DDS resources associated with the waitset.
   *
   * Once deleted, the waitset can no longer be used.
   *
   * Note that DDS resources and memory consumed by waitsets
   * cannot be automatically reclaimed by the NodeJS engine.
   * When your application is finished with a Condition, you may
   * call this method to release these DDS resources.
   *
   * Note also that
   * {@link module:vortexdds.Condition|Conditions} attached to
   * the waitset are NOT reclaimed or deleted by this operation.
   * DDS resources related to Conditions are deleted explicitly by
   * {@link module:vortexdds.Condition#delete|Condition.delete()}
   * or implicitly when the containing entity is deleted.
   *
   * @throws {module:vortexdds.DDSError} if an error occurs
   * while attempting to delete the waitset.
   */
  delete() {
    ddsc99.waitsetDelete(this.handle);
    this._handle = null;
    this._attachedConditions = null;
  }

  /**
   * Gets the C99 handle to this waitset.
   * @type {object}
   * @ignore
   */
  get handle() {
    return this._handle;
  }

  /**
   * An array of conditions attached to the waitset.
   * @type {external.Array<module:vortexdds.Condition>}
   */
  get conditions() {
    return Array.from(this._attachedConditions.values());
  }

  /**
   * Attach a
   * {@link module:vortexdds.Condition|Condition}
   * to this waitset.
   *
   * Note: if you wish to later
   * {@link module:vortexdds.Waitset#detach|detach}
   * a from the waitset, you must retain a reference
   * to it.
   *
   * @param {module:vortexdds.Condition} cond a condition
   * @throws {module:vortexdds.DDSError} if an error
   * occurs while attempting to attach the condition
   */
  attach(cond) {
    check.assert.instance(
      cond,
      Condition,
      ddserr.typeCheckMsgs.COND_ERR_MSG
    );

    ddsc99.waitsetAttach(this.handle, cond.handle, cond.handle);
    // Map cannot handle a buffer key. Use the string version of &cond.handle.
    this._attachedConditions.set(cond.handle.address().toString(16), cond);
  }

  /**
   * Remove a
   * {@link module:vortexdds.Condition|Condition}
   * from the waitset.
   *
   * Note that detaching a condition does not reclaim
   * any DDS resources associated with it. To reclaim those
   * resouces, you must call
   * {@link module:vortexdds.Condition#delete|Condition.delete()}.
   * @param {module:vortexdds.Condition} cond the condition to detach
   * @throws {module:vortexdds.DDSError} if an error occurs
   * while attempting to detach the condition.
   */
  detach(cond) {
    check.assert.instance(
      cond,
      Condition,
      ddserr.typeCheckMsgs.COND_ERR_MSG
    );

    this._attachedConditions.delete(cond.handle.address().toString(16));
    return ddsc99.waitsetDetach(this.handle, cond.handle);
  }

  /**
   * Asynchronously wait for one or more of the attached conditions to trigger.
   *
   * When the returned
   * {@link external:Promise|Promise}
   * resolves, its value is an array of
   * {@link module:vortexdds.Condition}
   * that caused the waitset to trigger.
   *
   * If a timeout, or other error occurs, then the returned
   * {@link external:Promise|Promise}
   * is rejected with a
   * {@link module:vortexdds.DDSError} value. If a timeout
   * occurred, then the
   * {@link module:vortexdds.DDSError#ddsErrCode|DDSError.ddsErrCode}
   * property will be {@link module:vortexdds.DDSErrorCode.TIMEOUT
   * DDSErrorCode.TIMEOUT}.
   *
   * @param {number|string} [timeout=DDSConstants.DDS_INFINITY]
   * a maximum amount of time to wait, in nanoseconds.
   * Represents a 64-bit value. May be a string
   * if the JavaScript numeric representation would result in
   * a loss of precision.
   *
   * @returns {external:Promise<external:Array<module:vortexdds.Condition>>}
   *
   * @example
   * const dds = require('vortexdds');
   * const ws = new dds.Waitset();
   * // ... use ws.attach(conditions)
   * const SEC_TO_NS = 10 ^ 9;
   *
   * ws.wait(10 * SEC_TO_NS)
   * .then(triggeredConds => {
   *     for(const cond of triggeredConds) {
   *         // 'cond' was triggered, do something
   *         // about it
   *     }
   * })
   * .catch(err => {
   *     if(err.ddsErrorCode === dds.DDSErrorCode.TIMEOUT) {
   *         // a timeout
   *     } else {
   *         // something more serious
   *     }
   * })
   * .then(_ => {
   *     // finally, do any cleanup required, regardless
   *     // of whether the promise resolved or rejected.
   * });
   */
  wait(timeout = DDSConstants.DDS_INFINITY) {

    check.assert(
      check.any(
        [
          check.number(timeout),
          check.match(timeout, ddsqos.HEX_OR_DEC_REGEX),
        ]
      ),
      ddserr.typeCheckMsgs.DUR_ERR_MSG,
      TypeError
    );

    const waitsetInstance = this;
    const numConds = waitsetInstance._attachedConditions.size;
    const attachedCondsBuf = Buffer.alloc(ddsc99.pointerSize * numConds);
    return new Promise(function(resolve, reject) {
      ddsc99.waitsetWait(
        waitsetInstance.handle,
        numConds,
        attachedCondsBuf,
        timeout,
        function(err, res) {
          if (err !== null) {
            reject(err);
          }
          if (res === 0) {
            reject(new ddserr.DDSError(ddserr.DDSErrorCode.TIMEOUT,
              'wait failed: '));
          } else if (res < 0) {
            reject(new ddserr.DDSError(res, 'wait failed: '));
          } else {
            let attachedCondArray = [];

            for (let i = 0; i < numConds; i++) {
              const attachedCond = ref.readPointer(
                attachedCondsBuf,
                i * ddsc99.pointerSize,
                ddsc99.pointerSize
              );
              attachedCondArray.push(attachedCond);
            }

            const triggeredConditions = attachedCondArray.map((h) =>
              waitsetInstance._attachedConditions.get(
                h.address().toString(16)));
            resolve(triggeredConditions);
          }
        }
      );
    });
  };

};

/**
  * Converts seconds to nanoseconds.
  *
  * @param {number} n seconds
  * @returns {number} nanoseconds
  *
  * @example
  * // create the waitset
  * let waitset = new dcps.Waitset();
  *
  * // skip code to setup waitset with conditions
  *
  * let conds = await waitset.wait(SEC_TO_NANO(1));
  *
  * @alias module:vortexdds.SEC_TO_NANO
  */
function SEC_TO_NANO(n) {
  return n * 1000000000;
}

module.exports = {
  Participant: Participant,
  Topic: Topic,
  Publisher: Publisher,
  Writer: Writer,
  Subscriber: Subscriber,
  Reader: Reader,
  TopicDescriptor: TopicDescriptor,
  Waitset: Waitset,
  ReadCondition: ReadCondition,
  GuardCondition: GuardCondition,
  QueryCondition: QueryCondition,
  StateMask: StateMask,
  SampleRejectedStatusKind: Object.freeze(SampleRejectedStatusKind),
  StatusCondition: StatusCondition,
  StatusMask: Object.freeze(StatusMask),
  DDSConstants: Object.freeze(DDSConstants),
  SEC_TO_NANO: SEC_TO_NANO,
};

