/*
 *                         Vortex OpenSplice
 *
 *   This software and documentation are Copyright 2006 to 2019 ADLINK
 *   Technology Limited, its affiliated companies and licensors. All rights
 *   reserved.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

'use strict';
/* eslint-env node, mocha */

const ddstopic = require('./ddstopic');
const expect = require('chai').expect;
const dcps = require('./dcps');
const path = require('path');


function SEC_TO_MILI(n) {
  return n * 1000;
}

describe('Type Support: Writing and reading', function() {
  var dp = null;
  before(function(){
    this.timeout(10000);
    dp = new dcps.Participant();
  });

  after(async function() {
    this.timeout(SEC_TO_MILI(20));
    await dp.delete();
  });


  it('IDLPP thing sdk', function(done) {

    const idlName = 'test_data' + path.sep + 'thingmodel.idl';
    const idl = path.resolve(idlName);

    ddstopic.importIDL(idl).then((result) => {

      expect(result instanceof Map).to.be.true;
      expect(result.size).to.be.equal(3);

      let typeSupport;

      typeSupport = result.get('com::adlinktech::iot::Thing');
      expect(typeSupport instanceof ddstopic.TypeSupport).to.be.true;

      let topic = dp.createTopic('MyThing', typeSupport);
      expect(topic).to.not.be.null;

      let reader = dp.createReader(topic, null);
      expect(reader).to.not.be.null;
      let writer = dp.createWriter(topic, null);
      expect(writer).to.not.be.null;


      const sampleJSObj = {
        id: '16',
        className: '001',
        description: 'testing123',
        parts: [
          {
            relationshipName: 'important',
            thingId: '16',
          },
          {
            relationshipName: 'priority',
            thingId: '8',
          },

        ],
      };

      // write out 1 sample
      let status = writer.write(sampleJSObj);
      expect(status).to.be.equal(0);

      // read 1 sample
      let numSamples = 1;
      let readArray = reader.read(numSamples);
      expect(readArray).to.not.be.null;
      expect(readArray.length).equals(numSamples);

      // verify that the data read is equivalent to
      // data sample written out
      let sampleItem = readArray[0];
      let sample = sampleItem.sample;

      expect(sample).deep.equal(sampleJSObj);


      done();
    }).catch((result) => {
      done(new Error(result));
    });

  });


});
