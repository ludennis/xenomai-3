/*
 *                         Vortex OpenSplice
 *
 *   This software and documentation are Copyright 2006 to 2019 ADLINK
 *   Technology Limited, its affiliated companies and licensors. All rights
 *   reserved.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

'use strict';
/* eslint-env node, mocha */

const dcps = require('./dcps');
const expect = require('chai').expect;
const qos = require('./qos');
const sleep = require('sleep');
const TypeSupport = require('./ddstopic').TypeSupport;

/* Topic Descriptor Information */
const sampleTypeName = 'HelloWorldData::Msg';
const sampleTypeKey = 'userID';
const sampleTopicXML = '<MetaData version="1.0.0">' +
  '<Module name="HelloWorldData">' +
  '<Struct name="Msg">' +
  '<Member name="userID"><Long/></Member>' +
  '<Member name="message"><Long/></Member>' +
  '</Struct>' +
  '</Module>' +
  '</MetaData>';

function createSampleTopic(participant, topicname) {
  let typeSupport = new TypeSupport(sampleTypeName, sampleTypeKey,
    sampleTopicXML);
  return participant.createTopic(
    topicname,
    typeSupport
  );
}

function SEC_TO_MILI(n) {
  return n * 1000;
}

describe('DDS Listeners', function() {
  let dp = null;

  before(function() {
    dp = new dcps.Participant();
  });

  after(async function() {
    this.timeout(SEC_TO_MILI(20));
    await dp.delete();
  });

  it('Reader receives on data available', function(done) {
    this.timeout(SEC_TO_MILI(5));
    let topic = createSampleTopic(dp, 'onDataAvailableTopic');

    let first = true;
    const rd = dp.createReader(
      topic,
      null,
      {
        onDataAvailable: function(entity) {
          if (first) {
            first = false;
            expect(entity).to.equal(rd);
            const dataSet = entity.take(1);
            expect(dataSet).to.be.length(1);
            expect(dataSet[0].info.valid_data).to.equal(true);
            expect(dataSet[0].sample).to.deep.equal({userID: 0, message: 1});
            done();
          }
        },
      }
    );

    const wqos = new qos.QoS({
      reliability: {kind: qos.ReliabilityKind.BestEffort}});

    const wr = dp.createWriter(topic, wqos);
    wr.write({userID: 0, message: 1});
  });

  it('Writer receives on offered deadline missed', function(done) {
    this.timeout(SEC_TO_MILI(5));
    let topic = createSampleTopic(dp, 'onOfferedDeadlineMissedTopic');
    let wqos = qos.QoS.writerDefault();
    wqos.deadline = {deadline: Math.pow(10, 9)}; // 1s deadline for the writer
    wqos.reliability = {
      kind: qos.ReliabilityKind.BestEffort,
      maxBlockingTime: 100000000,
    };

    let first = true;
    let wr = dp.createWriter(topic, wqos,
      {
        onOfferedDeadlineMissed: function(entity, status) {
          if (first) {
            first = false;
            expect(entity).to.equal(wr);
            expect(status.totalCount).to.satisfy(Number.isInteger);
            expect(status.totalCountChange).to.satisfy(Number.isInteger);
            expect(status.lastInstanceHandle).to.satisfy(Number.isInteger);
            done();
          }
        },
      });

    // eslint-disable-next-line no-unused-vars
    let rd = dp.createReader(topic);

    wr.write({ userID: 0, message: 1 });
  });

  it('Writer received on offered incompatible qos', function(done) {
    this.timeout(SEC_TO_MILI(5));
    let topic = createSampleTopic(dp, 'incompatibleQoSWriterTopic');
    let first = true;
    let wr = dp.createWriter(topic, null,
      {
        onOfferedIncompatibleQos: function(entity, status) {
          if (first) {
            first = false;
            expect(entity).to.equal(wr);
            expect(status.totalCount).to.equal(1);
            expect(status.totalCountChange).to.equal(1);
            expect(status.lastPolicyId).to.be.a('number');
            done();
          }
        },
      });

    let rqos = qos.QoS.readerDefault();
    rqos.durability = {kind: qos.DurabilityKind.Transient};
    // eslint-disable-next-line no-unused-vars
    let rd = dp.createReader(topic, rqos);
  });

  it('Writer receives on liveliness lost', function(done) {
    this.timeout(SEC_TO_MILI(5));
    // liveliness must be asserted within the lease duration.
    // the writer asserts its liveliness by writing
    let topic = createSampleTopic(dp, 'onLivelinessLostTopic');
    let wqos = qos.QoS.writerDefault();
    wqos.liveliness = {
      kind: qos.LivelinessKind.ManualByTopic,
      leaseDuration: 10,
    };

    let rqos = qos.QoS.readerDefault();
    rqos.liveliness = {
      kind: qos.LivelinessKind.ManualByTopic,
      leaseDuration: 10,
    };

    let first = true;
    let wr = dp.createWriter(topic, wqos,
      {
        onLivelinessLost: function(entity, status) {
          if (first) {
            first = false;
            expect(entity).to.equal(wr);
            expect(status.totalCount).to.satisfy(Number.isInteger);
            expect(status.totalCountChange).to.satisfy(Number.isInteger);
            done();
          }
        },
      });
    // eslint-disable-next-line no-unused-vars
    let rd = dp.createReader(topic, rqos);
  });

  it('Reader receives on liveliness changed', function(done) {
    this.timeout(SEC_TO_MILI(5));
    let topic = createSampleTopic(dp, 'onLivelinessChangedTopic');
    let wqos = qos.QoS.writerDefault();
    wqos.liveliness = {
      kind: qos.LivelinessKind.ManualByTopic,
      leaseDuration: 10,
    };

    let rqos = qos.QoS.readerDefault();
    rqos.liveliness = {
      kind: qos.LivelinessKind.ManualByTopic,
      leaseDuration: 10,
    };

    // eslint-disable-next-line no-unused-vars
    let wr = dp.createWriter(topic, wqos);

    let first = true;
    let rd = dp.createReader(topic, rqos,
      {
        onLivelinessChanged: function(entity, status) {
          if (first) {
            first = false;
            expect(entity).to.equal(rd);
            expect(status.lastPublicationHandle).to.be.at.least(0);
            done();
          }
        },
      });
  });

  it('Reader receives on requested deadline missed', function(done) {
    this.timeout(SEC_TO_MILI(5));
    let topic = createSampleTopic(dp, 'onRequestedDeadlineMissedTopic');

    let rqos = qos.QoS.readerDefault();
    rqos.deadline = {deadline: Math.pow(10, 9) / 4}; // deadline of 0.25s


    let first = true;
    let rd = dp.createReader(topic, rqos,
      {
        onRequestedDeadlineMissed: function(entity, status) {
          if (first) {
            first = false;
            expect(entity).to.equal(rd);
            expect(status.totalCount).to.satisfy(Number.isInteger);
            expect(status.totalCountChange).to.satisfy(Number.isInteger);
            expect(status.lastInstanceHandle).to.satisfy(Number.isInteger);
            done();
          }
        },
      });

    let wqos = qos.QoS.writerDefault();
    wqos.deadline = {deadline: Math.pow(10, 9) / 4};
    wqos.reliability = {
      kind: qos.ReliabilityKind.BestEffort,
      maxBlockingTime: 100000000,
    };
    let wr = dp.createWriter(topic, wqos);
    wr.write({ userID: 0, message: 1 });
    sleep.msleep(300);
    // wr.write({ userID: 3, message: 4 });
  });

  it('Reader receives on requested incompatible qos', function(done) {
    this.timeout(SEC_TO_MILI(5));
    let topic = createSampleTopic(dp, 'incompatibleQoSReaderTopic');
    let rqos = qos.QoS.readerDefault();
    rqos.durability = {kind: qos.DurabilityKind.Transient};

    let first = true;
    let rd = dp.createReader(topic, rqos,
      {
        onRequestedIncompatibleQos: function(entity, status) {
          if (first) {
            first = false;
            expect(entity).to.equal(rd);
            expect(status.totalCount).to.satisfy(Number.isInteger);
            expect(status.totalCountChange).to.satisfy(Number.isInteger);
            expect(status.lastPolicyId).to.satisfy(Number.isInteger);
            done();
          }
        },
      });

    let wqos = qos.QoS.writerDefault();
    wqos.durability = {kind: qos.DurabilityKind.Volatile};
    wqos.reliability = {
      kind: qos.ReliabilityKind.BestEffort,
      maxBlockingTime: 100000000,
    };
    let wr = dp.createWriter(topic, wqos);
    wr.write({ userID: 0, message: 1 });
  });

  it('Reader received on sample rejected', function(done) {
    this.timeout(SEC_TO_MILI(5));
    let topic = createSampleTopic(dp, 'onSampleRejectedTopic');

    let rqos = qos.QoS.readerDefault();
    rqos.resourceLimits = {
      maxSamples: 1,
      maxInstances: 1,
      maxSamplesPerInstance: 1,
    };
    let first = true;
    let rd = dp.createReader(topic, rqos,
      {
        onSampleRejected: function(entity, status) {
          if (first) {
            first = false;
            expect(entity).to.equal(rd);
            expect(status.totalCount).to.satisfy(Number.isInteger);
            expect(status.totalCountChange).to.satisfy(Number.isInteger);
            expect(status.lastReason).to.satisfy(Number.isInteger);
            expect(status.lastInstanceHandle).to.satisfy(Number.isInteger);
            done();
          }
        },
      });

    const wqos = new qos.QoS({
      reliability: {kind: qos.ReliabilityKind.BestEffort}});

    let wr = dp.createWriter(topic, wqos);

    wr.write({ userID: 0, message: 1 });
    // this sample will be rejected due to the resource limits qos on the
    // reader
    wr.write({ userID: 2, message: 3 });
  });

  it('Reader receives on sample lost', function(done) {
    this.timeout(SEC_TO_MILI(5));
    let topic = createSampleTopic(dp, 'onSampleLostTopic');
    let rqos = qos.QoS.readerDefault();
    rqos.destinationOrder = {kind: qos.DestinationOrderKind.BySourceTimestamp};

    let first = true;
    let rd = dp.createReader(topic, rqos,
      {
        onSampleLost: function(entity, status) {
          if (first) {
            first = false;
            expect(entity).to.equal(rd);
            expect(status.totalCount).to.satisfy(Number.isInteger);
            expect(status.totalCountChange).to.satisfy(Number.isInteger);
            done();
          }
        },
      });

    let wqos = qos.QoS.writerDefault();
    wqos.destinationOrder = {kind: qos.DestinationOrderKind.BySourceTimestamp};
    wqos.reliability = {
      kind: qos.ReliabilityKind.BestEffort,
      maxBlockingTime: 100000000,
    };
    let wr = dp.createWriter(topic, wqos);
    let datum = { userID: 1, message: 2 };
    wr.writeTs(datum, 1001 * Math.pow(10, 9));
    sleep.msleep(100);
    rd.take(1);
    wr.writeTs(datum, 1000 * Math.pow(10, 9));
  });


  it('Writer receives publication matched', function(done) {
    this.timeout(SEC_TO_MILI(5));
    let topic = createSampleTopic(dp, 'pubMatchedTopic');
    // eslint-disable-next-line no-unused-vars
    let first = true;
    const writer = dp.createWriter(
      topic,
      null,
      {
        onPublicationMatched: function(entity, status) {
          if (first) {
            first = false;
            expect(entity).to.be.equal(writer);
            expect(status.totalCount).to.satisfy(Number.isInteger);
            expect(status.totalCountChange).to.satisfy(Number.isInteger);
            expect(status.currentCount).to.satisfy(Number.isInteger);
            expect(status.currentCountChange).to.satisfy(Number.isInteger);
            expect(status.lastSubscriptionHandle).to.satisfy(Number.isInteger);
            done();
          }
        },
      }
    );
    // eslint-disable-next-line no-unused-vars
    const reader = dp.createReader(topic);
  });

  it('Reader receives subscription matched', function(done) {
    this.timeout(SEC_TO_MILI(5));
    let topic = createSampleTopic(dp, 'subMatchedTopic');
    // eslint-disable-next-line no-unused-vars
    let first = true;
    const rd = dp.createReader(
      topic,
      null,
      {
        onSubscriptionMatched: function(entity, status) {
          if (first) {
            expect(entity).to.be.equal(rd);
            expect(status.totalCount).to.satisfy(Number.isInteger);
            expect(status.totalCountChange).to.satisfy(Number.isInteger);
            expect(status.currentCount).to.satisfy(Number.isInteger);
            expect(status.currentCountChange).to.satisfy(Number.isInteger);
            expect(status.lastPublicationHandle).to.satisfy(Number.isInteger);
            first = false;
            done();
          }
        },
      }
    );
    // eslint-disable-next-line no-unused-vars
    const wr = dp.createWriter(topic);
  });
});
