/*
 *                         Vortex OpenSplice
 *
 *   This software and documentation are Copyright 2006 to 2019 ADLINK
 *   Technology Limited, its affiliated companies and licensors. All rights
 *   reserved.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

'use strict';
/* eslint-env node, mocha */

const dcps = require('./dcps');
const qos = require('./qos');
const ddserr = require('./ddserr');
const TypeSupport = require('./ddstopic').TypeSupport;
const expect = require('chai').expect;
const path = require('path');
const DDS_DOMAIN_DEFAULT = 0x7fffffff;

/* Topic Descriptor Information */
const sampleTypeName = 'HelloWorldData::Msg';
const sampleTypeKey = 'userID';
const sampleTopicXML = '<MetaData version="1.0.0">' +
'<Module name="HelloWorldData">' +
'<Struct name="Msg">' +
'<Member name="userID"><Long/></Member>' +
'<Member name="message"><Long/></Member>' +
'</Struct>' +
'</Module>' +
'</MetaData>';

const dirpath = 'test_data' + path.sep;
const relqospath = dirpath + 'DDS_PersistentQoS_All.xml';
const absqospath = path.resolve(relqospath);
const qosuri = 'file://' + absqospath;
const emptyqp = path.resolve(dirpath + 'Empty_Entity_QoS.xml');
const profile = 'DDS PersistentQosProfile';

const entityQosUri = 'file://'
  + path.resolve(dirpath
    + 'DDS_EntityQoS.xml');
const entityQosProfile = 'DDS EntityQosProfile';

function SEC_TO_MILI(n) {
  return n * 1000;
}

describe('QoS Provider class tests', function() {
  var dp = null;
  before(function(){
    this.timeout(SEC_TO_MILI(10));
    dp = new dcps.Participant();
  });

  after(async function() {
    this.timeout(SEC_TO_MILI(20));
    await dp.delete();
  });

  it('qos provider fails with invalid qospath', function() {
    expect(function() {
      // eslint-disable-next-line no-unused-vars
      var qp = new qos.QoSProvider(
        'home/dds.xml',
        'DDS PersistentQosProfile'
      );
    }).to.throw(ddserr.DDSError).with
      .property('ddsErrCode').to.be.within(1, 12);
  });

  it('qos provider with absolute qospath', function() {
    let qosprovide = new qos.QoSProvider(absqospath, profile);
    expect(qosprovide).to.not.be.null;
    qosprovide.delete();
  });

  it('qos provider with relative qospath', function() {
    let qosprovide = new qos.QoSProvider(relqospath, profile);
    expect(qosprovide).to.not.be.null;
    qosprovide.delete();
  });

  it('qos provider with file uri qospath', function() {
    let qosprovide = new qos.QoSProvider(qosuri, profile);
    expect(qosprovide).to.not.be.null;
    qosprovide.delete();
  });

  it('invalid type for qospath', function() {
    expect(function() {
      // eslint-disable-next-line no-unused-vars
      var qp = new qos.QoSProvider(1234, profile);
    }).to.throw(TypeError);
  });

  it('try to delete qos twice', function(){
    let qosprovide = new qos.QoSProvider(qosuri, profile);
    let pqos = qosprovide.getParticipantQos();
    pqos.delete();
    expect(function() {
      pqos.delete();
    }).to.not.throw(Error);
    qosprovide.delete();
  });

  it('getParticipantQos test when no participant qos is available', function() {
    let qosprovide = new qos.QoSProvider(emptyqp, profile);
    expect(function() { qosprovide.getParticipantQos(); })
      .to.throw(ddserr.DDSError)
      .with.property('ddsErrCode').to.be.within(1, 12);
    qosprovide.delete();
  });

  it('getSubscriberQoS test when no subscriber qos is available', function() {
    let qosprovide = new qos.QoSProvider(emptyqp, profile);
    expect(function() { qosprovide.getSubscriberQos(); })
      .to.throw(ddserr.DDSError)
      .with.property('ddsErrCode').to.be.within(1, 12);
    qosprovide.delete();
  });

  it('getPublisherQos test when no publisher qos is available', function() {
    let qosprovide = new qos.QoSProvider(emptyqp, profile);
    expect(function() { qosprovide.getPublisherQos(); })
      .to.throw(ddserr.DDSError)
      .with.property('ddsErrCode').to.be.within(1, 12);
    qosprovide.delete();
  });

  it('getTopicQos test when no topic qos is available', function() {
    let qosprovide = new qos.QoSProvider(emptyqp, profile);
    expect(function() { qosprovide.getTopicQos(); })
      .to.throw(ddserr.DDSError)
      .with.property('ddsErrCode').to.be.within(1, 12);
    qosprovide.delete();
  });

  it('getReaderQos test id = b', function() {
    const qosprovide = new qos.QoSProvider(qosuri, profile);
    const rqos = qosprovide.getReaderQos('b');
    qosprovide.delete();
    const typeSupport = new TypeSupport(sampleTypeName, sampleTypeKey,
      sampleTopicXML);
    const topic = dp.createTopic(
      'sampleTopic3',
      typeSupport
    );
    const reader = dp.createReader(topic, rqos);
    rqos.delete();
    expect(reader).to.not.be.null;
  });

  it('getReaderQos test null id', function() {
    let qosprovide = new qos.QoSProvider(qosuri, profile);
    expect(function() {
      qosprovide.getReaderQos();
    }).to.throw(Error);
    qosprovide.delete();
  });

  it('getReaderQos test when no reader qos is available', function() {
    let qosprovide = new qos.QoSProvider(emptyqp, profile);
    expect(function() { qosprovide.getReaderQos(); })
      .to.throw(ddserr.DDSError)
      .with.property('ddsErrCode').to.be.within(1, 12);
    qosprovide.delete();
  });

  it('getWriterQos test when no writer qos is available', function() {
    let qosprovide = new qos.QoSProvider(emptyqp, profile);
    expect(function() { qosprovide.getWriterQos(); })
      .to.throw(ddserr.DDSError)
      .with.property('ddsErrCode').to.be.within(1, 12);
    qosprovide.delete();
  });

  it('get participantDefault qos test', function() {
    let pqos = qos.QoS.participantDefault();
    expect(pqos).to.not.be.null;
    pqos.delete();
  });

  it('get topicDefault qos test', function() {
    let tqos = qos.QoS.topicDefault();
    expect(tqos).to.not.be.null;
    tqos.delete();
  });

  it('get publisherDefault qos test', function() {
    let pubqos = qos.QoS.publisherDefault();
    expect(pubqos).to.not.be.null;
    pubqos.delete();
  });

  it('get subscriberDefault qos test', function() {
    let subqos = qos.QoS.subscriberDefault();
    expect(subqos).to.not.be.null;
    subqos.delete();
  });

  it('get readerDefault qos test', function() {
    let rqos = qos.QoS.readerDefault();
    expect(rqos).to.not.be.null;
    rqos.delete();
  });

  it('get writerDefault qos test', function() {
    let wqos = qos.QoS.writerDefault();
    expect(wqos).to.not.be.null;
    wqos.delete();
  });

  it('getWriterQos test', function() {
    const qosprovide = new qos.QoSProvider(qosuri, profile);
    const wqos = qosprovide.getWriterQos();
    qosprovide.delete();
    const jsobj = wqos.durability;
    expect(jsobj.kind).to.be.equal(qos.DurabilityKind.Persistent);
    const typeSupport = new TypeSupport(sampleTypeName, sampleTypeKey,
      sampleTopicXML);
    const topic = dp.createTopic(
      'sampleTopic3',
      typeSupport
    );
    const writer = dp.createWriter(topic, wqos);
    wqos.delete();
    expect(writer).to.not.be.null;
  });

  it('getReaderQos test', function() {
    const qosprovide = new qos.QoSProvider(qosuri, profile);
    const rqos = qosprovide.getReaderQos('a');
    qosprovide.delete();
    const jsobj = rqos.durability;
    expect(jsobj.kind).to.be.equal(qos.DurabilityKind.Persistent);
    const typeSupport = new TypeSupport(sampleTypeName, sampleTypeKey,
      sampleTopicXML);
    const topic = dp.createTopic(
      'sampleTopic3',
      typeSupport
    );
    const reader = dp.createReader(topic, rqos);
    rqos.delete();
    expect(reader).to.not.be.null;
  });

  it('getTopicQos test', function() {
    const qosprovide = new qos.QoSProvider(qosuri, profile);
    const tqos = qosprovide.getTopicQos();
    qosprovide.delete();
    const jsobj = tqos.durability;
    expect(jsobj.kind).to.be.equal(qos.DurabilityKind.Persistent);
    const typeSupport = new TypeSupport(sampleTypeName, sampleTypeKey,
      sampleTopicXML);
    const topic = dp.createTopic(
      'sampleTopic1',
      typeSupport,
      tqos
    );
    tqos.delete();
    expect(topic).to.not.be.null;
  });

  it('getPublisherQos test', function() {
    const qosprovide = new qos.QoSProvider(qosuri, profile);
    const pubqos = qosprovide.getPublisherQos();
    qosprovide.delete();
    const scope = pubqos.presentation;
    expect(scope.accessScope).to.be.equal(
      qos.PresentationAccessScopeKind.Instance);
    const pub = dp.createPublisher(pubqos);
    pubqos.delete();
    expect(pub).to.not.be.null;
  });

  it('getSubscriberQos test', function() {
    const qosprovide = new qos.QoSProvider(qosuri, profile);
    const subqos = qosprovide.getSubscriberQos();
    qosprovide.delete();
    const scope = subqos.presentation;
    expect(scope.accessScope).to.be.equal(
      qos.PresentationAccessScopeKind.Instance);
    const sub = dp.createSubscriber(subqos);
    subqos.delete();
    expect(sub).to.not.be.null;
  });

  it('getParticipantQos test', async function() {
    let qosprovide = new qos.QoSProvider(qosuri, profile);
    let pqos = qosprovide.getParticipantQos();
    qosprovide.delete();
    this.timeout(10000);
    let participant = new dcps.Participant(DDS_DOMAIN_DEFAULT, pqos);
    pqos.delete();
    expect(participant).to.not.be.null;
    await participant.delete();
  });

  it('Create QoS sets durabilityService policy', function() {
    const tqos = new qos.QoS();
    const topicDefaultQos = qos.QoS.topicDefault();
    const tqosFromCqos = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    expect(tqosFromCqos.durabilityService.kind).to.be
      .equal(topicDefaultQos.durabilityService.kind);
  });

  it('Create QoS with dealine policy', function() {
    const tqos = new qos.QoS({deadline: {deadline: 3000}});
    const tqosFromCqos = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    expect(tqosFromCqos.deadline.deadline).to.be.equal(3000);
  });

  it('Create topic with reliability set QoS', function() {
    const tqos = new qos.QoS({
      reliability: {kind: qos.ReliabilityKind.Reliable},
    });
    const typeSupport = new TypeSupport(sampleTypeName, sampleTypeKey,
      sampleTopicXML);
    const tp = dp.createTopic(
      'sampleTopic4',
      typeSupport,
      tqos
    );
    expect(tp).not.to.be.null;
  });

  it('Create reader with durability set QoS', function() {
    const q = new qos.QoS({durability: {kind: qos.DurabilityKind.Transient}});
    const typeSupport = new TypeSupport(sampleTypeName, sampleTypeKey,
      sampleTopicXML);
    const tp = dp.createTopic(
      'sampleTopic5',
      typeSupport,
      q
    );
    const rd = dp.createReader(tp, q);
    expect(rd).not.to.be.null;
  });

  it('Create writer with destinationOrder set QoS', function() {
    const q = new qos.QoS({
      destinationOrder: {kind: qos.DestinationOrderKind.BySourceTimestamp},
    });
    const typeSupport = new TypeSupport(sampleTypeName, sampleTypeKey,
      sampleTopicXML);
    const tp = dp.createTopic(
      'sampleTopic6',
      typeSupport,
      q
    );
    const wr = dp.createWriter(tp, q);
    expect(wr).not.to.be.null;
  });

  it('Get entity qos after creating writer entity', function() {
    const q = new qos.QoS({deadline: {deadline: 1000}});
    const typeSupport = new TypeSupport(sampleTypeName, sampleTypeKey,
      sampleTopicXML);
    const tp = dp.createTopic(
      'sampleTopic7',
      typeSupport,
      q
    );
    const wr = dp.createWriter(tp, q);
    expect(wr).not.to.be.null;
    const wrQos = wr.qos;
    const wrDefaultQos = qos.QoS.writerDefault();
    expect(wrQos.deadline.deadline).to.be.equal(1000);
    expect(wrQos.lifespan.lifespan).to.be.equal(wrDefaultQos.lifespan.lifespan);
    expect(wrQos.resourceLimits).to.be.deep.equal(wrDefaultQos.resourceLimits);
  });

});

describe('Get and set userdata, topicdata and groupdata QoS tests', function() {

  it('userdata qos policy', function() {
    const dpqos = qos.QoS.participantDefault();
    dpqos.userdata = {value: 'test'};
    const dpqosUpdated = qos.getQoSObjectAndDeleteHandle(dpqos.asCQos());
    const jsobj = dpqosUpdated.userdata;
    expect(jsobj.value).to.be.equal('test');
    dpqos.delete();
  });

  it('userdata qos policy with undefined value', function() {
    const dpqos = qos.QoS.participantDefault();
    const defaultQos = dpqos.userdata;
    dpqos.userdata = {kind: 'test'};
    const dpqosUpdated = qos.getQoSObjectAndDeleteHandle(dpqos.asCQos());
    const jsobj = dpqosUpdated.userdata;
    expect(jsobj.value).to.be.equal(defaultQos.value);
    dpqos.delete();
  });

  it('userdataRaw qos policy', function() {
    const dpqos = qos.QoS.participantDefault();
    dpqos.userdata = {value: 'test'};
    const dpqosUpdated = qos.getQoSObjectAndDeleteHandle(dpqos.asCQos());
    const jsobj = dpqosUpdated.userdataRaw; // expect a buffer
    expect(jsobj.value.toString('binary')).to.be.equal('test');
    dpqos.delete();
  });

  it('userdata qos policy with non buffer input', function() {
    const dpqos = qos.QoS.participantDefault();
    expect(function() {
      dpqos.userdata = {value: 1234};
    }).to.throw(Error);
    dpqos.delete();
  });

  it('userdata qos policy with null value', function() {
    const dpqos = qos.QoS.participantDefault();
    dpqos.userdata = {value: null};
    const dpqosUpdated = qos.getQoSObjectAndDeleteHandle(dpqos.asCQos());
    const jsobj = dpqosUpdated.userdata;
    expect(jsobj.value).to.be.equal('');
    dpqos.delete();
  });

  it('set userdata qos policy with buffer input', function() {
    const dpqos = qos.QoS.participantDefault();
    dpqos.userdata = {value: Buffer.from('hello')};
    const dpqosUpdated = qos.getQoSObjectAndDeleteHandle(dpqos.asCQos());
    const jsobj = dpqosUpdated.userdata;
    expect(jsobj.value).to.be.equal('hello');
    dpqos.delete();
  });

  it('topicdata qos policy', function() {
    const tqos = qos.QoS.topicDefault();
    tqos.topicdata = {value: 'test'};
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    const jsobj = tqosUpdated.topicdata;
    expect(jsobj.value).to.be.equal('test');
    tqos.delete();
  });

  it('topicdataRaw qos policy', function() {
    const tqos = qos.QoS.topicDefault();
    tqos.topicdata = {value: 'test'};
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    const jsobj = tqosUpdated.topicdataRaw; // expect a buffer
    expect(jsobj.value.toString('binary')).to.be.equal('test');
    tqos.delete();
  });

  it('topicdata qos policy with non buffer input', function() {
    const tqos = qos.QoS.topicDefault();
    expect(function() {
      tqos.topicdata = {value: 1234};
    }).to.throw(Error);
    tqos.delete();
  });

  it('topicdata qos policy with null value', function() {
    const tqos = qos.QoS.topicDefault();
    tqos.topicdata = {value: null};
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    const jsobj = tqosUpdated.topicdata;
    expect(jsobj.value).to.be.equal('');
    tqos.delete();
  });

  it('set topicdata qos policy with buffer input', function() {
    const tqos = qos.QoS.topicDefault();
    tqos.topicdata = {value: Buffer.from('hello')};
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    const jsobj = tqosUpdated.topicdata;
    expect(jsobj.value).to.be.equal('hello');
    tqos.delete();
  });

  it('groupdata qos policy', function() {
    const subqos = qos.QoS.subscriberDefault();
    subqos.groupdata = {value: 'test'};
    const subqosUpdated = qos.getQoSObjectAndDeleteHandle(subqos.asCQos());
    const jsobj = subqosUpdated.groupdata;
    expect(jsobj.value).to.be.equal('test');
    subqos.delete();
  });

  it('groupdataRaw qos policy', function() {
    const subqos = qos.QoS.subscriberDefault();
    subqos.groupdata = {value: 'test'};
    const subqosUpdated = qos.getQoSObjectAndDeleteHandle(subqos.asCQos());
    const jsobj = subqosUpdated.groupdataRaw; // expect a buffer
    expect(jsobj.value.toString('binary')).to.be.equal('test');
    subqos.delete();
  });

  it('groupdata qos policy with non buffer input', function() {
    const subqos = qos.QoS.subscriberDefault();
    expect(function() {
      subqos.groupdata = {value: 1234};
    }).to.throw(Error);
    subqos.delete();
  });

  it('set groupdata qos policy with null value', function() {
    const subqos = qos.QoS.subscriberDefault();
    subqos.groupdata = {value: null};
    const subqosUpdated = qos.getQoSObjectAndDeleteHandle(subqos.asCQos());
    const jsobj = subqosUpdated.groupdata;
    expect(jsobj.value).to.be.equal('');
    subqos.delete();
  });

  it('set groupdata qos policy with buffer input', function() {
    const subqos = qos.QoS.subscriberDefault();
    subqos.groupdata = {value: Buffer.from('hello')};
    const subqosUpdated = qos.getQoSObjectAndDeleteHandle(subqos.asCQos());
    const jsobj = subqosUpdated.groupdata;
    expect(jsobj.value).to.be.equal('hello');
    subqos.delete();
  });
});

describe('Get QoS policy tests', function() {

  it('get durability policy', function() {
    const qp = new qos.QoSProvider(qosuri, profile);
    const tqos = qp.getTopicQos();
    qp.delete();
    const jsobj = tqos.durability;
    expect(jsobj.kind).to.be.equal(qos.DurabilityKind.Persistent);
    tqos.delete();
  });

  it('get history policy', function() {
    let qp = new qos.QoSProvider(qosuri, profile);
    let wqos = qp.getWriterQos();
    qp.delete();
    let history = wqos.history;
    expect(history.kind).to.be.equal(qos.HistoryKind.KeepLast);
    wqos.delete();
  });

  it('get resource limits policy', function() {
    let qp = new qos.QoSProvider(qosuri, profile);
    let wqos = qp.getWriterQos();
    qp.delete();
    let rlPolicy = wqos.resourceLimits;
    expect(rlPolicy.maxSamples).to.be.equal(-1);
    expect(rlPolicy.maxInstances).to.be.equal(-1);
    expect(rlPolicy.maxSamplesPerInstance).to.be.equal(-1);
    wqos.delete();
  });

  it('get presentation policy', function() {
    let qp = new qos.QoSProvider(qosuri, profile);
    let subqos = qp.getSubscriberQos();
    qp.delete();
    let pPolicy = subqos.presentation;
    expect(pPolicy.accessScope).to
      .be.equal(qos.PresentationAccessScopeKind.Instance);
    subqos.delete();
  });

  it('get lifespan policy', function() {
    const qp = new qos.QoSProvider(entityQosUri, entityQosProfile);
    const tqos = qp.getTopicQos();
    qp.delete();
    const jsobj = tqos.lifespan;
    expect(jsobj.lifespan).to.be.equal(3600);
    tqos.delete();
  });

  it('get deadline policy', function() {
    const qp = new qos.QoSProvider(entityQosUri, entityQosProfile);
    const tqos = qp.getTopicQos();
    qp.delete();
    const jsobj = tqos.deadline;
    expect(jsobj.deadline).to.be.equal(5000);
    tqos.delete();
  });

  it('get latency budget policy', function() {
    const qp = new qos.QoSProvider(qosuri, profile);
    const tqos = qp.getTopicQos();
    qp.delete();
    const jsobj = tqos.latencyBudget;
    expect(jsobj.duration).to.be.equal(0);
    tqos.delete();
  });

  it('get ownership policy', function() {
    const qp = new qos.QoSProvider(qosuri, profile);
    const tqos = qp.getTopicQos();
    qp.delete();
    const jsobj = tqos.ownership;
    expect(jsobj.kind).to.be.equal(qos.OwnershipKind.Shared);
    tqos.delete();
  });

  it('get ownership strength policy', function() {
    const qp = new qos.QoSProvider(qosuri, profile);
    const wqos = qp.getWriterQos();
    qp.delete();
    const jsobj = wqos.ownershipStrength;
    expect(jsobj.value).to.be.equal(0);
    wqos.delete();
  });

  it('get liveliness policy', function() {
    let qp = new qos.QoSProvider(qosuri, profile);
    let tqos = qp.getTopicQos();
    qp.delete();
    let jsobj = tqos.liveliness;
    expect(jsobj.kind).to.be.equal(qos.LivelinessKind.Automatic);
    tqos.delete();
  });

  it('get timebased filter policy', function() {
    const qp = new qos.QoSProvider(qosuri, profile);
    const rqos = qp.getReaderQos('a');
    qp.delete();
    const jsobj = rqos.timebasedFilter;
    expect(jsobj.minimumSeparation).to.be.equal(0);
    rqos.delete();
  });

  it('get partition policy', function() {
    const qp = new qos.QoSProvider(entityQosUri, entityQosProfile);
    const pubqos = qp.getPublisherQos();
    qp.delete();
    const partArr = pubqos.partition.names;
    expect(partArr.length).to.equal(2);
    expect(partArr[0]).to.be.equal('partition1');
    expect(partArr[1]).to.be.equal('partition2');
    pubqos.delete();
  });

  it('get reliability policy', function() {
    let qp = new qos.QoSProvider(qosuri, profile);
    let tqos = qp.getTopicQos();
    qp.delete();
    let jsobj = tqos.reliability;
    expect(jsobj.kind).to.be.equal(qos.ReliabilityKind.BestEffort);
    tqos.delete();
  });

  it('get transport priority policy', function() {
    const qp = new qos.QoSProvider(qosuri, profile);
    const tqos = qp.getTopicQos();
    qp.delete();
    const jsobj = tqos.transportPriority;
    expect(jsobj.value).to.be.equal(0);
    tqos.delete();
  });

  it('get destination order policy', function() {
    const qp = new qos.QoSProvider(qosuri, profile);
    const tqos = qp.getTopicQos();
    qp.delete();
    const kind = tqos.destinationOrder.kind;
    expect(kind).to.be.equal(qos.DestinationOrderKind.ByReceptionTimestamp);
    tqos.delete();
  });

  it('get writer data lifecycle policy', function() {
    const qp = new qos.QoSProvider(qosuri, profile);
    const wqos = qp.getWriterQos();
    qp.delete();
    const jsobj = wqos.writerDataLifecycle;
    expect(jsobj.autodisposeUnregisteredInstances).to.be.true;
    wqos.delete();
  });

  it('get reader data lifecycle policy', function() {
    let qp = new qos.QoSProvider(entityQosUri, entityQosProfile);
    let rqos = qp.getReaderQos();
    qp.delete();
    let jsobj = rqos.readerDataLifecycle;
    expect(jsobj.autopurgeNoWriterSamples).to.equal(1000);
    expect(jsobj.autopurgeDisposedSamplesDelay).to.equal(500);
    rqos.delete();
  });

  it('get durability service policy', function() {
    let qp = new qos.QoSProvider(qosuri, profile);
    let tqos = qp.getTopicQos();
    qp.delete();
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    let jsobj = tqosUpdated.durabilityService;
    expect(jsobj.historyKind).to.equal(qos.HistoryKind.KeepLast);
    tqos.delete();
  });
});

describe('Set QoS policy tests', function() {

  it('set userdata policy while creating QoS object', function() {
    const q = new qos.QoS({
      userdata: { value: 'testdata' },
    });
    const qUpdated = qos.getQoSObjectAndDeleteHandle(q.asCQos());
    const jsobj = qUpdated.userdata;
    expect(jsobj.value).to.equal('testdata');
  });

  it('set userdata policy to invalid type while creating QoS object',
    function() {
      // eslint-disable-next-line no-unused-vars
      let q = null;
      expect(function() {
        q = new qos.QoS({
          userdata: { value: 1234 },
        });
      }).to.throw(TypeError);
    });

  it('set userdata policy while creating QoS object ignores ' +
  'inapplicable values', function() {
    const q = new qos.QoS({
      userdata: { value: 'testdata', extraField: 'nothing'},
    });
    const qUpdated = qos.getQoSObjectAndDeleteHandle(q.asCQos());
    const jsobj = qUpdated.userdata;
    expect(jsobj.value).to.equal('testdata');
    expect(jsobj.extraField).to.be.undefined;
  });

  it('set durability policy', function() {
    const q = new qos.QoS({
      durability: { kind: qos.DurabilityKind.Persistent },
    });
    const qUpdated = qos.getQoSObjectAndDeleteHandle(q.asCQos());
    const jsobj = qUpdated.durability;
    expect(jsobj.kind).to.equal(qos.DurabilityKind.Persistent);
    q.delete();
  });

  it('set durability policy uses default values for empty input',
    function() {
      const tqos = qos.QoS.topicDefault();
      const defaultPolicy = tqos.durability;
      tqos.durability = {};
      const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
      const jsobj = tqosUpdated.durability;
      expect(jsobj.kind).to.equal(defaultPolicy.kind);
      tqos.delete();
    });

  it('set durability policy throws error for invalid type',
    function() {
      const q = new qos.QoS();
      expect(function() {
        q.durability = {kind: null};
      }).to.throw(TypeError);
      q.delete();
    });

  it('set history policy kind and depth', function() {
    let tqos = qos.QoS.topicDefault();
    tqos.history = {
      kind: qos.HistoryKind.KeepLast,
      depth: 10,
    };
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    let jsobj = tqosUpdated.history;
    expect(jsobj.kind).to.equal(qos.HistoryKind.KeepLast);
    expect(jsobj.depth).to.equal(10);
    tqos.delete();
  });

  it('set history policy kind only', function() {
    let tqos = qos.QoS.topicDefault();
    let defaultPolicy = tqos.history;
    tqos.history = { kind: qos.HistoryKind.KeepAll };
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    let jsobj = tqosUpdated.history;
    expect(jsobj.kind).to.equal(qos.HistoryKind.KeepAll);
    expect(jsobj.depth).to.equal(defaultPolicy.depth);
    tqos.delete();
  });

  it('set history policy ignores inapplicable values', function() {
    let tqos = qos.QoS.topicDefault();
    tqos.history = {kind: qos.HistoryKind.KeepAll, extraField: 1};
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    let jsobj = tqosUpdated.history;
    expect(jsobj.kind).to.equal(qos.HistoryKind.KeepAll);
    expect(jsobj.extraField).to.be.undefined;
    tqos.delete();
  });

  it('set history policy uses default values for empty input', function() {
    let tqos = qos.QoS.topicDefault();
    let defaultPolicy = tqos.history;
    tqos.history = {};
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    let jsobj = tqosUpdated.history;
    expect(jsobj.kind).to.equal(defaultPolicy.kind);
    expect(jsobj.depth).to.equal(defaultPolicy.depth);
    tqos.delete();
  });

  it('set resource limits policy', function() {
    let tqos = qos.QoS.topicDefault();
    tqos.resourceLimits = {
      maxSamples: 1,
      maxInstances: 2,
      maxSamplesPerInstance: 2,
    };
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    let jsobj = tqosUpdated.resourceLimits;
    expect(jsobj.maxSamples).to.equal(1);
    expect(jsobj.maxInstances).to.equal(2);
    expect(jsobj.maxSamplesPerInstance).to.equal(2);
    tqos.delete();
  });

  it('set resource limits policy maxInstances only', function() {
    let tqos = qos.QoS.topicDefault();
    let defaultPolicy = tqos.resourceLimits;
    tqos.resourceLimits = {maxInstances: 2};
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    let jsobj = tqosUpdated.resourceLimits;
    expect(jsobj.maxSamples).to.equal(defaultPolicy.maxSamples);
    expect(jsobj.maxInstances).to.equal(2);
    expect(jsobj.maxSamplesPerInstance).to.equal(
      defaultPolicy.maxSamplesPerInstance);
    tqos.delete();
  });

  it('set resource limits policy ignores inapplicable values', function() {
    let tqos = qos.QoS.topicDefault();
    tqos.resourceLimits = {maxInstances: 2, kind: 1};
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    let jsobj = tqosUpdated.resourceLimits;
    expect(jsobj.maxInstances).to.equal(2);
    expect(jsobj.kind).to.be.undefined;
    tqos.delete();
  });

  it('set resource limits policy uses default values for empty input',
    function() {
      let tqos = qos.QoS.topicDefault();
      let defaultPolicy = tqos.resourceLimits;
      tqos.resourceLimits = {};
      const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
      let jsobj = tqosUpdated.resourceLimits;
      expect(jsobj.maxSamples).to.equal(defaultPolicy.maxSamples);
      expect(jsobj.maxInstances).to.equal(defaultPolicy.maxInstances);
      expect(jsobj.maxSamplesPerInstance).to.equal(
        defaultPolicy.maxSamplesPerInstance);
      tqos.delete();
    });

  it('set presentation policy', function() {
    let subqos = qos.QoS.subscriberDefault();
    subqos.presentation = {
      accessScope: qos.PresentationAccessScopeKind.Group,
      coherentAccess: false,
      orderedAccess: true };
    const subqosUpdated = qos.getQoSObjectAndDeleteHandle(subqos.asCQos());
    let jsobj = subqosUpdated.presentation;
    expect(jsobj.accessScope).to
      .equal(qos.PresentationAccessScopeKind.Group);
    expect(jsobj.coherentAccess).to.be.false;
    expect(jsobj.orderedAccess).to.be.true;
    subqos.delete();
  });

  it('set presentation policy accessScope kind only', function() {
    let subqos = qos.QoS.subscriberDefault();
    let defaultPolicy = subqos.presentation;
    subqos.presentation = {
      accessScope: qos.PresentationAccessScopeKind.Group,
    };
    const subqosUpdated = qos.getQoSObjectAndDeleteHandle(subqos.asCQos());
    let jsobj = subqosUpdated.presentation;
    expect(jsobj.accessScope).to
      .equal(qos.PresentationAccessScopeKind.Group);
    expect(jsobj.coherentAccess).to.be.equal(defaultPolicy.coherentAccess);
    expect(jsobj.orderedAccess).to.be.equal(defaultPolicy.orderedAccess);
    subqos.delete();
  });

  it('set presentation policy ignores inapplicable values', function() {
    let subqos = qos.QoS.subscriberDefault();
    subqos.presentation = {
      accessScope: qos.PresentationAccessScopeKind.Group,
      extraField: 1,
    };
    let subqosUpdated = qos.getQoSObjectAndDeleteHandle(subqos.asCQos());
    let jsobj = subqosUpdated.presentation;
    expect(jsobj.accessScope).to
      .equal(qos.PresentationAccessScopeKind.Group);
    expect(jsobj.extraField).to.be.undefined;
    subqos.delete();
  });

  it('set presentation policy uses default values for empty input',
    function() {
      let subqos = qos.QoS.subscriberDefault();
      let defaultPolicy = subqos.presentation;
      subqos.presentation = {};
      const subqosUpdated = qos.getQoSObjectAndDeleteHandle(subqos.asCQos());
      let jsobj = subqosUpdated.presentation;
      expect(jsobj.accessScope).to
        .equal(defaultPolicy.accessScope);
      expect(jsobj.coherentAccess).to.be.equal(defaultPolicy.coherentAccess);
      expect(jsobj.orderedAccess).to.be.equal(defaultPolicy.orderedAccess);
      subqos.delete();
    });

  it('set lifespan to a number', function() {
    const tqos = qos.QoS.topicDefault();
    tqos.lifespan = {lifespan: 5000};
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    const jsobj = tqosUpdated.lifespan;
    expect(jsobj.lifespan).to.equal(5000);
    tqos.delete();
  });


  it('set lifespan to a string', function() {
    const tqos = qos.QoS.topicDefault();
    tqos.lifespan = {lifespan: '5000'};
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    const jsobj = tqosUpdated.lifespan;
    expect(jsobj.lifespan).to.equal(5000);
    tqos.delete();
  });

  it('set lifespan to infinity', function() {
    const tqos = qos.QoS.topicDefault();
    tqos.lifespan = {lifespan: dcps.DDSConstants.DDS_INFINITY};
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    const jsobj = tqosUpdated.lifespan;
    expect(jsobj.lifespan).to.equal('9223372036854775807');
    tqos.delete();
  });

  it('set lifespan policy uses default values for empty input',
    function() {
      const tqos = qos.QoS.topicDefault();
      const defaultPolicy = tqos.lifespan;
      tqos.lifespan = {};
      const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
      const jsobj = tqosUpdated.lifespan;
      expect(jsobj.lifespan).to.equal(defaultPolicy.lifespan);
      tqos.delete();
    });

  it('set lifespan policy callback throws error for invalid input type',
    function() {
      const tqos = qos.QoS.topicDefault();
      expect(function() {
        tqos.lifespan = {lifespan: 'aaa'};
      }).to.throw(TypeError);
      tqos.delete();
    });

  it('set deadline policy', function() {
    const tqos = qos.QoS.topicDefault();
    tqos.deadline = {deadline: 3000};
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    const jsobj = tqosUpdated.deadline;
    expect(jsobj.deadline).to.equal(3000);
    tqos.delete();
  });

  it('set deadline policy uses default values for empty input',
    function() {
      const tqos = qos.QoS.topicDefault();
      const defaultPolicy = tqos.deadline;
      tqos.deadline = {};
      const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
      const jsobj = tqosUpdated.deadline;
      expect(jsobj.deadline).to.equal(defaultPolicy.deadline);
      tqos.delete();
    });

  it('set deadline policy callback throws error for invalid input type',
    function() {
      const tqos = qos.QoS.topicDefault();
      expect(function() {
        tqos.deadline = {deadline: 'aaa'};
      }).to.throw(TypeError);
      tqos.delete();
    });

  it('set latency budget policy duration to a number', function() {
    const tqos = qos.QoS.topicDefault();
    tqos.latencyBudget = {duration: 4000};
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    const jsobj = tqosUpdated.latencyBudget;
    expect(jsobj.duration).to.equal(4000);
    tqos.delete();
  });

  it('set latency budget policy duration to a string', function() {
    const tqos = qos.QoS.topicDefault();
    tqos.latencyBudget = {duration: '4000'};
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    const jsobj = tqosUpdated.latencyBudget;
    expect(jsobj.duration).to.equal(4000);
    tqos.delete();
  });

  it('set latency budget policy duration to infinity', function() {
    const tqos = qos.QoS.topicDefault();
    tqos.latencyBudget = {duration: dcps.DDSConstants.DDS_INFINITY};
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    const jsobj = tqosUpdated.latencyBudget;
    expect(jsobj.duration).to.equal('9223372036854775807');
    tqos.delete();
  });

  it('set latency budget policy uses default values for empty input',
    function() {
      const tqos = qos.QoS.topicDefault();
      const defaultPolicy = tqos.latencyBudget;
      tqos.latencyBudget = {};
      const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
      const jsobj = tqosUpdated.latencyBudget;
      expect(jsobj.duration).to.equal(defaultPolicy.duration);
      tqos.delete();
    });

  it('set latency budget policy callback throws error for invalid input type',
    function() {
      const tqos = qos.QoS.topicDefault();
      expect(function() {
        tqos.latencyBudget = {duration: 'aaa'};
      }).to.throw(TypeError);
      tqos.delete();
    });

  it('set ownership policy', function() {
    const tqos = qos.QoS.topicDefault();
    tqos.ownership = {kind: qos.OwnershipKind.Exclusive};
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    const jsobj = tqosUpdated.ownership;
    expect(jsobj.kind).to.equal(qos.OwnershipKind.Exclusive);
    tqos.delete();
  });

  it('set ownership policy uses default values for empty input',
    function() {
      const tqos = qos.QoS.topicDefault();
      const defaultPolicy = tqos.ownership;
      tqos.ownership = {};
      const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
      const jsobj = tqosUpdated.ownership;
      expect(jsobj.kind).to.equal(defaultPolicy.kind);
      tqos.delete();
    });

  it('set ownership policy throws TypeError for invalid input type',
    function() {
      const tqos = qos.QoS.topicDefault();
      expect(function() {
        tqos.ownership = {kind: null};
      }).to.throw(TypeError);
      tqos.delete();
    });

  it('set ownership strength policy', function() {
    const wqos = qos.QoS.writerDefault();
    wqos.ownershipStrength = {value: 3};
    const wqosUpdated = qos.getQoSObjectAndDeleteHandle(wqos.asCQos());
    const jsobj = wqosUpdated.ownershipStrength;
    expect(jsobj.value).to.equal(3);
    wqos.delete();
  });

  it('set ownership strength policy uses default values for empty input',
    function() {
      const wqos = qos.QoS.writerDefault();
      const defaultPolicy = wqos.ownershipStrength;
      wqos.ownershipStrength = {};
      const wqosUpdated = qos.getQoSObjectAndDeleteHandle(wqos.asCQos());
      const jsobj = wqosUpdated.ownershipStrength;
      expect(jsobj.value).to.equal(defaultPolicy.value);
      wqos.delete();
    });

  it('set ownership strength policy throws error for invalid input type',
    function() {
      const wqos = qos.QoS.writerDefault();
      expect(function() {
        wqos.ownershipStrength = {value: null};
      }).to.throw(TypeError);
      wqos.delete();
    });

  it('set liveliness policy', function() {
    let tqos = qos.QoS.topicDefault();
    tqos.liveliness = {
      kind: qos.LivelinessKind.ManualByTopic,
      leaseDuration: 10,
    };
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    let jsobj = tqosUpdated.liveliness;
    expect(jsobj.kind).to.equal(qos.LivelinessKind.ManualByTopic);
    expect(jsobj.leaseDuration).to.equal(10);
    tqos.delete();
  });

  it('set leaseDuration to a string', function() {
    const tqos = qos.QoS.topicDefault();
    tqos.liveliness = {leaseDuration: '10'};
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    const jsobj = tqosUpdated.liveliness;
    expect(jsobj.leaseDuration).to.equal(10);
    tqos.delete();
  });

  it('set leaseDuration to infinity', function() {
    const tqos = qos.QoS.topicDefault();
    tqos.liveliness = {leaseDuration: dcps.DDSConstants.DDS_INFINITY};
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    const jsobj = tqosUpdated.liveliness;
    expect(jsobj.leaseDuration).to.equal('9223372036854775807');
    tqos.delete();
  });

  it('set liveliness policy kind only', function() {
    let tqos = qos.QoS.topicDefault();
    let defaultPolicy = tqos.liveliness;
    tqos.liveliness = {kind: qos.LivelinessKind.ManualByTopic};
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    let jsobj = tqosUpdated.liveliness;
    expect(jsobj.kind).to.equal(qos.LivelinessKind.ManualByTopic);
    expect(jsobj.leaseDuration).to.be.equal(defaultPolicy.leaseDuration);
    tqos.delete();
  });

  it('set liveliness policy ignores inapplicable values', function() {
    const tqos = qos.QoS.topicDefault();
    tqos.liveliness = {
      kind: qos.LivelinessKind.ManualByTopic,
      extraField: 1,
    };
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    const jsobj = tqosUpdated.liveliness;
    expect(jsobj.kind).to.equal(qos.LivelinessKind.ManualByTopic);
    expect(jsobj.extraField).to.be.undefined;
    tqos.delete();
  });

  it('set liveliness policy uses default values for empty input',
    function() {
      let tqos = qos.QoS.topicDefault();
      let defaultPolicy = tqos.liveliness;
      tqos.liveliness = {};
      const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
      let jsobj = tqosUpdated.liveliness;
      expect(jsobj.kind).to.equal(defaultPolicy.kind);
      expect(jsobj.leaseDuration).to.equal(defaultPolicy.leaseDuration);
      tqos.delete();
    });

  it('set time based filter policy', function() {
    const rqos = qos.QoS.readerDefault();
    rqos.timebasedFilter = {minimumSeparation: 60000};
    const rqosUpdated = qos.getQoSObjectAndDeleteHandle(rqos.asCQos());
    const jsobj = rqosUpdated.timebasedFilter;
    expect(jsobj.minimumSeparation).to.equal(60000);
    rqos.delete();
  });

  it('set minimumseparation to a string', function() {
    const rqos = qos.QoS.readerDefault();
    rqos.timebasedFilter = {minimumSeparation: 60000};
    const rqosUpdated = qos.getQoSObjectAndDeleteHandle(rqos.asCQos());
    const jsobj = rqosUpdated.timebasedFilter;
    expect(jsobj.minimumSeparation).to.equal(60000);
    rqos.delete();
  });

  it('set minimumseparation to infinity', function() {
    const rqos = qos.QoS.readerDefault();
    rqos.timebasedFilter = {minimumSeparation: dcps.DDSConstants.DDS_INFINITY};
    const rqosUpdated = qos.getQoSObjectAndDeleteHandle(rqos.asCQos());
    const jsobj = rqosUpdated.timebasedFilter;
    expect(jsobj.minimumSeparation).to.equal('9223372036854775807');
    rqos.delete();
  });

  it('set time based filter policy uses default values for empty input',
    function() {
      const rqos = qos.QoS.readerDefault();
      const defaultPolicy = rqos.timebasedFilter;
      rqos.timebasedFilter = {};
      const rqosUpdated = qos.getQoSObjectAndDeleteHandle(rqos.asCQos());
      const jsobj = rqosUpdated.timebasedFilter;
      expect(jsobj.minimumSeparation).to.equal(defaultPolicy.minimumSeparation);
      rqos.delete();
    });

  it('set timebased filter policy callback throws error for invalid input type',
    function() {
      const rqos = qos.QoS.readerDefault();
      expect(function() {
        rqos.timebasedFilter = {minimumSeparation: 'aaa'};
      }).to.throw(TypeError);
      rqos.delete();
    });

  it('set partition qos', function() {
    const pubqos = qos.QoS.publisherDefault();
    pubqos.partition = {
      names: ['partition1', 'partition2'],
    };
    const pubqosUpdated = qos.getQoSObjectAndDeleteHandle(pubqos.asCQos());
    const partition = pubqosUpdated.partition.names;
    expect(partition.length).to.equal(2);
    expect(partition[0]).to.be.equal('partition1');
    expect(partition[1]).to.be.equal('partition2');
    pubqos.delete();
  });

  it('set partition to an input string', function() {
    const pubqos = qos.QoS.publisherDefault();
    pubqos.partition = {
      names: 'partition1',
    };
    const pubqosUpdated = qos.getQoSObjectAndDeleteHandle(pubqos.asCQos());
    const partition = pubqosUpdated.partition.names;
    expect(partition.length).to.equal(1);
    expect(partition[0]).to.be.equal('partition1');
    pubqos.delete();
  });

  it('set partition set default partition for empty object', function() {
    const pubqos = qos.QoS.publisherDefault();
    pubqos.partition = {};
    const pubqosUpdated = qos.getQoSObjectAndDeleteHandle(pubqos.asCQos());
    const partition = pubqosUpdated.partition.names;
    expect(partition.length).to.equal(0);
    pubqos.delete();
  });

  it('set partition to an empty string', function() {
    const pubqos = qos.QoS.publisherDefault();
    pubqos.partition = {
      names: '',
    };
    const pubqosUpdated = qos.getQoSObjectAndDeleteHandle(pubqos.asCQos());
    const partition = pubqosUpdated.partition.names;
    expect(partition.length).to.equal(1);
    expect(partition[0]).to.be.equal('');
    pubqos.delete();
  });

  it('set partition to an empty array', function() {
    const pubqos = qos.QoS.publisherDefault();
    pubqos.partition = {
      names: [''],
    };
    const pubqosUpdated = qos.getQoSObjectAndDeleteHandle(pubqos.asCQos());
    const partition = pubqosUpdated.partition.names;
    expect(partition.length).to.equal(1);
    expect(partition[0]).to.be.equal('');
    pubqos.delete();
  });

  it('set partition input number throws TypeError', function() {
    const pubqos = qos.QoS.publisherDefault();
    expect(function() {
      pubqos.partition = {names: 48};
    }).to.throw(TypeError);
    pubqos.delete();
  });

  it('set reliability policy', function() {
    let tqos = qos.QoS.topicDefault();
    tqos.reliability = {
      kind: qos.ReliabilityKind.Reliable,
      maxBlockingTime: 100,
    };
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    let jsobj = tqosUpdated.reliability;
    expect(jsobj.kind).to.equal(qos.ReliabilityKind.Reliable);
    expect(jsobj.maxBlockingTime).to.equal(100);
    tqos.delete();
  });

  it('set maxBlockingTime to a string', function() {
    const tqos = qos.QoS.topicDefault();
    tqos.reliability = {
      maxBlockingTime: '100',
    };
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    const jsobj = tqosUpdated.reliability;
    expect(jsobj.maxBlockingTime).to.equal(100);
    tqos.delete();
  });

  it('set maxBlockingTime to infinity', function() {
    const tqos = qos.QoS.topicDefault();
    tqos.reliability = {
      maxBlockingTime: dcps.DDSConstants.DDS_INFINITY,
    };
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    const jsobj = tqosUpdated.reliability;
    expect(jsobj.maxBlockingTime).to.equal('9223372036854775807');
    tqos.delete();
  });

  it('set reliability policy kind only', function() {
    let tqos = qos.QoS.topicDefault();
    let defaultPolicy = tqos.reliability;
    tqos.reliability = {kind: qos.ReliabilityKind.Reliable};
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    let jsobj = tqosUpdated.reliability;
    expect(jsobj.kind).to.equal(qos.ReliabilityKind.Reliable);
    expect(jsobj.maxBlockingTime).to.be.equal(defaultPolicy.maxBlockingTime);
    tqos.delete();
  });

  it('set reliability policy ignores inapplicable values', function() {
    const tqos = qos.QoS.topicDefault();
    tqos.reliability = {
      kind: qos.ReliabilityKind.Reliable,
      extraField: 1};
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    const jsobj = tqosUpdated.reliability;
    expect(jsobj.kind).to.equal(qos.ReliabilityKind.Reliable);
    expect(jsobj.extraField).to.be.undefined;
    tqos.delete();
  });

  it('set reliability policy uses default values for empty input',
    function() {
      let tqos = qos.QoS.topicDefault();
      let defaultPolicy = tqos.reliability;
      tqos.reliability = {};
      const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
      let jsobj = tqosUpdated.reliability;
      expect(jsobj.kind).to.equal(defaultPolicy.kind);
      expect(jsobj.maxBlockingTime).to.equal(defaultPolicy.maxBlockingTime);
      tqos.delete();
    });

  it('set transport priority policy', function() {
    const tqos = qos.QoS.topicDefault();
    tqos.transportPriority = {value: 5};
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    const jsobj = tqosUpdated.transportPriority;
    expect(jsobj.value).to.equal(5);
    tqos.delete();
  });

  it('set transport priority policy ignores if value is undefined', function() {
    const tqos = qos.QoS.topicDefault();
    const defaultPolicy = tqos.transportPriority;
    tqos.transportPriority = {
      kind: 1,
    };
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    const jsobj = tqosUpdated.transportPriority;
    expect(jsobj.value).to.equal(defaultPolicy.value);
    tqos.delete();
  });

  it('set transport priority policy throws error for invalid input type',
    function() {
      const tqos = qos.QoS.topicDefault();
      expect(function() {
        tqos.transportPriority = {value: 'aaaaaa'};
      }).to.throw(TypeError);
      tqos.delete();
    });

  it('set destination order policy', function() {
    const tqos = qos.QoS.topicDefault();
    tqos.destinationOrder = {
      kind: qos.DestinationOrderKind.BySourceTimestamp,
    };
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    const jsobj = tqosUpdated.destinationOrder;
    expect(jsobj.kind).to.equal(qos.DestinationOrderKind.BySourceTimestamp);
    tqos.delete();
  });

  it('set destination order policy ignores if kind is undefined', function() {
    const tqos = qos.QoS.topicDefault();
    const defaultPolicy = tqos.destinationOrder;
    tqos.destinationOrder = {
      value: 1,
    };
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    const jsobj = tqosUpdated.destinationOrder;
    expect(jsobj.kind).to.equal(defaultPolicy.kind);
    tqos.delete();
  });

  it('set destination order policy throws error for invalid input type',
    function() {
      const tqos = qos.QoS.topicDefault();
      expect(function() {
        tqos.destinationOrder = {kind: null};
      }).to.throw(TypeError);
      tqos.delete();
    });

  it('set writer data lifecycle policy', function() {
    const wqos = qos.QoS.writerDefault();
    wqos.writerDataLifecycle = {autodisposeUnregisteredInstances: false};
    const wqosUpdated = qos.getQoSObjectAndDeleteHandle(wqos.asCQos());
    const jsobj = wqosUpdated.writerDataLifecycle;
    expect(jsobj.autodisposeUnregisteredInstances).to.be.false;
    wqos.delete();
  });

  it('set writer data lifecycle policy ignores if ' +
    'autodisposeUnregisteredInstances is undefined',
  function() {
    const wqos = qos.QoS.writerDefault();
    const defaultPolicy = wqos.writerDataLifecycle;
    wqos.writerDataLifecycle = {value: false};
    const wqosUpdated = qos.getQoSObjectAndDeleteHandle(wqos.asCQos());
    const jsobj = wqosUpdated.writerDataLifecycle;
    expect(jsobj.autodisposeUnregisteredInstances).to
      .equal(defaultPolicy.autodisposeUnregisteredInstances);
    wqos.delete();
  });

  it('set writer data lifecycle callback throws error for invalid input type',
    function() {
      const wqos = qos.QoS.writerDefault();
      expect(function() {
        wqos.writerDataLifecycle = {autodisposeUnregisteredInstances: -99};
      }).to.throw(TypeError);
      wqos.delete();
    });

  it('set reader data lifecycle qos policy', function() {
    let rqos = qos.QoS.readerDefault();
    rqos.readerDataLifecycle = {
      autopurgeNoWriterSamples: 100,
      autopurgeDisposedSamplesDelay: 500,
    };
    const rqosUpdated = qos.getQoSObjectAndDeleteHandle(rqos.asCQos());
    let jsobj = rqosUpdated.readerDataLifecycle;
    expect(jsobj.autopurgeNoWriterSamples).to.equal(100);
    expect(jsobj.autopurgeDisposedSamplesDelay).to.equal(500);
    rqos.delete();
  });

  it('set autopurgeDisposedSamplesDelay to a string', function() {
    const rqos = qos.QoS.readerDefault();
    rqos.readerDataLifecycle = {
      autopurgeDisposedSamplesDelay: '500',
    };
    const rqosUpdated = qos.getQoSObjectAndDeleteHandle(rqos.asCQos());
    const jsobj = rqosUpdated.readerDataLifecycle;
    expect(jsobj.autopurgeDisposedSamplesDelay).to.equal(500);
    rqos.delete();
  });

  it('set autopurgeDisposedSamplesDelay to infinity', function() {
    const rqos = qos.QoS.readerDefault();
    rqos.readerDataLifecycle = {
      autopurgeDisposedSamplesDelay: dcps.DDSConstants.DDS_INFINITY,
    };
    const rqosUpdated = qos.getQoSObjectAndDeleteHandle(rqos.asCQos());
    const jsobj = rqosUpdated.readerDataLifecycle;
    expect(jsobj.autopurgeDisposedSamplesDelay).to.equal('9223372036854775807');
    rqos.delete();
  });

  it('set reader data lifecycle qos policy autopurgeNoWriterSamples only',
    function() {
      let rqos = qos.QoS.readerDefault();
      let defaultPolicy = rqos.readerDataLifecycle;
      rqos.readerDataLifecycle = {autopurgeNoWriterSamples: 300};
      const rqosUpdated = qos.getQoSObjectAndDeleteHandle(rqos.asCQos());
      let jsobj = rqosUpdated.readerDataLifecycle;
      expect(jsobj.autopurgeNoWriterSamples).to.equal(300);
      expect(jsobj.autopurgeDisposedSamplesDelay).to
        .equal(defaultPolicy.autopurgeDisposedSamplesDelay);
      rqos.delete();
    });

  it('set reader data lifecycle qos policy ignores inapplicable values',
    function() {
      const rqos = qos.QoS.readerDefault();
      rqos.readerDataLifecycle = {
        autopurgeNoWriterSamples: 500,
        extraField: 1,
      };
      const rqosUpdated = qos.getQoSObjectAndDeleteHandle(rqos.asCQos());
      const jsobj = rqosUpdated.readerDataLifecycle;
      expect(jsobj.autopurgeNoWriterSamples).to.equal(500);
      expect(jsobj.extraField).to.be.undefined;
      rqos.delete();
    });

  it('set reader data lifecycle qos policy uses default values for empty input',
    function() {
      let rqos = qos.QoS.readerDefault();
      let defaultPolicy = rqos.readerDataLifecycle;
      rqos.readerDataLifecycle = {};
      const rqosUpdated = qos.getQoSObjectAndDeleteHandle(rqos.asCQos());
      let jsobj = rqosUpdated.readerDataLifecycle;
      expect(jsobj.autopurgeNoWriterSamples).to
        .equal(defaultPolicy.autopurgeNoWriterSamples);
      expect(jsobj.autopurgeDisposedSamplesDelay).to
        .equal(defaultPolicy.autopurgeDisposedSamplesDelay);
      rqos.delete();
    });

  it('set durability service qos policy', function() {
    let tqos = qos.QoS.topicDefault();
    tqos.durabilityService = {
      serviceCleanupDelay: 5000,
      historyKind: qos.HistoryKind.KeepLast,
      historyDepth: 10,
      maxSamples: 10,
      maxInstances: 5,
      maxSamplesPerInstance: 2,
    };
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    let jsobj = tqosUpdated.durabilityService;
    expect(jsobj.serviceCleanupDelay).to.equal(5000);
    expect(jsobj.historyKind).to.equal(qos.HistoryKind.KeepLast);
    expect(jsobj.historyDepth).to.equal(10);
    expect(jsobj.maxSamples).to.equal(10);
    expect(jsobj.maxInstances).to.equal(5);
    expect(jsobj.maxSamplesPerInstance).to.equal(2);
    tqos.delete();
  });

  it('set serviceCleanupDelay to a string', function() {
    const tqos = qos.QoS.topicDefault();
    tqos.durabilityService = {
      serviceCleanupDelay: '5000',
    };
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    const jsobj = tqosUpdated.durabilityService;
    expect(jsobj.serviceCleanupDelay).to.equal(5000);
    tqos.delete();
  });

  it('set serviceCleanupDelay to infinity', function() {
    const tqos = qos.QoS.topicDefault();
    tqos.durabilityService = {
      serviceCleanupDelay: dcps.DDSConstants.DDS_INFINITY,
    };
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    const jsobj = tqosUpdated.durabilityService;
    expect(jsobj.serviceCleanupDelay).to.equal('9223372036854775807');
    tqos.delete();
  });

  it('set durability service policy historyKind only', function() {
    let tqos = qos.QoS.topicDefault();
    let defaultPolicy = tqos.durabilityService;
    tqos.durabilityService = { historyKind: qos.HistoryKind.KeepAll };
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    let jsobj = tqosUpdated.durabilityService;
    expect(jsobj.serviceCleanupDelay).to.equal(
      defaultPolicy.serviceCleanupDelay
    );
    expect(jsobj.historyKind).to.equal(qos.HistoryKind.KeepAll);
    expect(jsobj.historyDepth).to.equal(defaultPolicy.historyDepth);
    expect(jsobj.maxSamples).to.equal(defaultPolicy.maxSamples);
    expect(jsobj.maxInstances).to.equal(defaultPolicy.maxInstances);
    expect(jsobj.maxSamplesPerInstance).to.equal(
      defaultPolicy.maxSamplesPerInstance);
    tqos.delete();
  });

  it('set durability service policy ignores inapplicable values', function() {
    const tqos = qos.QoS.topicDefault();
    tqos.durabilityService = {
      historyKind: qos.HistoryKind.KeepAll,
      extraField: 1,
    };
    const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
    const jsobj = tqosUpdated.durabilityService;
    expect(jsobj.historyKind).to.equal(qos.HistoryKind.KeepAll);
    expect(jsobj.extraField).to.be.undefined;
    tqos.delete();
  });

  it('set durability service policy uses default values for empty input',
    function() {
      let tqos = qos.QoS.topicDefault();
      let defaultPolicy = tqos.durabilityService;
      tqos.durabilityService = {};
      const tqosUpdated = qos.getQoSObjectAndDeleteHandle(tqos.asCQos());
      let jsobj = tqosUpdated.durabilityService;
      expect(jsobj.serviceCleanupDelay).to.equal(
        defaultPolicy.serviceCleanupDelay
      );
      expect(jsobj.historyKind).to.equal(defaultPolicy.historyKind);
      expect(jsobj.historyDepth).to.equal(defaultPolicy.historyDepth);
      expect(jsobj.maxSamples).to.equal(defaultPolicy.maxSamples);
      expect(jsobj.maxInstances).to.equal(defaultPolicy.maxInstances);
      expect(jsobj.maxSamplesPerInstance).to.equal(
        defaultPolicy.maxSamplesPerInstance);
      tqos.delete();
    });

});
