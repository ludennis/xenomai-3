/*
 *                         Vortex OpenSplice
 *
 *   This software and documentation are Copyright 2006 to 2019 ADLINK
 *   Technology Limited, its affiliated companies and licensors. All rights
 *   reserved.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

'use strict';


const qc99 = require('./qosc99');
const path = require('path');
const check = require('check-types');
const clone = require('clone');
const ddserr = require('./ddserr');


/**
 * The built-in Node JS Buffer class
 * @external Buffer
 * @see https://nodejs.org/api/buffer.html
 *
 * @alias external:Buffer
 */

/**
 * Defines identifiers for each available QoS policy.
 * Returned by DDS status objects.
 * @readonly
 * @enum {number}
 * @alias module:vortexdds.QosPolicyID
 */
const QosPolicyID = {
  /**
   * Invalid QoS policy
   */
  INVALID: 0,
  /**
   * A {@link module:vortexdds.QoS#userdata|QoS.userdata} policy.
   */
  USERDATA: 1,
  /**
   * A {@link module:vortexdds.QoS#durability|QoS.durability} policy.
   */
  DURABILITY: 2,
  /**
   * A {@link module:vortexdds.QoS#presentation|QoS.presentation} policy.
   */
  PRESENTATION: 3,
  /**
   * A {@link module:vortexdds.QoS#deadline|QoS.deadline} policy.
   */
  DEADLINE: 4,
  /**
   * A {@link module:vortexdds.QoS#latencyBudget|QoS.latencyBudget} policy.
   */
  LATENCYBUDGET: 5,
  /**
   * A {@link module:vortexdds.QoS#ownership|QoS.ownership} policy.
   */
  OWNERSHIP: 6,
  /**
   * A {@link module:vortexdds.QoS#ownershipStrength|
   * QoS.ownershipStrength} policy.
   */
  OWNERSHIPSTRENGTH: 7,
  /**
   * A {@link module:vortexdds.QoS#liveliness|QoS.liveliness} policy.
   */
  LIVELINESS: 8,
  /**
   * A {@link module:vortexdds.QoS#timebasedFilter|QoS.timebasedFilter} policy.
   */
  TIMEBASEDFILTER: 9,
  /**
   * A {@link module:vortexdds.QoS#partition|QoS.partition} policy.
   */
  PARTITION: 10,
  /**
   * A {@link module:vortexdds.QoS#reliability|QoS.reliability} policy.
   */
  RELIABILITY: 11,
  /**
   * A {@link module:vortexdds.QoS#destinationOrder|
   * QoS.destinationOrder} policy.
   */
  DESTINATIONORDER: 12,
  /**
   * A {@link module:vortexdds.QoS#history|QoS.history} policy.
   */
  HISTORY: 13,
  /**
   * A {@link module:vortexdds.QoS#resourceLimits|QoS.resourceLimits} policy.
   */
  RESOURCELIMITS: 14,
  /**
   * An entityFactory policy. Not supported by this API
   */
  ENTITYFACTORY: 15,
  /**
   * A {@link module:vortexdds.QoS#writerDataLifecycle|
   * QoS.writerDataLifecycle} policy.
   */
  WRITERDATALIFECYCLE: 16,
  /**
   * A {@link module:vortexdds.QoS#readerDataLifecycle|
   * QoS.readerDataLifecycle} policy.
   */
  READERDATALIFECYCLE: 17,
  /**
   * A {@link module:vortexdds.QoS#topicdata|QoS.topicdata} policy.
   */
  TOPICDATA: 18,
  /**
  * A {@link module:vortexdds.QoS#groupdata|QoS.groupdata} policy.
  */
  GROUPDATA: 19,
  /**
   * A {@link module:vortexdds.QoS#transportPriority|
   * QoS.transportPriority} policy.
   */
  TRANSPORTPRIORITY: 20,
  /**
   * A {@link module:vortexdds.QoS#lifespan|QoS.lifespan} policy.
   */
  LIFESPAN: 21,
  /**
   * A {@link module:vortexdds.QoS#durabilityService|
   * QoS.durabilityService} policy.
   */
  DURABILITYSERVICE: 22,
};

/**
 * Regular expression to validate hexadecimal/decimal number
 * @ignore
 */
const HEX_OR_DEC_REGEX = /\b(0x[0-9a-fA-F]+|[0-9]+)\b/;

/**
 * Create a QoS object. Copy all the qos policies
 * from the given c99Qos handle to the QoS object and
 * delete the c99Qos handle.
 *
 * @param {object} c99Qos
 * @returns {module:vortexdds.QoS}
 * @ignore
 */
function getQoSObjectAndDeleteHandle(c99Qos) {
  const qos = new QoS();
  copyPoliciesFromC99(c99Qos, qos);
  qc99.qosDelete(c99Qos);
  return qos;
}

function copyPoliciesFromC99(c99Qos, qos) {
  qos._userdata = getUserdataFromC99(c99Qos);
  qos._topicdata = getTopicdataFromC99(c99Qos);
  qos._groupdata = getGroupdataFromC99(c99Qos);
  qos._durability = getDurabilityFromC99(c99Qos);
  qos._history = getHistoryFromC99(c99Qos);
  qos._resourceLimits = getResourceLimitsFromC99(c99Qos);
  qos._presentation = getPresentationFromC99(c99Qos);
  qos._lifespan = getLifespanFromC99(c99Qos);
  qos._deadline = getDeadlineFromC99(c99Qos);
  qos._latencyBudget = getLatencyBudgetFromC99(c99Qos);
  qos._ownership = getOwnershipFromC99(c99Qos);
  qos._ownershipStrength = getOwnershipStrengthFromC99(c99Qos);
  qos._liveliness = getLivelinessFromC99(c99Qos);
  qos._timebasedFilter = getTimebasedFilterFromC99(c99Qos);
  qos._partition = getPartitionFromC99(c99Qos);
  qos._reliability = getReliabilityFromC99(c99Qos);
  qos._transportPriority = getTransportPriorityFromC99(c99Qos);
  qos._destinationOrder = getDestinationOrderFromC99(c99Qos);
  qos._writerDataLifecycle = getWriterDataLifecycleFromC99(c99Qos);
  qos._readerDataLifecycle = getReaderDataLifecycleFromC99(c99Qos);
  qos._durabilityService = getDurabilityServiceFromC99(c99Qos);
}

function getUserdataFromC99(c99Qos) {
  return {
    value: qc99.getUserdata(c99Qos),
  };
}

function getTopicdataFromC99(c99Qos) {
  return {
    value: qc99.getTopicdata(c99Qos),
  };
}

function getGroupdataFromC99(c99Qos) {
  return {
    value: qc99.getGroupdata(c99Qos),
  };
}

function getDurabilityFromC99(c99Qos) {
  return {
    kind: qc99.getDurability(c99Qos),
  };
}

function getHistoryFromC99(c99Qos) {
  return qc99.getHistory(c99Qos);
}

function getResourceLimitsFromC99(c99Qos) {
  return qc99.getResourceLimits(c99Qos);
}

function getPresentationFromC99(c99Qos) {
  return qc99.getPresentation(c99Qos);
}

function getLifespanFromC99(c99Qos) {
  return {
    lifespan: qc99.getLifespan(c99Qos),
  };
}

function getDeadlineFromC99(c99Qos) {
  return {
    deadline: qc99.getDeadline(c99Qos),
  };
}

function getLatencyBudgetFromC99(c99Qos) {
  return {
    duration: qc99.getLatencyBudget(c99Qos),
  };
}

function getOwnershipFromC99(c99Qos) {
  return {
    kind: qc99.getOwnership(c99Qos),
  };
}

function getOwnershipStrengthFromC99(c99Qos) {
  return {
    value: qc99.getOwnershipStrength(c99Qos),
  };
}

function getLivelinessFromC99(c99Qos) {
  return qc99.getLiveliness(c99Qos);
}

function getTimebasedFilterFromC99(c99Qos) {
  return {
    minimumSeparation: qc99.getTimebasedFilter(c99Qos),
  };
}

function getPartitionFromC99(c99Qos) {
  return {
    names: qc99.getPartition(c99Qos),
  };
}

function getReliabilityFromC99(c99Qos) {
  return qc99.getReliability(c99Qos);
}

function getTransportPriorityFromC99(c99Qos) {
  return {
    value: qc99.getTransportPriority(c99Qos),
  };
}

function getDestinationOrderFromC99(c99Qos) {
  return {
    kind: qc99.getDestinationOrder(c99Qos),
  };
}

function getWriterDataLifecycleFromC99(c99Qos) {
  return {
    autodisposeUnregisteredInstances: qc99.getWriterDataLifecycle(
      c99Qos
    ),
  };
}

function getReaderDataLifecycleFromC99(c99Qos) {
  return qc99.getReaderDataLifecycle(c99Qos);
}

function getDurabilityServiceFromC99(c99Qos) {
  return qc99.getDurabilityService(c99Qos);
}

function copyPoliciesToC99(qos, c99Qos) {
  copyUserdataToC99(qos, c99Qos);
  copyTopicdataToC99(qos, c99Qos);
  copyGroupdataToC99(qos, c99Qos);
  copyDurabilityToC99(qos, c99Qos);
  copyHistoryToC99(qos, c99Qos);
  copyResourceLimitsToC99(qos, c99Qos);
  copyPresentationToC99(qos, c99Qos);
  copyLifespanToC99(qos, c99Qos);
  copyDeadlineToC99(qos, c99Qos);
  copyLatencyBudgetToC99(qos, c99Qos);
  copyOwnershipToC99(qos, c99Qos);
  copyOwnershipStrengthToC99(qos, c99Qos);
  copyLivelinessToC99(qos, c99Qos);
  copyTimebasedFilterToC99(qos, c99Qos);
  copyPartitionToC99(qos, c99Qos);
  copyReliabilityToC99(qos, c99Qos);
  copyTransportPriorityToC99(qos, c99Qos);
  copyDestinationOrderToC99(qos, c99Qos);
  copyWriterDataLifecycleToC99(qos, c99Qos);
  copyReaderDataLifecycleToC99(qos, c99Qos);
  copyDurabilityServiceToC99(qos, c99Qos);
}

function copyUserdataToC99(qos, c99Qos) {
  qc99.setUserdata(c99Qos, qos._userdata.value);
}

function copyTopicdataToC99(qos, c99Qos) {
  qc99.setTopicdata(c99Qos, qos._topicdata.value);
}

function copyGroupdataToC99(qos, c99Qos) {
  qc99.setGroupdata(c99Qos, qos._groupdata.value);
}

function copyDurabilityToC99(qos, c99Qos) {
  qc99.setDurability(c99Qos, qos._durability.kind);
}

function copyHistoryToC99(qos, c99Qos) {
  qc99.setHistory(
    c99Qos,
    qos._history.kind,
    qos._history.depth
  );
}

function copyResourceLimitsToC99(qos, c99Qos) {
  qc99.setResourceLimits(
    c99Qos,
    qos._resourceLimits.maxSamples,
    qos._resourceLimits.maxInstances,
    qos._resourceLimits.maxSamplesPerInstance
  );
}

function copyPresentationToC99(qos, c99Qos) {
  qc99.setPresentation(
    c99Qos,
    qos._presentation.accessScope,
    qos._presentation.coherentAccess,
    qos._presentation.orderedAccess
  );
}

function copyLifespanToC99(qos, c99Qos) {
  qc99.setLifespan(c99Qos, qos._lifespan.lifespan);
}

function copyDeadlineToC99(qos, c99Qos) {
  qc99.setDeadline(c99Qos, qos._deadline.deadline);
}

function copyLatencyBudgetToC99(qos, c99Qos) {
  qc99.setLatencyBudget(c99Qos, qos._latencyBudget.duration);
}

function copyOwnershipToC99(qos, c99Qos) {
  qc99.setOwnership(c99Qos, qos._ownership.kind);
}

function copyOwnershipStrengthToC99(qos, c99Qos) {
  qc99.setOwnershipStrength(c99Qos, qos._ownershipStrength.value);
}

function copyLivelinessToC99(qos, c99Qos) {
  qc99.setLiveliness(
    c99Qos,
    qos._liveliness.kind,
    qos._liveliness.leaseDuration
  );
}

function copyTimebasedFilterToC99(qos, c99Qos) {
  qc99.setTimebasedFilter(
    c99Qos,
    qos._timebasedFilter.minimumSeparation
  );
}

function copyPartitionToC99(qos, c99Qos) {
  qc99.setPartition(c99Qos, qos._partition.names);
}

function copyReliabilityToC99(qos, c99Qos) {
  qc99.setReliability(
    c99Qos,
    qos._reliability.kind,
    qos._reliability.maxBlockingTime
  );
}

function copyTransportPriorityToC99(qos, c99Qos) {
  qc99.setTransportPriority(c99Qos, qos._transportPriority.value);
}

function copyDestinationOrderToC99(qos, c99Qos) {
  qc99.setDestinationOrder(
    c99Qos,
    qos._destinationOrder.kind
  );
}

function copyWriterDataLifecycleToC99(qos, c99Qos) {
  qc99.setWriterDataLifecycle(
    c99Qos,
    qos._writerDataLifecycle.autodisposeUnregisteredInstances
  );
}

function copyReaderDataLifecycleToC99(qos, c99Qos) {
  qc99.setReaderDataLifecycle(
    c99Qos,
    qos._readerDataLifecycle.autopurgeNoWriterSamples,
    qos._readerDataLifecycle.autopurgeDisposedSamplesDelay
  );
}

function copyDurabilityServiceToC99(qos, c99Qos) {
  qc99.setDurabilityService(
    c99Qos,
    qos._durabilityService.serviceCleanupDelay,
    qos._durabilityService.historyKind,
    qos._durabilityService.historyDepth,
    qos._durabilityService.maxSamples,
    qos._durabilityService.maxInstances,
    qos._durabilityService.maxSamplesPerInstance
  );
}

function copyPoliciesToQoSObject(qos, policies) {
  // Each qos policies are setters and do appropriate deep copying
  // before setting each policies
  qos.userdata = policies.userdata;
  qos.topicdata = policies.topicdata;
  qos.groupdata = policies.groupdata;
  qos.durability = policies.durability;
  qos.history = policies.history;
  qos.resourceLimits = policies.resourceLimits;
  qos.presentation = policies.presentation;
  qos.lifespan = policies.lifespan;
  qos.deadline = policies.deadline;
  qos.latencyBudget = policies.latencyBudget;
  qos.ownership = policies.ownership;
  qos.ownershipStrength = policies.ownershipStrength;
  qos.liveliness = policies.liveliness;
  qos.timebasedFilter = policies.timebasedFilter;
  qos.partition = policies.partition;
  qos.reliability = policies.reliability;
  qos.transportPriority = policies.transportPriority;
  qos.destinationOrder = policies.destinationOrder;
  qos.writerDataLifecycle = policies.writerDataLifecycle;
  qos.readerDataLifecycle = policies.readerDataLifecycle;
  qos.durabilityService = policies.durabilityService;
}

const _c99Qos = qc99.qosCreate();
qc99.qosReset(_c99Qos);
const defaultQoSPolicies = {
  userdata: getUserdataFromC99(_c99Qos),
  topicdata: getTopicdataFromC99(_c99Qos),
  groupdata: getGroupdataFromC99(_c99Qos),
  durability: getDurabilityFromC99(_c99Qos),
  history: getHistoryFromC99(_c99Qos),
  resourceLimits: getResourceLimitsFromC99(_c99Qos),
  presentation: getPresentationFromC99(_c99Qos),
  lifespan: getLifespanFromC99(_c99Qos),
  deadline: getDeadlineFromC99(_c99Qos),
  latencyBudget: getLatencyBudgetFromC99(_c99Qos),
  ownership: getOwnershipFromC99(_c99Qos),
  ownershipStrength: getOwnershipStrengthFromC99(_c99Qos),
  liveliness: getLivelinessFromC99(_c99Qos),
  timebasedFilter: getTimebasedFilterFromC99(_c99Qos),
  partition: getPartitionFromC99(_c99Qos),
  reliability: getReliabilityFromC99(_c99Qos),
  transportPriority: getTransportPriorityFromC99(_c99Qos),
  destinationOrder: getDestinationOrderFromC99(_c99Qos),
  writerDataLifecycle: getWriterDataLifecycleFromC99(_c99Qos),
  readerDataLifecycle: getReaderDataLifecycleFromC99(_c99Qos),
  durabilityService: getDurabilityServiceFromC99(_c99Qos),
};
qc99.qosDelete(_c99Qos);

function deepClone(obj) {
  return clone(obj);
}

/**
 * Quality of service (QoS) policy container
 *
 * Twenty-one (21) QoS policies are defined, although
 * most policies apply to only a subset of the DDS
 * entity types. Policies that do not apply to a
 * particular entity are ignored. The documentation
 * for each property specifies the applicable entities.
 *
 * The available QoS policies are:
 * {@link module:vortexdds.QoS#userdata|userdata},
 * {@link module:vortexdds.QoS#topicdata|topicdata},
 * {@link module:vortexdds.QoS#groupdata|groupdata},
 * {@link module:vortexdds.QoS#durability|durability},
 * {@link module:vortexdds.QoS#durabilityService|durabilityService},
 * {@link module:vortexdds.QoS#presentation|presentation},
 * {@link module:vortexdds.QoS#deadline|deadline},
 * {@link module:vortexdds.QoS#latencyBudget|latencyBudget},
 * {@link module:vortexdds.QoS#ownership|ownership},
 * {@link module:vortexdds.QoS#ownershipStrength|ownershipStrength},
 * {@link module:vortexdds.QoS#liveliness|liveliness},
 * {@link module:vortexdds.QoS#timebasedFilter|timebasedFilter},
 * {@link module:vortexdds.QoS#partition|partition},
 * {@link module:vortexdds.QoS#reliability|reliability},
 * {@link module:vortexdds.QoS#transportPriority|transportPriority},
 * {@link module:vortexdds.QoS#lifespan|lifespan},
 * {@link module:vortexdds.QoS#destinationOrder|destinationOrder},
 * {@link module:vortexdds.QoS#history|history},
 * {@link module:vortexdds.QoS#resourceLimits|resourceLimits},
 * {@link module:vortexdds.QoS#writerDataLifecycle|writerDataLifecycle}
 * and
 * {@link module:vortexdds.QoS#readerDataLifecycle|readerDataLifecycle}.
 *
 * @alias module:vortexdds.QoS
*/
class QoS {
  /**
   * Create a QoS object.
   *
   * While creating a QoS object, all the QoS policies
   * are initialized to the default QoS policies except
   * for the policies that are provided and set accordingly.
   *
   * Note that you should consider using one of the
   * following factory functions to create defaults
   * appropriate for the type of DDS entity you will
   * be creating:
   * - {@link module:vortexdds.QoS.participantDefault|
   * QoS.participantDefault()}
   * - {@link module:vortexdds.QoS.topicDefault|
   * QoS.topicDefault()}
   * - {@link module:vortexdds.QoS.publisherDefault|
   * QoS.publisherDefault()}
   * - {@link module:vortexdds.QoS.subscriberDefault|
   * QoS.subscriberDefault()}
   * - {@link module:vortexdds.QoS.readerDefault|
   * QoS.readerDefault()}
   * - {@link module:vortexdds.QoS.writerDefault|
   * QoS.writerDefault()}
   *
   * These functions return an initialized QoS object
   * that differs from a constructed QoS object with no parameter.
   *
   * @param {module:vortexdds~QosPolicies} [policies] an object
   * defining QoS policies
   *
   * @example
   * const dds = require('vortexdds');
   * const qos = new dds.QoS({
   *   durability: { kind: qos.DurabilityKind.Persistent },
   *  });
   */
  constructor(policies = null) {
    let initialPolicies = deepClone(defaultQoSPolicies);

    /**
     * All the policies in the QoS object are initialized to the deep copied
     * defaultQoSPolicies. This is because setter methods are used later in this
     * constructor for copying user given policies to the QoS object policies
     * and the setters do not work properly if all the policies in the QoS
     * object are not initialized.
     * @ignore
     */
    this._userdata = initialPolicies.userdata;
    this._topicdata = initialPolicies.topicdata;
    this._groupdata = initialPolicies.groupdata;
    this._durability = initialPolicies.durability;
    this._history = initialPolicies.history;
    this._resourceLimits = initialPolicies.resourceLimits;
    this._presentation = initialPolicies.presentation;
    this._lifespan = initialPolicies.lifespan;
    this._deadline = initialPolicies.deadline;
    this._latencyBudget = initialPolicies.latencyBudget;
    this._ownership = initialPolicies.ownership;
    this._ownershipStrength = initialPolicies.ownershipStrength;
    this._liveliness = initialPolicies.liveliness;
    this._timebasedFilter = initialPolicies.timebasedFilter;
    this._partition = initialPolicies.partition;
    this._reliability = initialPolicies.reliability;
    this._transportPriority = initialPolicies.transportPriority;
    this._destinationOrder = initialPolicies.destinationOrder;
    this._writerDataLifecycle = initialPolicies.writerDataLifecycle;
    this._readerDataLifecycle = initialPolicies.readerDataLifecycle;
    this._durabilityService = initialPolicies.durabilityService;

    if (policies !== null) {
      copyPoliciesToQoSObject(
        this,
        Object.assign(deepClone(defaultQoSPolicies), policies)
      );
    }
  }

  /**
   * Create a C99 qos handle. Copy all the policies from this
   * QoS object to the C99 qos handle by calling all the C99 qos policy
   * setter methods. Return the C99 qos handle.
   *
   * Note that C99 qos handle created by this method
   * consume DDS memory that is not automatically
   * reclaimed by Node JS. Once you are finished
   * with a C99 qos handle, you must explicitly call
   * 'qc99.qosDelete(C99Qos_handle)'
   * to reclaim these memory resources.
   *
   * @returns {object}
   * @ignore
   */
  asCQos() {
    const c99Qos = qc99.qosCreate();
    copyPoliciesToC99(this, c99Qos);
    return c99Qos;
  }

  /**
   * This function does nothing. Previously it
   * released the DDS memory associated with
   * this QoS object. This class no longer retains
   * any DDS resources.
   *
   * @example
   * // release QoS resources after usage
   * const qos = QoS.subscriberDefault();
   * qos.partition = {name: ['foo','bar']};
   * const sub = dp.createSubscriber(qos);
   * qos.delete(); // finished with QoS object
   *
   */
  delete() {
    // Does nothing. Doesn't change the API.
  }

  /**
   * Create a default QoS object suitable for
   * creating
   * {@link module:vortexdds.Participant|Participant}
   * entities.
   *
   * @returns {module:vortexdds.QoS}
   */
  static participantDefault(){
    const cqos = qc99.qosCreate();
    qc99.defaultParticipantQos(cqos);
    const qos = getQoSObjectAndDeleteHandle(cqos);
    return qos;
  }

  /**
   * Create a default QoS object suitable for
   * creating
   * {@link module:vortexdds.Topic|Topic}
   * entities.
   *
   * @returns {module:vortexdds.QoS}
   */
  static topicDefault(){
    const cqos = qc99.qosCreate();
    qc99.defaultTopicQos(cqos);
    const qos = getQoSObjectAndDeleteHandle(cqos);
    return qos;
  }

  /**
   * Create a default QoS object suitable for
   * creating
   * {@link module:vortexdds.Subscriber|Subscriber}
   * entities.
   *
   * @returns {module:vortexdds.QoS}
   */
  static subscriberDefault(){
    const cqos = qc99.qosCreate();
    qc99.defaultSubscriberQos(cqos);
    const qos = getQoSObjectAndDeleteHandle(cqos);
    return qos;
  }

  /**
   * Create a default QoS object suitable for
   * creating
   * {@link module:vortexdds.Reader|Reader}
   * entities.
   *
   * @returns {module:vortexdds.QoS}
   */
  static readerDefault(){
    const cqos = qc99.qosCreate();
    qc99.defaultReaderQos(cqos);
    const qos = getQoSObjectAndDeleteHandle(cqos);
    return qos;
  }

  /**
   * Create a default QoS object suitable for
   * creating
   * {@link module:vortexdds.Publisher|Publisher}
   * entities.
   *
   * @returns {module:vortexdds.QoS}
   */
  static publisherDefault(){
    const cqos = qc99.qosCreate();
    qc99.defaultPublisherQos(cqos);
    const qos = getQoSObjectAndDeleteHandle(cqos);
    return qos;
  }

  /**
   * Create a default QoS object suitable for
   * creating
   * {@link module:vortexdds.Writer|Writer}
   * entities.
   *
   * @returns {module:vortexdds.QoS}
   */
  static writerDefault(){
    const cqos = qc99.qosCreate();
    qc99.defaultWriterQos(cqos);
    const qos = getQoSObjectAndDeleteHandle(cqos);
    return qos;
  }

  /* See set variable for JSDOC documentation
   */
  get userdata() {
    const buf = deepClone(this._userdata).value;

    return {
      value: buf === null ? '' : buf.toString('binary'),
    };
  }

  /**
   * The user data policy, uninterpreted
   *
   * Applies to: Participant, Reader, Writer
   *
   * @type {module:vortexdds.DataPolicy}
   */
  get userdataRaw() {
    return deepClone(this._userdata);
  }

  /**
   * The user data policy.
   *
   * Applies to: Participant, Reader, Writer
   *
   * When setting this policy, the *value* field
   * of the passed
   * {@link module:vortexdds~DataPolicy|
   * DataPolicy} may be one of:
   * - a {@link external:Buffer|Buffer}
   * - a string
   *
   * If *value* is a string, it will be converted
   * to a Buffer using the ISO-8859-1 encoding.
   *
   * When retrieving the policy, the *value* field
   * will be returned as a 'string' which has
   * been ISO-8859-1 decoded from the raw binary
   * data physically stored by DDS.
   *
   * To directly retrieve the raw binary data
   * stored by DDS, use the
   * {@link module:vortexdds.QoS#userdataRaw|userdataRaw}
   * data.
   *
   * @type {module:vortexdds~DataPolicy}
   */
  set userdata(jsobj) {
    check.assert(
      check.any(
        [
          check.instance(jsobj.value, Buffer),
          check.string(jsobj.value),
          check.not.assigned(jsobj.value),
        ]
      ),
      ddserr.typeCheckMsgs.STR_OR_BUF_MSG,
      TypeError
    );

    const updatedPolicy = Object.assign(this._userdata, jsobj);
    const buf = updatedPolicy.value;

    this._userdata.value =
      (typeof buf === 'string') ? Buffer.from(buf, 'binary') :
        buf === null ? Buffer.alloc(0) :
          buf;
  }

  /*
   * See setter for JSDOC documentation
   */
  get topicdata() {
    const buf = deepClone(this._topicdata).value;

    return {
      value: buf === null ? '' : buf.toString('binary'),
    };
  }

  /**
   * The topic data policy, uninterpreted
   *
   * Applies to: Topic
   *
   * @type {module:vortexdds~DataPolicy}
   */
  get topicdataRaw() {
    return deepClone(this._topicdata);
  }

  /**
   * The topic data policy.
   *
   * Applies to: Topic

   * When setting this policy, the *value* field
   * of the passed
   * {@link module:vortexdds~DataPolicy|
   * DataPolicy} may be one of:
   * - a {@link external:Buffer|Buffer}
   * - a string
   *
   * If *value* is a string, it will be converted
   * to a Buffer using the ISO-8859-1 encoding.
   *
   * When retrieving the policy, the *value* field
   * will be returned as a 'string' which has
   * been ISO-8859-1 decoded from the raw binary
   * data physically stored by DDS.
   *
   * To directly retrieve the raw binary data
   * stored by DDS, use the
   * {@link module:vortexdds.QoS#topicdataRaw|topicdataRaw}
   * property.
   *
   * @type {module:vortexdds~DataPolicy}
   */
  set topicdata(jsobj) {
    check.assert(
      check.any(
        [
          check.instance(jsobj.value, Buffer),
          check.string(jsobj.value),
          check.not.assigned(jsobj.value),
        ]
      ),
      ddserr.typeCheckMsgs.STR_OR_BUF_MSG,
      TypeError
    );

    const updatedPolicy = Object.assign(this._topicdata, jsobj);
    const buf = updatedPolicy.value;

    this._topicdata.value =
      (typeof buf === 'string') ? Buffer.from(buf, 'binary') :
        buf === null ? Buffer.alloc(0) :
          buf;
  }

  /*
   * See set method for JSDOC documentation.
   */
  get groupdata() {
    const buf = deepClone(this._groupdata).value;

    return {
      value: buf === null ? '' : buf.toString('binary'),
    };
  }

  /**
   * The group data policy, uninterpreted
   *
   * Applies to: Publisher, Subscriber
   * @type {module:vortexdds~DataPolicy}
   */
  get groupdataRaw() {
    return deepClone(this._groupdata);
  }

  /**
   * The group data policy.
   *
   * Applies to: Publisher, Subscriber
   *
   * When setting this policy, the *value* field
   * of the passed
   * {@link module:vortexdds~DataPolicy|
   * DataPolicy} may be one of:
   * - a {@link external:Buffer|Buffer}
   * - a string
   *
   * If *value* is a string, it will be converted
   * to a Buffer using the ISO-8859-1 encoding.
   *
   * When retrieving the policy, the *value* field
   * will be returned as a 'string' which has
   * been ISO-8859-1 decoded from the raw binary
   * data physically stored by DDS.
   *
   * To directly retrieve the raw binary data
   * stored by DDS, use the
   * {@link module:vortexdds.QoS#groupdataRaw|groupdataRaw}
   * data.
   *
   * @type {module:vortexdds~DataPolicy}
   */
  set groupdata(jsobj) {
    check.assert(
      check.any(
        [
          check.instance(jsobj.value, Buffer),
          check.string(jsobj.value),
          check.not.assigned(jsobj.value),
        ]
      ),
      ddserr.typeCheckMsgs.STR_OR_BUF_MSG,
      TypeError
    );

    const updatedPolicy = Object.assign(this._groupdata, jsobj);
    const buf = updatedPolicy.value;

    this._groupdata.value =
      (typeof buf === 'string') ? Buffer.from(buf, 'binary') :
        buf === null ? Buffer.alloc(0) :
          buf;
  }

  // Documentation for durability is written in the setter function
  get durability() {
    return deepClone(this._durability);
  }

  /**
   * The durability policy.
   *
   * Applies to: Reader, Writer, Topic
   *
   * @example
   * const dds = require('vortexdds');
   * const qos = dds.QoS.writerDefault();
   * qos.durability.kind = dds.DurabilityKind.Persistent;
   *
   * @type {module:vortexdds~DurabilityPolicy}
   */
  set durability(jsobj) {
    if (check.not.undefined(jsobj.kind)) {
      check.assert.number(jsobj.kind, ddserr.typeCheckMsgs.KIND_ERR_MSG);
    }

    this._durability = Object.assign(this._durability, jsobj);
  }


  // Documentation for history is written in the setter function
  get history() {
    return deepClone(this._history);
  }

  /**
   * The history policy.
   *
   * Applies to: Reader, Writer, Topic
   *
   * You only need to provide the fields that you want to change.
   *
   * @example
   * const dds = require('vortexdds');
   * const qos = dds.QoS.topicDefault();
   * qos.history = {
   *     kind: dds.HistoryKind.KeepLast,
   *     depth: 5
   * };
   *
   * @type {module:vortexdds~HistoryPolicy}
   */
  set history(jsobj) {
    if (check.not.undefined(jsobj.kind)) {
      check.assert.number(jsobj.kind, ddserr.typeCheckMsgs.KIND_ERR_MSG);
    }
    if (check.not.undefined(jsobj.depth)) {
      check.assert.number(
        jsobj.depth,
        ddserr.typeCheckMsgs.INVALID_ARG_MSG +
        'depth ' + ddserr.typeCheckMsgs.NUM_ERR_MSG
      );
    }

    this._history = Object.assign(this._history, jsobj);
  }


  // Documentation for resourceLimits is written in the setter function
  get resourceLimits() {
    return deepClone(this._resourceLimits);
  }

  /**
   * The resource limits policy.
   *
   * Applies to: Reader, Writer, Topic
   *
   * You only need to provide the fields that you want to change.
   *
   * @example
   * const dds = require('vortexdds');
   * const qos = dds.QoS.topicDefault();
   * qos.resourceLimits = {
   *     maxSamples: 100,
   *     maxInstances: 10,
   *     maxSamplesPerInstance: 10,
   * };
   *
   *
   * @type {module:vortexdds~ResourceLimitsPolicy}
   */
  set resourceLimits(jsobj) {
    if (check.not.undefined(jsobj.maxSamples)) {
      check.assert.number(
        jsobj.maxSamples,
        ddserr.typeCheckMsgs.INVALID_ARG_MSG +
        'maxSamples ' + ddserr.typeCheckMsgs.NUM_ERR_MSG
      );
    }
    if (check.not.undefined(jsobj.maxInstances)) {
      check.assert.number(
        jsobj.maxInstances,
        ddserr.typeCheckMsgs.INVALID_ARG_MSG +
        'maxInstances ' + ddserr.typeCheckMsgs.NUM_ERR_MSG
      );
    }
    if (check.not.undefined(jsobj.maxSamplesPerInstance)) {
      check.assert.number(
        jsobj.maxSamplesPerInstance,
        ddserr.typeCheckMsgs.INVALID_ARG_MSG +
        'maxSamplesPerInstance ' + ddserr.typeCheckMsgs.NUM_ERR_MSG
      );
    }

    this._resourceLimits = Object.assign(this._resourceLimits, jsobj);
  }

  // Documentation for presentation is written in the setter function
  get presentation() {
    return deepClone(this._presentation);
  }

  /**
   * The presentation policy.
   *
   * Applies to: Publisher, Subscriber
   *
   * You only need to provide the fields that you want to change.
   *
   * Note that the Node JS API for DDS only supports
   * the *Instance* access scope.
   *
   * @example
   * const dds = require('vortexdds');
   * const qos = dds.QoS.publisherDefault();
   * qos.presentation = {
   *  accessScope: dds.PresentationAccessScopeKind.Instance
   * };
   *
   * @type {module:vortexdds~PresentationPolicy}
   */
  set presentation(jsobj) {
    if (check.not.undefined(jsobj.accessScope)) {
      check.assert.number(
        jsobj.accessScope,
        ddserr.typeCheckMsgs.INVALID_ARG_MSG +
        'accessScope ' + ddserr.typeCheckMsgs.NUM_ERR_MSG
      );
    }
    if (check.not.undefined(jsobj.coherentAccess)) {
      check.assert.boolean(
        jsobj.coherentAccess,
        ddserr.typeCheckMsgs.INVALID_ARG_MSG +
        'coherentAccess ' + ddserr.typeCheckMsgs.BOOL_ERR_MSG
      );
    }
    if (check.not.undefined(jsobj.orderedAccess)) {
      check.assert.boolean(
        jsobj.orderedAccess,
        ddserr.typeCheckMsgs.INVALID_ARG_MSG +
        'orderedAccess ' + ddserr.typeCheckMsgs.BOOL_ERR_MSG
      );
    }

    this._presentation = Object.assign(this._presentation, jsobj);
  }

  // Documentation for lifespan is written in the setter function
  get lifespan() {
    return deepClone(this._lifespan);
  }

  /**
   * The lifespan policy.
   *
   * Applies to: Topic, Writer
   *
   * @example
   * const dds = require('vortexdds');
   * const qos = dds.QoS.topicDefault();
   * const SECS_TO_NS = 10 ^ 9;
   * qos.lifespan = { lifespan: 1 * SECS_TO_NS };
   *
   * @type {module:vortexdds~LifespanPolicy}
   */
  set lifespan(jsobj) {
    check.assert(
      check.any([
        check.number(jsobj.lifespan),
        check.match(jsobj.lifespan, HEX_OR_DEC_REGEX),
        check.not.assigned(jsobj.lifespan),
      ]),
      ddserr.typeCheckMsgs.DUR_ERR_MSG,
      TypeError
    );

    this._lifespan = Object.assign(this._lifespan, jsobj);
  }

  // Documentation for deadline is written in the setter function
  get deadline() {
    return deepClone(this._deadline);
  }

  /**
   * The deadline policy.
   *
   * Applies to: Topic, Reader, Writer
   *
   * @example
   * const dds = require('vortexdds');
   * const qos = dds.QoS.topicDefault();
   * const SEC_TO_NS = 10 ^ 9;
   * qos.deadline = { deadline: 10 * SECS_TO_NS};
   *
   * @type {module:vortexdds~DeadlinePolicy}
   */
  set deadline(jsobj) {
    check.assert(
      check.any([
        check.number(jsobj.deadline),
        check.match(jsobj.deadline, HEX_OR_DEC_REGEX),
        check.not.assigned(jsobj.deadline),
      ]),
      ddserr.typeCheckMsgs.DUR_ERR_MSG,
      TypeError
    );

    this._deadline = Object.assign(this._deadline, jsobj);
  }

  // Documentation for latencyBudget is written in the setter function
  get latencyBudget() {
    return deepClone(this._latencyBudget);
  }

  /**
   * The latency budget policy.
   *
   * Applies to: Topic, Reader, Writer
   *
   * @example
   * const dds = require('vortexdds');
   * const qos = dds.QoS.topicDefault();
   * const SEC_TO_NS = 10 ^ 9;
   * qos.latencyBudget = { duration: 5 * SEC_TO_NS };
   *
   * @type {module:vortexdds~LatencyBudgetPolicy}
   */
  set latencyBudget(jsobj) {

    check.assert(
      check.any([
        check.number(jsobj.duration),
        check.match(jsobj.duration, HEX_OR_DEC_REGEX),
        check.not.assigned(jsobj.duration),
      ]),
      ddserr.typeCheckMsgs.DUR_ERR_MSG,
      TypeError
    );

    this._latencyBudget = Object.assign(this._latencyBudget, jsobj);
  }

  // Documentation for ownership is written in the setter function
  get ownership() {
    return deepClone(this._ownership);
  }

  /**
   * The ownership policy.
   *
   * Applies to: Topic, Reader, Writer
   *
   * @example
   * const dds = require('vortexdds');
   * const qos = dds.QoS.topicDefault();
   * qos.ownership = {
   *     kind: dds.OwnershipKind.Exclusive
   * };
   *
   * @type {module:vortexdds~OwnershipPolicy}
   */
  set ownership(jsobj) {
    if (check.not.undefined(jsobj.kind)) {
      check.assert.number(jsobj.kind, ddserr.typeCheckMsgs.KIND_ERR_MSG);
    }

    this._ownership = Object.assign(this._ownership, jsobj);
  }

  // Documentation for ownershipStrength is written in the setter function
  get ownershipStrength() {
    return deepClone(this._ownershipStrength);
  }

  /**
   * The ownership strength policy.
   *
   * Applies to: Writer
   *
   * @example
   * const dds = require('vortexdds');
   * const qos = dds.QoS.writerDefault();
   * qos.ownership = {
   *     kind: dds.OwnershipKind.Exclusive
   * };
   * qos.ownershipStrength = {
   *     value: 100
   * };
   *
   * @type {module:vortexdds~OwnershipStrengthPolicy}
   */
  set ownershipStrength(jsobj) {
    if (check.not.undefined(jsobj.value)) {
      check.assert.number(
        jsobj.value,
        ddserr.typeCheckMsgs.INVALID_ARG_MSG +
        'value ' + ddserr.typeCheckMsgs.NUM_ERR_MSG
      );
    }

    this._ownershipStrength = Object.assign(this._ownershipStrength, jsobj);
  }

  // Documentation for liveliness is written in the setter function
  get liveliness() {
    return deepClone(this._liveliness);
  }

  /**
   * The liveliness policy.
   *
   * Applies to: Topic, Reader, Writer
   *
   * You only need to provide the fields that you want to change.
   *
   * @example
   * const dds = require('vortexdds');
   * const qos = dds.QoS.topicDefault();
   * const MS_TO_NS = 10 ^ 6;
   * qos.liveliness = {
   *     kind: dds.LivelinessKind.Automatic,
   *     leaseDuration: 100 * MS_to_NS
   * };
   *
   * @type {module:vortexdds~LivelinessPolicy}
   */
  set liveliness(jsobj) {
    if (check.not.undefined(jsobj.kind)) {
      check.assert.number(jsobj.kind, ddserr.typeCheckMsgs.KIND_ERR_MSG);
    }

    check.assert(
      check.any([
        check.number(jsobj.leaseDuration),
        check.match(jsobj.leaseDuration, HEX_OR_DEC_REGEX),
        check.not.assigned(jsobj.leaseDuration),
      ]),
      ddserr.typeCheckMsgs.DUR_ERR_MSG,
      TypeError
    );

    this._liveliness = Object.assign(this._liveliness, jsobj);
  }

  // Documentation for timebasedFilter is written in the setter function
  get timebasedFilter() {
    return deepClone(this._timebasedFilter);
  }

  /**
   * The time based filter policy.
   *
   * Applies to: Reader
   *
   * @example
   * const dds = require('vortexdds');
   * const qos = dds.QoS.readerDefault();
   * const MS_TO_NS = 10 ^ 6;
   * qos.timebasedFilter = {
   *     minimumSeparation: 100 * MS_TO_NS
   * };
   *
   * @type {module:vortexdds~TimebasedFilterPolicy}
   */
  set timebasedFilter(jsobj) {

    check.assert(
      check.any([
        check.number(jsobj.minimumSeparation),
        check.match(jsobj.minimumSeparation, HEX_OR_DEC_REGEX),
        check.not.assigned(jsobj.minimumSeparation),
      ]),
      ddserr.typeCheckMsgs.DUR_ERR_MSG,
      TypeError
    );

    this._timebasedFilter = Object.assign(this._timebasedFilter, jsobj);
  }

  // partition documentation is found on 'set' method
  get partition() {
    return deepClone(this._partition);
  }

  /**
   * The partition policy.
   *
   * Applies to: Publisher, Subscriber
   *
   * We retrieving the partition policy, the *names* field
   * of the returned
   * {@link module:vortexdds~PartitionPolicy|policy}
   * object is always an array of strings.
   *
   * We setting the partition policy, you may set the *names* field
   * of the returned
   * {@link module:vortexdds~PartitionPolicy|policy}
   * to be either a single string, or an array of strings.
   *
   * @example
   * // set a single partition
   * const dds = require('vortexdds');
   * const qos = dds.QoS.publisherDefault();
   * qos.partition = {names: 'mypartition'};
   * @example
   * // set multiplpe partitions
   * const dds = require('vortexdds');
   * const qos = dds.QoS.publisherDefault();
   * qos.partition = {names: [
   *   'mypartition1',
   *   'mypartition2'
   * ]};
   *
   * @type {module:vortexdds~PartitionPolicy}
   */
  set partition(jsobj) {
    check.assert(
      check.any(
        [
          check.array.of.string(jsobj.names),
          check.string(jsobj.names),
          check.undefined(jsobj.names),
        ]
      ),
      ddserr.typeCheckMsgs.STR_OR_ARR_OF_STR_MSG,
      TypeError
    );

    const updatedPolicy = Object.assign(this._partition, jsobj);
    const pnames = updatedPolicy.names;
    let partitionArray = [];

    if (pnames instanceof Array) {
      partitionArray = pnames;
    } else {
      partitionArray.push(pnames);
    }

    this._partition.names = partitionArray;
  }

  // Documentation for reliability is written in the setter function
  get reliability() {
    return deepClone(this._reliability);
  }

  /**
   * The reliability policy.
   *
   * Applies to: Topic, Reader, Writer
   *
   * You only need to provide the fields that you want to change.
   *
   * @example
   * const dds = require('vortexdds');
   * const qos = dds.QoS.topicDefault();
   * const MS_TO_NS = 10 ^ 6;
   * qos.reliability = {
   *     kind: dds.ReliabilityKind.Reliable,
   *     maxBlockingTime: 100 * MS_TO_NS
   * };
   *
   * @type {module:vortexdds~ReliabilityPolicy}
   */
  set reliability(jsobj) {
    if (check.not.undefined(jsobj.kind)) {
      check.assert.number(jsobj.kind, ddserr.typeCheckMsgs.KIND_ERR_MSG);
    }
    check.assert(
      check.any([
        check.number(jsobj.maxBlockingTime),
        check.match(jsobj.maxBlockingTime, HEX_OR_DEC_REGEX),
        check.not.assigned(jsobj.maxBlockingTime),
      ]),
      ddserr.typeCheckMsgs.DUR_ERR_MSG,
      TypeError
    );

    this._reliability = Object.assign(this._reliability, jsobj);
  }

  // Documentation for transportPriority is written in the setter function
  get transportPriority() {
    return deepClone(this._transportPriority);
  }

  /**
   * The transport priority policy.
   *
   * Applies to: Topic, Writer
   *
   * @example
   * const dds = require('vortexdds');
   * const qos = dds.QoS.topicDefault();
   * qos.transportPriority = {
   *     value: 100
   * };
   *
   * @type {module:vortexdds~TransportPriorityPolicy}
   */
  set transportPriority(jsobj) {
    if (check.not.undefined(jsobj.value)) {
      check.assert.number(
        jsobj.value,
        ddserr.typeCheckMsgs.INVALID_ARG_MSG +
        'value ' + ddserr.typeCheckMsgs.NUM_ERR_MSG
      );
    }

    this._transportPriority = Object.assign(this._transportPriority, jsobj);
  }

  // Documentation for destinationOrder is written in the setter function
  get destinationOrder() {
    return deepClone(this._destinationOrder);
  }

  /**
   * The destination order policy.
   *
   * Applies to: Topic, Reader, Writer
   *
   * @example
   * const dds = require('vortexdds');
   * const qos = dds.QoS.topicDefault();
   * qos.destinationOrder = {
   *     kind: dds.DestinationOrderKind.BySourceTimestamp
   * };
   *
   * @type {module:vortexdds~DestinationOrderPolicy}
   */
  set destinationOrder(jsobj) {
    if (check.not.undefined(jsobj.kind)) {
      check.assert.number(jsobj.kind, ddserr.typeCheckMsgs.KIND_ERR_MSG);
    }

    this._destinationOrder = Object.assign(this._destinationOrder, jsobj);
  }

  // Documentation for writerDataLifecycle is written in the setter function
  get writerDataLifecycle() {
    return deepClone(this._writerDataLifecycle);
  }

  /**
   * The writer data lifecycle policy.
   *
   * Applies to: Writer
   *
   * @example
   * const dds = require('vortexdds');
   * const qos = dds.QoS.writerDefault();
   * qos.writerDataLifecycle = {
   *     autodisposeUnregisteredInstances: false
   * };
   *
   * @type {module:vortexdds~WriterDataLifecyclePolicy}
   */
  set writerDataLifecycle(jsobj) {
    if (check.not.undefined(jsobj.autodisposeUnregisteredInstances)) {
      check.assert.boolean(
        jsobj.autodisposeUnregisteredInstances,
        ddserr.typeCheckMsgs.INVALID_ARG_MSG +
        'autodisposeUnregisteredInstances ' + ddserr.typeCheckMsgs.BOOL_ERR_MSG
      );
    }

    this._writerDataLifecycle = Object.assign(this._writerDataLifecycle, jsobj);
  }

  // Documentation for readerDataLifecycle is written in the setter function
  get readerDataLifecycle() {
    return deepClone(this._readerDataLifecycle);
  }

  /**
   * The reader data lifecycle policy.
   *
   * Applies to: Reader
   *
   * You only need to provide the fields that you want to change.
   *
   * @example
   * const dds = require('vortexdds');
   * const qos = dds.QoS.readerDefault();
   * const MS_TO_NS = 10 ^ 6;
   * qos.readerDataLifecycle = {
   *     autopurgeNoWriterSamples: 100 * MS_TO_NS,
   *     autopurgeDisposedSamplesDelay: 100 * MS_TO_NS
   * };
   *
   * @type {module:vortexdds~ReaderDataLifecyclePolicy}
   */
  set readerDataLifecycle(jsobj) {
    check.assert(
      check.any([
        check.number(jsobj.autopurgeNoWriterSamples),
        check.match(jsobj.autopurgeNoWriterSamples, HEX_OR_DEC_REGEX),
        check.not.assigned(jsobj.autopurgeNoWriterSamples),
      ]),
      ddserr.typeCheckMsgs.DUR_ERR_MSG,
      TypeError
    );

    check.assert(
      check.any([
        check.number(jsobj.autopurgeDisposedSamplesDelay),
        check.match(jsobj.autopurgeDisposedSamplesDelay, HEX_OR_DEC_REGEX),
        check.not.assigned(jsobj.autopurgeDisposedSamplesDelay),
      ]),
      ddserr.typeCheckMsgs.DUR_ERR_MSG,
      TypeError
    );

    this._readerDataLifecycle = Object.assign(this._readerDataLifecycle, jsobj);
  }

  // Documentation for DurabilityService is written in the setter function
  get durabilityService() {
    return deepClone(this._durabilityService);
  }

  /**
   * The durability service policy.
   *
   * Applies to: Topic, Writer
   *
   * You only need to provide the fields that you want to change.
   *
   * @example
   * const dds = require('vortexdds');
   * const qos = dds.QoS.topicDefault();
   * const MS_TO_NS = 10 ^ 6;
   * qos.durabilityService = {
   *     serviceCleanupDelay: 100 * MS_TO_NS,
   *     historyKind: dds.HistoryKind.KeepLast,
   *     historyDepth: 1,
   *     maxSamples: 1000,
   *     maxInstances 100,
   *     maxSamplesPerInstance: 10
   * };
   *
   * @type {module:vortexdds~DurabilityServicePolicy}
   */
  set durabilityService(jsobj) {

    check.assert(
      check.any([
        check.number(jsobj.serviceCleanupDelay),
        check.match(jsobj.serviceCleanupDelay, HEX_OR_DEC_REGEX),
        check.not.assigned(jsobj.serviceCleanupDelay),
      ]),
      ddserr.typeCheckMsgs.DUR_ERR_MSG,
      TypeError
    );

    if (check.not.undefined(jsobj.historyKind)) {
      check.assert.number(
        jsobj.historyKind,
        ddserr.typeCheckMsgs.INVALID_ARG_MSG +
        'historyKind ' + ddserr.typeCheckMsgs.NUM_ERR_MSG
      );
    }
    if (check.not.undefined(jsobj.historyDepth)) {
      check.assert.number(
        jsobj.historyDepth,
        ddserr.typeCheckMsgs.INVALID_ARG_MSG +
        'historyDepth ' + ddserr.typeCheckMsgs.NUM_ERR_MSG
      );
    }
    if (check.not.undefined(jsobj.maxSamples)) {
      check.assert.number(
        jsobj.maxSamples,
        ddserr.typeCheckMsgs.INVALID_ARG_MSG +
        'maxSamples ' + ddserr.typeCheckMsgs.NUM_ERR_MSG
      );
    }
    if (check.not.undefined(jsobj.maxInstances)) {
      check.assert.number(
        jsobj.maxInstances,
        ddserr.typeCheckMsgs.INVALID_ARG_MSG +
        'maxInstances ' + ddserr.typeCheckMsgs.NUM_ERR_MSG
      );
    }
    if (check.not.undefined(jsobj.maxSamplesPerInstance)) {
      check.assert.number(
        jsobj.maxSamplesPerInstance,
        ddserr.typeCheckMsgs.INVALID_ARG_MSG +
        'maxSamplesPerInstance ' + ddserr.typeCheckMsgs.NUM_ERR_MSG
      );
    }

    this._durabilityService = Object.assign(this._durabilityService, jsobj);
  }

}

/**
 * Represents a QoS 'profile' defining QoS policies
 * for one or more types of DDS entity.
 * A QoS profile is loaded from an XML document
 * that you create.
 *
 * A QoSProvider file is an alternative to specifying
 * QoS policies directly in your code. It allows you
 * to separate the QoS policy design from the
 * rest of your code.
 *
 * Vortex OpenSplice provides an XML schema for QoS profile
 * documents in *etc/DDS_QoSProfile.xsd* under your
 * OpenSplice installation. Coupled with an XML
 * schema-directed editor, you can quickly create
 * valid profile documents.
 *
 * @alias module:vortexdds.QoSProvider
 */
class QoSProvider{
  /** Create a qos provider.
   *
   * Note that a QoSProvider consumes DDS memory that
   * is not automatically reclaimed by NodeJS.
   * Once you are finished with a QoSProvider object,
   * you must call
   * {@link module:vortexdds.QoSProvider#delete|
   * QoSProvider.delete()}
   * to reclaim this memory.
   *
   * @param {string} qospath the absolute path to the qos file
   * @param {string} profile matches the *name* attribute of
   * a *qos_profile* element within the QoS provider file
   * @throws {module:vortexdds.DDSError} if the file
   * cannot be opened, or if the named profile cannot be found
   * in the file.
   */

  constructor(qosPath, profile) {
    check.assert.string(
      qosPath,
      ddserr.typeCheckMsgs.INVALID_ARG_MSG +
      'qosPath ' + ddserr.typeCheckMsgs.STR_ERR_MSG
    );
    check.assert.string(
      profile,
      ddserr.typeCheckMsgs.INVALID_ARG_MSG +
      'profile ' + ddserr.typeCheckMsgs.STR_ERR_MSG
    );

    let uri = null;
    /**
     * check if qospath is a file uri else build uri
     */
    if (qosPath.startsWith('file://')){
      uri = qosPath;
    } else {
      /**
         * check if qos path is an absolute path else
         * resolve it into an absolute path
         */
      if (path.isAbsolute(qosPath)){
        uri = 'file://' + qosPath;
      } else {
        uri = 'file://' + path.resolve(qosPath);
      }
    }
    this._qp = qc99.qosProviderCreate(uri, profile);
  }

  /**
   * Retrieves a Participant QoS
   *
   * @param {string} [name] matches the option *name* attribute
   * of the a *domainparticipant_qos* element within the profile.
   * If omitted, then the *domainparticipant_qos* without a *name*
   * attribute is selected.

   * @returns {module:vortexdds.QoS} QoS object that contains
   * values of the policies for a Participant
   * @throws {module:vortexdds.DDSError} if the specified
   * QoS object cannot be retrieved.
   *
   * @example
   * const dds = require('vortexdds');
   * const qp = somePreviouslyCreatedQoSProfile;
   * // retrieve the anonymous participant qos in the profile
   * const qos = qp.getParticipantQos();
   * const dp = new dds.Participant(qos);
   * // ... continue program, using the Participant 'dp'
   */
  getParticipantQos(name = null) {
    check.assert.maybe.string(name, ddserr.typeCheckMsgs.ID_STR_ERR_MSG);

    const cqos = qc99.qosCreate();
    qc99.qosProviderGetParticipantQos(this._qp, cqos, name);
    const qos = getQoSObjectAndDeleteHandle(cqos);
    return qos;
  }

  /**
   * Retrieves a Topic QoS
   *
   * @param {string} [name] matches the option *name* attribute
   * of the a *topic_qos* element within the profile.
   * If omitted, then the *topic_qos* without a *name*
   * attribute is selected.
   *
   * @returns {module:vortexdds.QoS} QoS object that contains
   * values of the policies for a Topic
   * @throws {module:vortexdds.DDSError} if the specified
   * QoS object cannot be retrieved.
   *
   * @example
   * const dds = require('vortexdds');
   * const qp = somePreviouslyCreatedQoSProfile;
   * const dp = somePreviouslyCreatedParticipant;
   * // retrieve the anonymous topic qos in the profile
   * const qos = qp.getTopicQos();
   * const name = 'SomeTopicName';
   * const ts = somePreviouslyRetrievedTypeSupport;
   * const topic = dp.createTopic(name, ts, qos);
   * // ... continue program, using the Topic 'topic'
   */
  getTopicQos(name = null) {
    check.assert.maybe.string(name, ddserr.typeCheckMsgs.ID_STR_ERR_MSG);

    const cqos = qc99.qosCreate();
    qc99.qosProviderGetTopicQos(this._qp, cqos, name);
    const qos = getQoSObjectAndDeleteHandle(cqos);
    return qos;
  }

  /**
   * Retrieves the Publisher QoS
   *
   * @param {string} [name] matches the option *name* attribute
   * of the a *publisher_qos* element within the profile.
   * If omitted, then the *publisher_qos* without a *name*
   * attribute is selected.
   *
   * @returns {module:vortexdds.QoS} QoS object that contains
   * values of the policies for a Publisher
   * @throws {module:vortexdds.DDSError} if the specified
   * QoS object cannot be retrieved.
   *
   * @example
   * const dds = require('vortexdds');
   * const qp = somePreviouslyCreatedQoSProfile;
   * const dp = somePreviouslyCreatedParticipant;
   * // retrieve the anonymous publisher qos in the profile
   * const qos = qp.getPublisherQos();
   * const pub = dp.createPublisher(qos);
   * // ... continue program, using the Publisher 'pub'
   */
  getPublisherQos(name = null) {
    check.assert.maybe.string(name, ddserr.typeCheckMsgs.ID_STR_ERR_MSG);

    const cqos = qc99.qosCreate();
    qc99.qosProviderGetPublisherQos(this._qp, cqos, name);
    const qos = getQoSObjectAndDeleteHandle(cqos);
    return qos;
  }

  /**
   * Retrieves the Subscriber qos
   *
   * @param {string} [name] matches the option *name* attribute
   * of the a *subscriber_qos* element within the profile.
   * If omitted, then the *subscriber_qos* without a *name*
   * attribute is selected.
   *
   * @returns {module:vortexdds.QoS} QoS object that contains
   * values of the policies for a Subscriber
   * @throws {module:vortexdds.DDSError} if the specified
   * QoS object cannot be retrieved.
   *
   * @example
   * const dds = require('vortexdds');
   * const qp = somePreviouslyCreatedQoSProfile;
   * const dp = somePreviouslyCreatedParticipant;
   * // retrieve the anonymous subscriber qos in the profile
   * const qos = qp.getSubscriberQos();
   * const sub = dp.createSubscriber(qos);
   * // ... continue program, using the Subscriber 'sub'
   */
  getSubscriberQos(name = null) {
    check.assert.maybe.string(name, ddserr.typeCheckMsgs.ID_STR_ERR_MSG);

    const cqos = qc99.qosCreate();
    qc99.qosProviderGetSubscriberQos(this._qp, cqos, name);
    const qos = getQoSObjectAndDeleteHandle(cqos);
    return qos;
  }

  /**
   * Retrieves the Writer QoS
   *
   * @param {string} [name] matches the option *name* attribute
   * of the a *datawriter_qos* element within the profile.
   * If omitted, then the *datawriter_qos* without a *name*
   * attribute is selected.
   *
   * @returns {module:vortexdds.QoS} QoS object that contains
   * values of the policies for a Writer
   * @throws {module:vortexdds.DDSError} if the specified
   * QoS object cannot be retrieved.
   *
   * @example
   * const dds = require('vortexdds');
   * const qp = somePreviouslyCreatedQoSProfile;
   * const dp = somePreviouslyCreatedParticipant;
   * const topic = somePreviouslyCreatedTopic;
   * // retrieve the anonymous writer qos in the profile
   * const qos = qp.getWriterQos();
   * const wr = dp.createWriter(topic, qos);
   * // ... continue program, using the Writer 'wr'
   */
  getWriterQos(name = null) {
    check.assert.maybe.string(name, ddserr.typeCheckMsgs.ID_STR_ERR_MSG);

    const cqos = qc99.qosCreate();
    qc99.qosProviderGetWriterQos(this._qp, cqos, name);
    const qos = getQoSObjectAndDeleteHandle(cqos);
    return qos;
  }

  /**
   * Retrieves the Reader QoS
   *
   * @param {string} [name] matches the option *name* attribute
   * of the a *datareader_qos* element within the profile.
   * If omitted, then the *datareader_qos* without a *name*
   * attribute is selected.
   *
   * @returns {module:vortexdds.QoS} QoS object that contains
   * values of the policies for a Reader
   * @throws {module:vortexdds.DDSError} if the specified
   * QoS object cannot be retrieved.
   *
   * @example
   * const dds = require('vortexdds');
   * const qp = somePreviouslyCreatedQoSProfile;
   * const dp = somePreviouslyCreatedParticipant;
   * const topic = somePreviouslyCreatedTopic;
   * // retrieve the anonymous reader qos in the profile
   * const qos = qp.getReaderQos();
   * const rd = dp.createReader(topic, qos);
   * // ... continue program, using the Reader 'rd'
   */
  getReaderQos(name = null) {
    check.assert.maybe.string(name, ddserr.typeCheckMsgs.ID_STR_ERR_MSG);

    const cqos = qc99.qosCreate();
    qc99.qosProviderGetReaderQos(this._qp, cqos, name);
    const qos = getQoSObjectAndDeleteHandle(cqos);
    return qos;
  }

  /**
   * Release the DDS allocated memory associated with
   * this QoSProvider object.
   *
   * Once delete() is called, the QoSProvider object is
   * no longer usable in your program.
   *
   * @example
   * const dds = require('vortexdds');
   * const qp = new dds.QoSProfile(somePath,someProfile);
   * // ... retrieve QoS entities from the profile to
   * // ... create your DDS entities.
   *
   * // all done with the QoSProfile, release its DDS memory
   * qp.delete();
   *
   * // ... continue executing your program, using the DDS
   * // ... entities you created above.
   */
  delete() {
    /** Delete the qos provider only if it hasn't been deleted */
    if (this._qp !== null){
      qc99.qosProviderDelete(this._qp);
      this._qp = null;
    }
  }
}

/**
 * Specifies the type of durability policy.
 * @readonly
 * @enum {number}
 * @alias module:vortexdds.DurabilityKind
 */
const DurabilityKind = {
  /**
   * The Service does not need to keep
   * any samples of data-instances on
   * behalf of any DataReader that is not
   * known by the DataWriter at the
   * time the instance is written. In other
   * words the Service will only attempt
   * to provide the data to existing
   * subscribers. This is the default kind.
   */
  Volatile: 0,
  /**
   * The Service will attempt to keep
   * some samples so that they can be
   * delivered to any potential late-
   * joining DataReader. Which
   * particular samples are kept depends
   * on other QoS such as HISTORY and
   * RESOURCE_LIMITS.
   * For TRANSIENT_LOCAL, the
   * service is only required to keep the
   * data in the memory of the
   * DataWriter that wrote the data and
   * the data is not required to survive
   * the DataWriter.
   */
  TransientLocal: 1,
  /**
   * The Service will attempt to keep
   * some samples so that they can be
   * delivered to any potential late-
   * joining DataReader. Which
   * particular samples are kept depends
   * on other QoS such as HISTORY and
   * RESOURCE_LIMITS.
   * For TRANSIENT, the service is
   * only required to keep the data in
   * memory and not in permanent
   * storage; but the data is not tied to
   * the lifecycle of the DataWriter and
   * will, in general, survive it.
   */
  Transient: 2,
  /**
   * Data is kept on permanent
   * storage, so that they can outlive a
   * system session.
   */
  Persistent: 3,
};

/**
 * Constants specifying behaviours of the
 * History Service.
 * @readonly
 * @enum {number}
 *
 * @alias module:vortexdds.HistoryKind
 */
const HistoryKind = {
  /**
   * On the publishing side, the Service
   * will only attempt to keep the most
   * recent depth samples of each
   * instance of data (identified by its
   * key) managed by the DataWriter.
   * On the subscribing side, the
   * DataReader will only attempt to
   * keep the most recent depth
   * samples received for each instance
   * (identified by its key) until the
   * application takes them via the
   * DataReaders take operation.
   * KeepLast is the default kind.
   * The default value of depth is 1.
   * If a value other than 1 is specified, it
   * should be consistent with the
   * settings of the
   * RESOURCE_LIMITS QoS policy.
   */
  KeepLast: 0,
  /**
   * On the publishing side, the Service
   * will attempt to keep all samples
   * (representing each value written) of
   * each instance of data (identified by
   * its key) managed by the DataWriter
   * until they can be delivered to all
   * subscribers. On the subscribing side,
   * the Service will attempt to keep all
   * samples of each instance of data
   * (identified by its key) managed by
   * the DataReader. These samples are
   * kept until the application takes
   * them from the Service via the take
   * operation. The setting of depth has
   * no effect. Its implied value is
   * LENGTH_UNLIMITED.
   */
  KeepAll: 1,
};

/**
 * Defines the kinds of ownership for the
 * {@link module:vortexdds.QoS#ownership|ownership}
 * policy.
 * @readonly
 * @enum {number}
 *
 * @alias module:vortexdds.OwnershipKind
 */
const OwnershipKind = {
  /**
   * Indicates shared ownership for each instance.
   * Multiple writers are allowed to update the same instance
   * and all the updates are made available to the readers.
   * In other words there is no concept of an owner for
   * the instances. This is the default behavior if the
   * {@link module:vortexdds.QoS#ownership|ownership}
   * QoS policy is not specified.
   */
  Shared: 0,
  /**
   * Indicates each instance can only be owned by one Writer,
   * but the owner of an instance can change dynamically.
   * The selection of the owner is controlled by the setting of
   * the
   * {@link module:vortexdds.QoS#ownershipStrength|ownershipStrength}
   * QoS policy. The owner is always set to be the highest-strength
   * Writer object among the ones currently active (as determined by
   * the
   * {@link module:vortexdds.QoS#liveliness|liveliness}
   * QoS).
   */
  Exclusive: 1,
};

/**
 * Defines the kinds of
 * {@link module:vortexdds.QoS#liveliness|liveliness}
 * QoS policy.
 * @readonly
 * @enum {number}
 *
 * @alias module:vortexdds.LivelinessKind
 */
const LivelinessKind = {
  /**
   * The infrastructure will automatically
   * signal liveliness for the Writers at least as
   * often as required by the
   * {@link module:vortexdds~LivelinessPolicy|
   * LivelinessPolicy}
   * *leaseDuration* field.
   */
  Automatic: 0,
  /**
   * The user application takes responsibility to signal
   * liveliness to the DDS Service using one of the
   * mechanisms described in Section 7.1.3.11, LIVELINESS,
   * on page 113 DDS 1.2 Specification.
   * Liveliness must be asserted as
   * often as required by the
   * {@link module:vortexdds~LivelinessPolicy|
   * LivelinessPolicy}
   * *leaseDuration* field.
   * Otherwise the DDS Service will assume the
   * corresponding Entity is no longer active/alive.
   *
   * The DDS Service will assume that as long as at least one
   * Entity within the Participant has asserted its liveliness
   * the other Entities in that same Participant are also alive.
   */
  ManualByParticipant: 1,
  /**
   * The user application takes responsibility to signal
   * liveliness to the DDS Service using one of the
   * mechanisms described in Section 7.1.3.11, LIVELINESS,
   * on page 113 of the DDS 1.2 Specification}.
   * Liveliness must be asserted as
   * often as required by the
   * {@link module:vortexdds~LivelinessPolicy|
   * LivelinessPolicy}
   * *leaseDuration* field.
   * Otherwise the DDS Service will assume the
   * corresponding Entity is no longer active/alive.
   *
   * The DDS Service will only assume liveliness of the Writer if
   * the application has asserted liveliness of that Writer itself.
   */
  ManualByTopic: 2,
};

/**
 * The kinds of
 * {@link module:vortexdds.QoS#reliability|reliability}
 * QoS policy.
 * @readonly
 * @enum {number}
 *
 * @alias module:vortexdds.ReliabilityKind
 */
const ReliabilityKind = {
  /**
   * Specifies the DDS Service will attempt to deliver all samples
   * in its history. Missed samples may be retried. In steady-state
   * (no modifications communicated via the Writer) the middleware
   * guarantees that all samples in the Writer history will eventually
   * be delivered to all the Reader a objects. Outside steady state
   * the
   * {@link module:vortexdds.QoS#history|history}
   * and
   * {@link module:vortexdds.QoS#resourceLimits|resourceLimits}
   * policies will determine how samples become part of the history
   * and whether samples can be discarded from it. This is the default
   * value for Writers.
   */
  BestEffort: 0,
  /**
   * Indicates that it is acceptable to not retry propagation
   * of any samples. Presumably new values for the samples
   * are generated often enough that it is not necessary to
   * re-send or acknowledge any samples. This is the default
   * value for Readers and Topics.
   */
  Reliable: 1,
};

/**
 * The kinds of
 * {@link module:vortexdds.QoS#destinationOrder|destinationOrder}
 * QoS policy
 * @readonly
 * @enum {number}
 *
 * @alias module:vortexdds.DestinationOrderKind
*/
const DestinationOrderKind = {
  /**
   * Indicates that data is ordered based on the reception time
   * at each Subscriber. Since each subscriber may receive the
   * data at different times there is no guaranteed that the
   * changes will be seen in the same order. Consequently, it is
   * possible for each subscriber to end up with a different final
   * value for the data.
   */
  ByReceptionTimestamp: 0,
  /**
   * Indicates that data is ordered based on a timestamp placed
   * at the source (by the DDS Service or by the application).
   * In any case this guarantees a consistent final value for
   * the data in all subscribers.
   */
  BySourceTimestamp: 1,
};

/**
 * Constants defining the kinds of presentation
 * policy scopes.
 * @readonly
 * @enum {number}
 *
 * @alias module:vortexdds.PresentationAccessScopeKind
*/
const PresentationAccessScopeKind = {
  /**
   * No coherent change sets are expected
   */
  Instance: 0,
  /**
   * Samples written by a Writer within
   * a 'coherent change' will not be interleaved
   * by other samples when read by a Reader.
   *
   * Note: The NodeJS API does not support Topic kind.
   */
  Topic: 1,
  /**
   * Samples written by multiple Writers within
   * a 'coherent change' will not be interleaved
   * by other samples written by other Writers when
   * accessed from a coherent Subscriber..
   *
   * Note: The NodeJS API does not support Group kind.
   */
  Group: 2,
};

module.exports = {
  QoSProvider: QoSProvider,
  QoS: QoS,
  getQoSObjectAndDeleteHandle: getQoSObjectAndDeleteHandle,
  DurabilityKind: Object.freeze(DurabilityKind),
  HistoryKind: Object.freeze(HistoryKind),
  OwnershipKind: Object.freeze(OwnershipKind),
  LivelinessKind: Object.freeze(LivelinessKind),
  ReliabilityKind: Object.freeze(ReliabilityKind),
  DestinationOrderKind: Object.freeze(DestinationOrderKind),
  PresentationAccessScopeKind: Object.freeze(PresentationAccessScopeKind),
  QosPolicyID: Object.freeze(QosPolicyID),
  HEX_OR_DEC_REGEX: HEX_OR_DEC_REGEX,
};
