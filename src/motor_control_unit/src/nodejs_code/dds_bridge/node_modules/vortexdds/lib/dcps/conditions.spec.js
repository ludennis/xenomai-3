/*
 *                         Vortex OpenSplice
 *
 *   This software and documentation are Copyright 2006 to 2019 ADLINK
 *   Technology Limited, its affiliated companies and licensors. All rights
 *   reserved.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

'use strict';
/* eslint-env node, mocha */

const dcps = require('./dcps');
const ddserr = require('./ddserr');
const TypeSupport = require('./ddstopic').TypeSupport;
const expect = require('chai').expect;


/* Topic Descriptor Information */
const sampleTypeName = 'HelloWorldData::Msg';
const sampleTypeKey = 'userID';
const sampleTopicXML = '<MetaData version="1.0.0">' +
  '<Module name="HelloWorldData">' +
  '<Struct name="Msg">' +
  '<Member name="userID"><Long/></Member>' +
  '<Member name="message"><Long/></Member>' +
  '</Struct>' +
  '</Module>' +
  '</MetaData>';

function createSampleTopic(participant, topicname) {
  let typeSupport = new TypeSupport(sampleTypeName, sampleTypeKey,
    sampleTopicXML);
  return participant.createTopic(
    topicname,
    typeSupport
  );
}

function SEC_TO_NANO(n) {
  return n * 1000000000;
}

function SEC_TO_MILI(n) {
  return n * 1000;
}

describe('Conditions', function() {
  let dp = null;

  before(function() {
    dp = new dcps.Participant();
  });

  after(async function() {
    this.timeout(SEC_TO_MILI(20));
    await dp.delete();
  });

  describe('Read conditions', function() {

    it('Can trigger a read condition on a waitset', async function() {
      let topic = createSampleTopic(dp, 'readConditionTopic1');
      let reader = dp.createReader(topic, null);
      let writer = dp.createWriter(topic, null);

      let cond = reader.createReadCondition(dcps.StateMask.sample.not_read);

      let sample = { userID: 1, message: 2 };

      writer.write(sample);

      // create the waitset
      let waitset = new dcps.Waitset();
      waitset.attach(cond);

      const conds = await waitset.wait(SEC_TO_NANO(1));
      expect(conds).to.deep.equal([cond]);
    });

    it('Waitset will timeout when read condition not triggered within 1s',
      async function() {
        let topic = createSampleTopic(dp, 'readConditionTopic2');
        let reader = dp.createReader(topic);

        let cond = reader.createReadCondition(dcps.StateMask.sample.not_read);

        // create the waitset
        let waitset = new dcps.Waitset();
        waitset.attach(cond);

        await waitset.wait(SEC_TO_NANO(1)).catch(function(err) {
          expect(err).to.be.an.instanceof(ddserr.DDSError);
          expect(err.ddsErrCode).to
            .equal(ddserr.DDSErrorCode.TIMEOUT);
        });
      });

    xit('Can create a ReadCondition, and read samples against it', function() {
      let topic = createSampleTopic(dp, 'readConditionTopic3');
      let reader = dp.createReader(topic, null);
      let writer = dp.createWriter(topic, null);

      let cond = reader.createReadCondition(dcps.StateMask.view.not_new);

      let sample1 = { userID: 1, message: 2 };
      let sample2 = { userID: 1, message: 3 };

      // we write two samples
      // the first one will get read, the other one will be ignored
      writer.write(sample1);

      // expect to get nothing
      let dataSet = reader.readCond(1, cond);
      expect(dataSet.length).to.equal(0);

      // read, and mark key userID=1 as not_new
      reader.read(1);

      writer.write(sample2);

      dataSet = reader.readCond(1, cond);

      expect(dataSet[0].sample).to.deep.equal(sample2);
      expect(dataSet[0].info.view_state).to.equal(dcps.StateMask.view.not_new);
    });

    xit('Can create a ReadCondition, and take samples against it', function() {
      let topic = createSampleTopic(dp, 'readConditionTopic4');
      let reader = dp.createReader(topic, null);
      let writer = dp.createWriter(topic, null);

      let cond = reader.createReadCondition(dcps.StateMask.view.not_new);

      let sample1 = { userID: 1, message: 2 };
      let sample2 = { userID: 1, message: 3 };

      // we write two samples
      // the first one will get read, the other one will be ignored
      writer.write(sample1);

      // expect to get nothing
      let dataSet = reader.takeCond(1, cond);
      expect(dataSet.length).to.equal(0);

      // read, to mark the instance userID=1 as not_new
      reader.read(1);

      writer.write(sample2);

      dataSet = reader.takeCond(1, cond);

      expect(dataSet[0].sample).to.deep.equal(sample2);
      expect(dataSet[0].info.view_state).to.equal(dcps.StateMask.view.not_new);
    });


  });

  describe('Query conditions', function() {
    it('Match-everything query condition on waitset is triggered on any' +
      ' incoming data',
    async function() {
      let topic = createSampleTopic(dp, 'queryConditionTopic1');
      let reader = dp.createReader(topic, null);
      let writer = dp.createWriter(topic, null);

      let cond = reader.createQueryCondition(dcps.StateMask.any,
        '1=1', []);

      let sample = { userID: 1, message: 2 };

      writer.write(sample);

      // create the waitset
      let waitset = new dcps.Waitset();
      waitset.attach(cond);

      const conds = await waitset.wait(SEC_TO_NANO(1));
      expect(conds).to.deep.equal([cond]);
    });

    it('Non-trivial query condition on waitset triggers on ' +
      'incoming matching data', async function() {
      let topic = createSampleTopic(dp, 'queryConditionTopic2');
      let reader = dp.createReader(topic, null);
      let writer = dp.createWriter(topic, null);

      let cond = reader.createQueryCondition(
        dcps.StateMask.sample.not_read,
        'userID=%0',
        ['1']);


      let sample = { userID: 1, message: 2 };

      writer.write(sample);

      // create the waitset
      let waitset = new dcps.Waitset();
      waitset.attach(cond);

      const conds = await waitset.wait(SEC_TO_NANO(1));
      expect(conds).to.deep.equal([cond]);
    });

    it('Can create non-trivial query condition and read samples against it',
      function() {
        let topic = createSampleTopic(dp, 'queryConditionTopic3');
        let reader = dp.createReader(topic, null);
        let writer = dp.createWriter(topic, null);

        let cond = reader.createQueryCondition(
          dcps.StateMask.sample.not_read,
          'userID=%0',
          ['3']);

        let sample1 = { userID: 1, message: 2 };
        let sample2 = { userID: 3, message: 4 };

        writer.write(sample1);
        writer.write(sample2);

        let dataSet = reader.readCond(1, cond);
        expect(dataSet[0].sample).to.deep.equal(sample2);
      });

    it('Can create non-trivial query condition and take samples against it',
      function() {
        let topic = createSampleTopic(dp, 'queryConditionTopic4');
        let reader = dp.createReader(topic, null);
        let writer = dp.createWriter(topic, null);

        let cond = reader.createQueryCondition(
          dcps.StateMask.sample.not_read,
          'userID=%0',
          ['3']);

        let sample1 = { userID: 1, message: 2 };
        let sample2 = { userID: 3, message: 4 };

        writer.write(sample1);
        writer.write(sample2);

        let dataSet = reader.takeCond(1, cond);
        expect(dataSet[0].sample).to.deep.equal(sample2);
      });

    it('Waitset will timeout when query condition not triggered within 1s',
      async function() {
        let topic = createSampleTopic(dp, 'queryConditionTopic5');
        let reader = dp.createReader(topic);

        let cond = reader.createQueryCondition(
          dcps.StateMask.sample.not_read,
          'userID=%0',
          ['1']);

        // create the waitset
        let waitset = new dcps.Waitset();
        waitset.attach(cond);

        await waitset.wait(SEC_TO_NANO(1)).catch(function(err) {
          expect(err).to.be.an.instanceof(ddserr.DDSError);
          expect(err.ddsErrCode).to
            .equal(ddserr.DDSErrorCode.TIMEOUT);
        });
      });
  });

  describe('Status Conditions', function() {
    it('Can trigger a status condition', async function() {
      let topic = createSampleTopic(dp, 'statusConditionTopic');
      let reader = dp.createReader(topic);
      // eslint-disable-next-line no-unused-vars
      let writer = dp.createWriter(topic);

      let cond = reader.createStatusCondition(dcps.StatusMask
        .subscription_matched);

      // create the waitset
      let waitset = new dcps.Waitset();
      waitset.attach(cond);

      let conds = await waitset.wait(SEC_TO_NANO(1));
      expect(conds).to.deep.equal([cond]);
    });
  });
});
