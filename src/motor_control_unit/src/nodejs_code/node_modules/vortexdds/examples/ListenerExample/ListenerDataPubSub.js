/*
 *                         Vortex OpenSplice
 *
 *   This software and documentation are Copyright 2006 to 2019 ADLINK
 *   Technology Limited, its affiliated companies and licensors. All rights
 *   reserved.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

/*
    Listener example.
    Instructions: 1. Run nodejs ListenerDataPubSub.js
*/

'use strict';

const dds = require('vortexdds');
const path = require('path');

main();

function main() {
  listenerDataPubSub().then(() => {
    console.log('=== ListenerDataPubSub end');
    process.exit(0);
  }).catch((error) => {
    console.log('Error: ' + error.message);
    process.exit(1);
  });
}

async function listenerDataPubSub() {

  console.log('=== ListenerDataPubSub start');

  let participant = null;
  try {
    participant = new dds.Participant();

    const topicName = 'ListenerDataTopic';
    const idlName = 'ListenerData.idl';
    const idlPath = __dirname + path.sep + idlName;
    const typeSupports = await dds.importIDL(idlPath);
    const typeSupport = typeSupports.get('ListenerData::Msg');

    const topic = participant.createTopic(topicName, typeSupport);

    let listenerTriggered = false;
    // eslint-disable-next-line no-unused-vars
    const writer = participant.createWriter(
      topic,
      null,
      {
        onPublicationMatched: function(entity, status) {
          console.log('=== [ListenerDataPubSub] ' +
          'onPublicationMatched listener triggered');
          console.log('    status.totalCount: ', status.totalCount);
          console.log('    status.totalCountChange: ', status.totalCountChange);
          listenerTriggered = true;
        },
      }
    );
    console.log('writer created');

    // eslint-disable-next-line no-unused-vars
    const reader = participant.createReader(topic);
    console.log('reader created');

    const waitForReaderPromise = new Promise((resolve, reject) => {
      console.log('Promise created to run the program until ' +
      'the listener gets triggered');
      let intervalObject = setInterval(function() {
        if (listenerTriggered) {
          clearInterval(intervalObject);
          resolve(0);
        }
      }, 100);
    });
    await waitForReaderPromise;

  } finally {
    console.log('=== Cleanup resources');
    if (participant !== null) {
      participant.delete().catch((error) => {
        console.log('Error cleaning up resources: '
          + error.message);
      });
    }
  }
}
