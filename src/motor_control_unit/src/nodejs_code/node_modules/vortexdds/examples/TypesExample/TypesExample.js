/*
 *                         Vortex OpenSplice
 *
 *   This software and documentation are Copyright 2006 to 2019 ADLINK
 *   Technology Limited, its affiliated companies and licensors. All rights
 *   reserved.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

/*
    This example demonstrates how to write data with
    different data types.   (Sequences, Arrays,
    Enumerations,Nested types)
    Instructions: 1. Run node TypesExample.js

*/

'use strict';

const dds = require('vortexdds');
const path = require('path');

main();

function main() {
  examples().then(() => {
    console.log('=== TypesExample end');
    process.exit(0);
  }).catch((error) => {
    console.log('Error: ' + error.message);
    process.exit(1);
  });
}

async function examples() {

  console.log('=== TypesExample start\n');

  let participant = null;
  try {

    // setup
    participant = new dds.Participant();
    const idlName = 'types.idl';
    const idlPath = __dirname + path.sep + idlName;
    const typeSupports = await dds.importIDL(idlPath);

    enumExample(participant, typeSupports);

    sequenceExample(participant, typeSupports);

    boundedSequenceExample(participant, typeSupports);

    arrayOfSeqExample(participant, typeSupports);

    nestedTypeExample(participant, typeSupports);

    arrayOfNestedTypeExample(participant, typeSupports);

  } finally {
    console.log('=== Cleanup resources');
    if (participant !== null){
      participant.delete().catch((error) => {
        console.log('Error cleaning up resources: '
          + error.message);
      });
    }
  }

}

function enumExample(participant, typeSupports){

  console.log('=== enumExample');

  const typeSupport = typeSupports.get('DataType::TypeTestEnum');
  const colorEnum = typeSupport.getClass('DataType::Color');

  const topic = participant.createTopic('myTypeTestEnum', typeSupport);

  const data = {
    id: 1,
    value: colorEnum.GREEN.value, // enum
  };
  writeReadData(participant, topic, data);

  console.log('===\n');
}

function sequenceExample(participant, typeSupports){

  console.log('=== sequenceExample');

  const typeSupport = typeSupports.get('DataType::TypeTestSeq');
  const topic = participant.createTopic('seqTopic', typeSupport);

  const data = {
    id: 2,
    value: [1, -6, 7], // sequence of long
  };
  writeReadData(participant, topic, data);

  console.log('===\n');
}

function boundedSequenceExample(participant, typeSupports){

  console.log('=== boundedSequenceExample');

  const typeSupport = typeSupports.get('DataType::TypeTestBoundedSeq');
  const topic = participant.createTopic(
    'boundedSeqTopic',
    typeSupport
  );
  const data = {
    id: 3,
    value: [5, 6, 7], // bounded sequence of long
  };

  writeReadData(participant, topic, data);

  console.log('===\n');
}

function arrayOfSeqExample(participant, typeSupports){

  console.log('=== arrayOfSeqExample');

  const typeSupport = typeSupports.get('DataType::TypeTestArrayOfSeq');
  const topic = participant.createTopic(
    'arrayOfSeqTopic',
    typeSupport
  );
  const data = {
    id: 4,
    value: [ // array of sequence of long
      [1],
      [8, 4, 3],
      [2, 3, 7],
    ],
  };

  writeReadData(participant, topic, data);

  console.log('===\n');
}

function nestedTypeExample(participant, typeSupports){

  console.log('=== nestedTypeExample');

  const typeSupport = typeSupports.get(
    'DataType::TypeTestNestedStruct'
  );
  const topic = participant.createTopic(
    'nestedStructTopic',
    typeSupport
  );
  const data = {
    id: 5,
    value: { // nested struct
      key: 99,
      message: 'Hi',
    },
  };
  writeReadData(participant, topic, data);

  console.log('===\n');
}

function arrayOfNestedTypeExample(participant, typeSupports){

  console.log('=== arrayOfNestedTypeExample');

  const typeSupport = typeSupports.get(
    'DataType::TypeTestArrayOfNestedStruct'
  );
  const topic = participant.createTopic(
    'arrayOfNestedStructTopic',
    typeSupport
  );

  const data = {
    id: 5,
    value: [
      // Array of nested struct:
      // number of elements in the array is equal to
      // array size in the idl file (2)
      {
        key: 3,
        message: 'hello',
      },
      {
        key: 7,
        message: 'there',
      },
    ],
  };
  writeReadData(participant, topic, data);

  console.log('===\n');
}

function writeReadData(participant, topic, jsData) {

  const qos = new dds.QoS({
    reliability: {kind: dds.ReliabilityKind.BestEffort}});

  const reader = participant.createReader(topic, qos);
  const writer = participant.createWriter(topic, qos);

  console.log('write 1 sample');
  writer.write(jsData);

  console.log('take 1 sample');
  reader.take(1);
}


