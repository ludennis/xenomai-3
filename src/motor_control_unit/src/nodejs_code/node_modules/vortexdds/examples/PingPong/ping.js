/*
 *                         Vortex OpenSplice
 *
 *   This software and documentation are Copyright 2006 to 2019 ADLINK
 *   Technology Limited, its affiliated companies and licensors. All rights
 *   reserved.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

/*
    Ping Pong ping.
    Instructions: run nodejs ping.js
                  run nodejs pong.js
                  You may run these in any order.
*/
/**
 * Summary: Ping sends a message on the "ping" partition with a userID of 0,
 * which pong reads. Pong sends the message back on the "pong" partition with
 * the same userID field. Ping reads it, and sends the message back with 1
 * added to the userID field. This is repeated until userID = 20.
 *
 * All the messages from ping have 'from ping' in the message field, and all the
 * messages from pong have 'from pong' in the message field.
 */

'use strict';

const dds = require('vortexdds');
const path = require('path');

main();

function main(){
  ping().then(() => {
    console.log('=== Ping end');
    process.exit(0);
  }).catch((error) => {
    console.log('Error: ' + error.message);
    process.exit(1);
  });
}

async function ping() {

  console.log('=== Ping start');

  let participant = null;
  try {
    // create our entities
    participant = new dds.Participant();

    const topicName = 'PingPongData_Msg';
    const idlName = 'PingPongTopic.idl';
    const idlPath = __dirname + path.sep + idlName;

    const typeSupports = await dds.importIDL(idlPath);
    const typeSupport = typeSupports.get('PingPongData::Msg');

    const topic = participant.createTopic(
      topicName,
      typeSupport
    );

    // create publisher on partition 'Ping' and writer on the publisher
    // on pong, we have a subscriber on the same partition and topic
    const pqos = dds.QoS.publisherDefault();

    pqos.partition = {names: 'Ping'};
    const publisher = participant.createPublisher(pqos);

    const wqos = new dds.QoS({
      reliability: {kind: dds.ReliabilityKind.BestEffort}});
    const writer = publisher.createWriter(topic, wqos);

    // create a subscriber on partition 'Pong' and a reader on the subscriber
    const sqos = dds.QoS.subscriberDefault();

    sqos.partition = {names: 'Pong'};
    const subscriber = participant.createSubscriber(sqos);

    const reader = subscriber.createReader(topic);

    // create waitset which waits until pong subscriber on partition
    // 'Ping' is found
    let pubMatchedCond = null;
    let pubMatchedWaitset = null;
    try {
      pubMatchedCond = writer.createStatusCondition();
      pubMatchedCond.enable(dds.StatusMask.publication_matched);
      pubMatchedWaitset = new dds.Waitset(pubMatchedCond);

      // wait until pong has been found
      console.log('Waiting for pong subscriber to be found...');
      await pubMatchedWaitset.wait(dds.SEC_TO_NANO(10));
      console.log('Found pong subscriber.');
    } finally {
      if (pubMatchedWaitset !== null){
        pubMatchedWaitset.delete();
      }
    }

    // Ping writes the first message
    let msg = {userID: 0, message: 'from ping'};
    console.log('sending ' + JSON.stringify(msg));
    writer.write(msg);

    // wait for data, and resend in a ping/pong
    // loop for 20 iterations
    let newDataCondition = null;
    let newDataWaitset = null;
    try {
      // create waitset for new data
      newDataCondition = reader.createReadCondition(
        dds.StateMask.sample.not_read
      );
      newDataWaitset = new dds.Waitset(newDataCondition);

      /* Loop 20 times: when we have new data, it
       reads it, prints it, and sends back a message with the userID
       field incremented by one and 'from ping' in the message field.*/

      for (let i = 0; i < 20; i++) {
        // wait for new data
        await newDataWaitset.wait();

        // new data incoming
        let takeArray = reader.take(1);
        if (takeArray.length > 0 && takeArray[0].info.valid_data) {
          let sample = takeArray[0].sample;
          console.log('received: ' + JSON.stringify(sample));
          let msg = {userID: sample.userID + 1, message: 'from ping'};
          console.log('sending ' + JSON.stringify(msg));
          writer.write(msg);
        }

      }

    } finally {
      if (newDataWaitset !== null){
        newDataWaitset.delete();
      }
    }

  } finally {
    console.log('=== Cleanup resources');
    if (participant !== null){
      participant.delete().catch((error) => {
        console.log('Error cleaning up resources: '
          + error.message);
      });
    }
  }
}
