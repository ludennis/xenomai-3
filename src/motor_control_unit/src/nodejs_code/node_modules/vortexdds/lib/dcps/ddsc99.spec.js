/*
 *                         Vortex OpenSplice
 *
 *   This software and documentation are Copyright 2006 to 2019 ADLINK
 *   Technology Limited, its affiliated companies and licensors. All rights
 *   reserved.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

'use strict';
/* eslint-env node, mocha */

const dds = require('./ddsc99');
const ddserr = require('./ddserr');
const ddstopic = require('./ddstopic');
const ddsqos = require('./qos');
const qosc99 = require('./qosc99');
const expect = require('chai').expect;
const ref = require('ref');
const os = require('os');
const sleep = require('sleep');

/* sample topic data */
const sampleTopicXML = '<MetaData version="1.0.0">' +
  '<Module name="HelloWorldData">' +
  '<Struct name="Msg">' +
  '<Member name="userID"><Long/></Member>' +
  '<Member name="message"><Long/></Member>' +
  '</Struct>' +
  '</Module>' +
  '</MetaData>';
const sampleTypeName = 'HelloWorldData::Msg';
const sampleTypeKey = 'userID';
const sampleTopicName = 'HelloWorldData_Msg';
var topicNameInstanceCounter = 0;// increment each time sampleTopicName is used

const pvoid = ref.refType(ref.types.void);

function SEC_TO_MILI(n) {
  return n * 1000;
}

// test the environment
describe('OSPL environment', function() {
  it('Has non-empty OSPL_HOME', function() {
    this.timeout(10000);
    expect(process.env.OSPL_HOME).to.not.be.a('null');
  });
});


describe('FFI interface to C99 - participant', function() {
  if (os.platform() === 'linux') {
    it('participantCreate fails with invalid OSPL_URI', function() {

      this.timeout(10000);
      const savedOsplURI = process.env.OSPL_URI;
      process.env.OSPL_URI = savedOsplURI + 'XXX';

      // expect failure with the default callback
      expect(function() { dds.participantCreate(); })
        .to.throw(ddserr.DDSError)
        .with.property('ddsErrCode').to.be.within(1, 12); ;

      // change the URI back
      process.env.OSPL_URI = savedOsplURI;

    });
  }
});

describe('FFI interface to C99', function() {

  var dp = null;
  var typeSupport = null;

  before(function() {
    dp = dds.participantCreate();
    typeSupport = new ddstopic.TypeSupport(
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    );
  });

  after(function(done) {
    this.timeout(SEC_TO_MILI(20));
    dds.entityDelete(dp, function(err, res) {
      expect(err).to.be.null;
      expect(res).to.be.null;
      done();
    });
  });

  /* topicDescriptorCreate tests */
  it('topicDescriptorCreate creates a topic descriptor',
    function() {
      expect(function() {
        dds.topicDescriptorCreate(
          sampleTypeName,
          sampleTypeKey,
          sampleTopicXML
        );
      }).not.to.throw(Error);
    });

  it('topicDescriptorCreate fails to create topic descriptor with invalid '
    + 'arguments',
  function() {
    // the only way I know how to make this call fail is to put in the wrong
    // type of arguments so FFI fails. So we'll just test with (0,0,0) for
    // now.

    // expect failure with default callback
    expect(function() { dds.topicDescriptorCreate(0, 0, 0); })
      .to.throw(TypeError);
  });

  it('delete a topic descriptor', function() {
    var topicDesc = dds.topicDescriptorCreate(
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    );
    expect(function() {
      dds.topicDescriptorDelete(topicDesc);
    }).to.not.throw(Error);
  });

  it('topicDescriptorDelete throws exception for invalid argument', function() {
    expect(function() {
      dds.topicDescriptorDelete(0);
    }).to.throw(TypeError);
  });
  /* end of topicDescriptorCreate tests */

  /* publisherCreate tests */
  it('publisherCreate creates a publisher', function() {
    var pub = dds.publisherCreate(dp);
    expect(pub).to.not.be.a('null');
  });

  it('publisherCreate fails with invalid arguments',
    function() {
      // We can make publisherCreate fail by passing in a random pointer
      // instead of a valid dp. This results in a negative status
      // which turns into an error.

      // expect failure with default callback
      expect(function() { dds.publisherCreate(ref.alloc(ref.types.void)); })
        .to.throw(Error);
    });
  /* end of publisherCreate tests */

  it('entityDelete fails with an invalid argument',
    function(done) {
      dds.entityDelete('foo', function(err, res) {
        expect(err).to.be.an.instanceOf(TypeError);
        done();
      });
    });

  /* topicFind tests */
  it('topicFind finds a published topic', function(done) {
    var desc = dds.topicDescriptorCreate(
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    );
    var topic = dds.topicCreate(dp, desc, 'hello');
    expect(topic).to.not.be.a('null');
    dds.topicFind(
      dp,
      'hello',
      function(err, result) {
        expect(result).to.not.be.a('null');
        expect(err).to.be.null;
        done();
      }
    );
  });

  it('topicFind fails to find a topic when there is no topic on the domain '
    + 'participant', function() {
    // for the moment, the only way i'll make the call fail is by passing in 0

    // expect failure with default callback
    expect(function() { dds.topicFind(0, sampleTopicName); }).to.throw(Error);

  });
  /* end of topicFind tests */

  /* topicGetTypeName tests */
  it('topicGetTypeName gets the type name of a created topic', function() {
    var desc = dds.topicDescriptorCreate(
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    );
    var top = dds.topicCreate(dp, desc, sampleTopicName);
    expect(dds.topicGetTypeName(top)).to.equal(sampleTypeName);
  });

  it('topicGetTypeName fails when the topic is invalid (0)', function() {
    // pass in 0 to force the call to fail
    expect(function() { dds.topicGetTypeName(0); })
      .to.throw(Error);
  });
  /* end of topicGetTypeName tests */

  /* topicGetKeylist tests */
  it('topicGetKeylist gets the keylist of a created topic', function() {
    var desc = dds.topicDescriptorCreate(
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    );
    var top = dds.topicCreate(dp, desc, sampleTopicName);
    expect(dds.topicGetKeylist(top)).to.equal('userID');
  });

  it('topicGetKeylist fails when the topic is invalid', function() {
    // expect failure with default callback
    expect(function() { dds.topicGetKeylist(0); }).to.throw(Error);
  });
  /* end of topigGetKeylist tests */

  /* topicGetMetadescriptor tests */
  it('topicGetMetadescriptor gets the metadescriptor of a created topic',
    function() {
      var desc = dds.topicDescriptorCreate(
        sampleTypeName,
        sampleTypeKey,
        sampleTopicXML
      );
      var top = dds.topicCreate(dp, desc, sampleTopicName);
      expect(dds.topicGetMetadescriptor(top)).to
        .equal(sampleTopicXML);
    });

  it('topicGetMetadescriptor fails when the topic is invalid', function() {
    // expect failure with default callback
    expect(function() { dds.topicGetMetadescriptor(0); }).to.throw(Error);
  });
  /* end of topicGetMetadecsriptor tests */

  /* topicGetName tests */
  it('topicGetName gets the name of a created topic', function() {
    var desc = dds.topicDescriptorCreate(
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    );
    var top = dds.topicCreate(dp, desc, sampleTopicName);
    expect(dds.topicGetName(top)).to.equal(sampleTopicName);
  });

  it('topicGetName fails when the topic (first argument) is invalid',
    function() {
      // expect failure with default callback
      expect(function() { dds.topicGetName(0); }).to.throw(Error);
    });
  /* end of topicGetName tests */

  /* end of topic tests */

  /* write tests */
  it('write writes a message successfully', function() {
    var desc = dds.topicDescriptorCreate(
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    );
    var top = dds.topicCreate(dp, desc, sampleTopicName);
    var wr = dds.writerCreate(dp, top).handle;

    var sampleJSObj = { userID: 100, message: 200 };
    var data = typeSupport.copyin(sampleJSObj);
    var status = dds.write(wr, data);

    expect(status).to.not.be.a('null');
  });

  it('write fails with invalid writer (first argument)', function() {
    var sampleJSObj = { userID: 1, message: 2 };
    var data = typeSupport.copyin(sampleJSObj);
    // expect failure. FFI throws an error here
    expect(function() { dds.write(0, data); })
      .to.throw(TypeError);
  });

  /*
  it('writeTs writes with a timestamp', function() {
    let sampleJSObj = { userID: 1, message: 2 };
    let data = typeSupport.copyin(sampleJSObj);
    let tstamp =
  }); */

  /* end of write tests */

  /* read and take tests */
  it('can read 10 messages successfully', function() {
    var sampleDesc = dds.topicDescriptorCreate(
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    );
    var topic = dds.topicCreate(dp, sampleDesc, sampleTopicName);
    var wr = dds.writerCreate(dp, topic).handle;
    var rd = dds.readerCreate(dp, topic).handle;

    // write 10 messages
    for (let i = 0; i < 10; i++) {
      let sampleJSObj = { userID: i, message: 100 + i };
      let data = typeSupport.copyin(sampleJSObj);
      dds.write(wr, data);
    }

    // read our messages into an array
    var readArray = dds.read(rd, 10, typeSupport.getRefType());
    expect(readArray.length).to.equal(10);
    for (let i = 0; i < 10; i++) {
      expect(readArray[i].sample.userID).to.equal(i);
      expect(readArray[i].sample.message).to.equal(100 + i);
    }
  });

  /* read and take tests */


  it('can take 10 messages successfully', function() {
    var sampleDesc = dds.topicDescriptorCreate(
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    );
    var topic = dds.topicCreate(dp, sampleDesc, sampleTopicName);
    var wr = dds.writerCreate(dp, topic).handle;
    var rd = dds.readerCreate(dp, topic).handle;

    // write 10 messages
    for (let i = 0; i < 10; i++) {
      let sampleJSObj = { userID: i, message: 100 + i };
      let data = typeSupport.copyin(sampleJSObj);
      dds.write(wr, data);
    }

    // read our messages into an array
    var readArray = dds.take(rd, 10, typeSupport.getRefType());
    expect(readArray.length).to.equal(10);
    for (let i = 0; i < 10; i++) {
      expect(readArray[i].sample.userID).to.equal(i);
      expect(readArray[i].sample.message).to.equal(100 + i);
    }
  });

  it('can take 10 messages successfully with condition', function() {
    var sampleDesc = dds.topicDescriptorCreate(
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    );
    var topic = dds.topicCreate(dp, sampleDesc, sampleTopicName);
    var wr = dds.writerCreate(dp, topic).handle;
    var rd = dds.readerCreate(dp, topic).handle;

    // write 10 messages
    for (let i = 0; i < 10; i++) {
      var sampleJSObj = { userID: i, message: 100 + i };
      var data = typeSupport.copyin(sampleJSObj);
      dds.write(wr, data);
    }

    // read our messages into an array
    var readArray = dds.takeCond(
      rd,
      10,
      typeSupport.getRefType(),
      dds.readConditionCreate(rd, 127)
    );
    expect(readArray.length).to.equal(10);
    for (let i = 0; i < 10; i++) {
      expect(readArray[i].sample.userID).to.equal(i);
      expect(readArray[i].sample.message).to.equal(100 + i);
    }

  });


  it('read fails to read with invalid arguments', function() {
    // expect failure with default callback
    expect(function() { dds.read(0, 0, 0); }).to.throw(TypeError);

    var pvoid = ref.refType(ref.types.void);
    expect(function() {
      dds.read(ref.alloc(pvoid), 10, typeSupport.getRefType());
    }).to.throw(ddserr.DDSError).with
      .property('ddsErrCode').to.be.within(1, 12);
  });

  it('readCond fails to read with invalid arguments', function() {
    // expect failure with default callback
    expect(function() { dds.readCond(0, 0, 0, 0); }).to.throw(TypeError);

    var pvoid = ref.refType(ref.types.void);
    expect(function() {
      dds.readCond(ref.alloc(pvoid), 10, typeSupport.getRefType(),
        dds.guardConditionCreate());
    }).to.throw(ddserr.DDSError).with
      .property('ddsErrCode').to.be.within(1, 12);

  });

  it('takeCond fails to read with invalid arguments', function() {
    // expect failure with default callback
    expect(function() { dds.takeCond(0, 0, 0, 0); }).to.throw(TypeError);

    var pvoid = ref.refType(ref.types.void);
    expect(function() {
      dds.takeCond(
        ref.alloc(pvoid),
        10,
        typeSupport.getRefType(),
        dds.guardConditionCreate()
      );
    }).to.throw(ddserr.DDSError).with
      .property('ddsErrCode').to.be.within(1, 12);

  });

  it('take fails to read with invalid arguments', function() {
    var pvoid = ref.refType(ref.types.void);
    expect(function() {
      dds.take(
        ref.alloc(pvoid),
        10,
        typeSupport.getRefType()
      );
    }).to.throw(ddserr.DDSError).with
      .property('ddsErrCode').to.be.within(1, 12);

  });

  it('read, take, readCond, takeCond do not return the loan when they '
    + 'receive nothing', function() {
    var sampleDesc = dds.topicDescriptorCreate(
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    );
    var topic = dds.topicCreate(dp, sampleDesc, sampleTopicName);
    var rd = dds.readerCreate(dp, topic).handle;
    let cond = dds.readConditionCreate(rd, 127);

    expect(dds.read(rd, 1, typeSupport.getRefType())).to.not.be.null;
    expect(dds.take(rd, 1, typeSupport.getRefType())).to.not.be.null;
    expect(dds.readCond(rd, 1, typeSupport.getRefType(), cond)).to.not.be.null;
    expect(dds.takeCond(rd, 1, typeSupport.getRefType(), cond)).to.not.be.null;
  });
  /* end of read tests */

  it('free frees a topic descriptor successfully', function() {
    expect(function() {
      var desc = dds.topicDescriptorCreate(
        sampleTypeName,
        sampleTypeKey,
        sampleTopicXML
      );
      dds.free(desc);
    }).to.not.throw(Error);
  });

  it('free fails to free given an invalid pointer', function() {
    // expect failure with default callback
    expect(function() { dds.free(0); }).to.throw(TypeError);
  });

  it('participantCreate fails with invalid arguments',
    function() {
      this.timeout(10000);
      // we need 0 <= domainId <= 230
      // expect non-zero status to turn into an Error
      expect(function() { dds.participantCreate(231); })
        .to.throw(ddserr.DDSError).with
        .property('ddsErrCode').to.be.within(1, 12);
    });
});

describe('FFI interface to C99 - Waitsets', function() {
  var dp = null;
  var reader = null;
  var topic = null;
  // var typeSupport = null;

  before(function() {
    dp = dds.participantCreate();
    let sampleDesc = dds.topicDescriptorCreate(
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    );
    topic = dds.topicCreate(dp, sampleDesc, sampleTopicName);
    reader = dds.readerCreate(dp, topic).handle;
    /* typeSupport = new ddstopic.TypeSupport(
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    );*/
  });

  after(function(done) {
    this.timeout(SEC_TO_MILI(20));
    dds.entityDelete(dp, function(err, res) {
      expect(err).to.be.null;
      expect(res).to.be.null;
      done();
    });
  });

  it('Can create and delete a waitset', function() {
    // successfully create and delete a waitset
    var ws = dds.waitsetCreate();
    expect(ws).to.not.be.null;
    expect(dds.waitsetDelete(ws)).to.not.be.null;

    // expect deleting a random pointer to throw an error
    expect(function() { dds.waitsetDelete(null); })
      .to.throw(Error);
  });

  it('Can create and delete a read condition', function() {
    // create and delete as usual
    var cond = dds.readConditionCreate(reader, 127);
    expect(cond).to.not.be.null;
    expect(function() {
      dds.conditionDelete(cond);
    }).to.not.throw(Error);

    // try to create a read condition with invalid reader. expect error
    expect(function() {
      dds.readConditionCreate('invalid_reader', 127);
    }).to.throw(TypeError);

    // try to delete a string. expect to throw an error
    expect(function() {
      dds.conditionDelete('invalid_input');
    }).to.throw(Error);

  });

  it('Can create and delete a guard condition', function() {
    var cond = dds.guardConditionCreate();
    expect(cond).to.not.be.null;
  });

  it('Can trigger and reset a guard condition', function() {
    var cond = dds.guardConditionCreate();

    // trigger it and expect it to work
    dds.guardTrigger(cond);
    expect(dds.conditionTriggered(cond)).to.equal(true);

    // reset it and expect it to work
    dds.guardReset(cond);
    expect(dds.conditionTriggered(cond)).to.equal(false);

    // try to reset a string. expect it to fail
    expect(function() {
      dds.guardTrigger('invalid_cond');
    }).to.throw(Error);

    // try to reset a string. expect it to fail
    expect(function() {
      dds.guardReset('invalid_cond');
    }).to.throw(Error);

    // try to check the condition of a string. expect failure
    expect(function() {
      dds.conditionTriggered('invalid_cond');
    }).to.throw(Error);

  });

  it('Can attach and detach read conditions', function() {
    var readCond = dds.readConditionCreate(reader, 127);
    var ws = dds.waitsetCreate();

    expect(function() {
      dds.waitsetAttach(ws, readCond, readCond);
    }).to.not.throw(Error);

    expect(function() {
      dds.waitsetDetach(ws, readCond, readCond);
    }).to.not.throw(Error);

    // try to attach an invalid condition and get an error
    expect(function() {
      dds.waitsetAttach(ws, 'invalid_cond', ws);
    }).to.throw(TypeError);

    // try to attach a random pointer. expect to get a status error
    expect(function() {
      dds.waitsetAttach(ws, ref.alloc(pvoid), ws);
    }).to.throw(Error);

    // try to detach a condition that wasn't attached. expect error.
    expect(function() {
      var cond = dds.readConditionCreate(reader, 127);
      dds.waitsetDetach(ws, cond);
    }).to.throw(ddserr.DDSError).with
      .property('ddsErrCode').to.be.within(1, 12);

    // try to detach an invalid cond
    expect(function() {
      dds.waitsetDetach(ws, 'invalid_cond');
    }).to.throw(Error);

  });

  // OK
  it('Async waitset wait fails with invalid arguments', function(done) {
    // The error from FFI will get passed into our callback
    dds.waitsetWait('foo', 'foo', 'foo', 'foo', function(err, res) {
      expect(err).to.be.instanceof(TypeError);
      expect(res).to.be.undefined;
      done();
    });
  });

  it('Async waitset wait can time out', function(done) {
    let ws = dds.waitsetCreate();
    let cond = dds.guardConditionCreate();
    dds.waitsetAttach(ws, cond, cond);

    // when it times out, we will get a return value of 0
    // wait for 1s and timeout
    const attachedCondsBuf = Buffer.alloc(dds.pointerSize * 1);
    dds.waitsetWait(ws,
      1,
      attachedCondsBuf,
      Math.pow(10, 9),
      function(err, res) {
        expect(err).to.be.null;
        expect(res).to.equal(0);
        done();
      });
  });

  it('Async waitset wait can wait and unblock when '
    + 'condition is met', function(done) {
    let ws = dds.waitsetCreate();
    let cond = dds.guardConditionCreate();
    dds.guardTrigger(cond);
    dds.waitsetAttach(ws, cond, cond);

    // when it unblocks, err will be null and res will be the # of conditions
    // triggered
    const attachedCondsBuf = Buffer.alloc(dds.pointerSize * 1);
    dds.waitsetWait(ws,
      1,
      attachedCondsBuf,
      Math.pow(10, 9),
      function(err, res) {
        expect(err).to.be.null;
        expect(res).to.equal(1);
        done();
      });
  });

  // quick test -- fix later
  it('Can create a query condition', function() {
    expect(dds.queryConditionCreateSql(reader, 127, 'color = %0',
      ['BLUE', 'RED', 'GREEN'], 3)).to.not.be.null;

    expect(function() {
      dds.queryConditionCreateSql('invalid_arg', 127, 'name = %0', null, 1);
    }).to.throw(TypeError);

  });

  it('Can create a status condition', function() {
    let dp = dds.participantCreate();
    let rd = dds.readerCreate(dp, topic).handle;
    let cond = dds.statusCondition(rd);
    expect(cond).to.not.be.null;
    let ret = dds.enableStatus(rd, 1024); // 1024 = data_available
    expect(ret).to.be.a('number');
    expect(ret).to.equal(0);

    expect(function() {
      dds.enableStatus('foo', 9999);
    }).to.Throw(TypeError);

  });
});

xdescribe('Async dds_reader_wait_for_historical_data tests', function() {
  var reader = null;
  var writer = null;
  var dp = null;
  var typeSupport = null;

  // in order to have wait for historical get called properly, we must
  // make sure reader,writer and topic are created with transient qos
  before(function() {
    dp = dds.participantCreate();
    let sampleDesc = dds.topicDescriptorCreate(
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    );
    let tqos = ddsqos.QoS.topicDefault();
    tqos.durability = {kind: ddsqos.DurabilityKind.Transient};
    tqos.reliability = {kind: ddsqos.ReliabilityKind.Reliable};
    let c99tqos = tqos.asCQos();
    let topic = dds.topicCreate(dp, sampleDesc, sampleTopicName + '1',
      c99tqos);
    qosc99.qosDelete(c99tqos);

    let rqos = ddsqos.QoS.readerDefault();
    rqos.durability = {kind: ddsqos.DurabilityKind.Transient};
    rqos.reliability = {kind: ddsqos.ReliabilityKind.Reliable};
    let c99rqos = rqos.asCQos();
    reader = dds.readerCreate(dp, topic, c99rqos).handle;
    qosc99.qosDelete(c99rqos);

    let wqos = ddsqos.QoS.writerDefault();
    wqos.durability = {kind: ddsqos.DurabilityKind.Transient};
    wqos.reliability = {kind: ddsqos.ReliabilityKind.Reliable};
    let c99wqos = wqos.asCQos();
    writer = dds.writerCreate(dp, topic, c99wqos).handle;
    qosc99.qosDelete(c99wqos);

    typeSupport = new ddstopic.TypeSupport(
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    );
  });

  after(function(done) {
    this.timeout(SEC_TO_MILI(20));
    dds.entityDelete(dp, function(err, res) {
      expect(err).to.be.null;
      expect(res).to.be.null;
      done();
    });
  });

  it('readerWaitForHistoricalData fails with bad arguments',
    function(done) {
      dds.readerWaitForHistoricalData(reader, 'foo', function(err, res) {
        expect(err).to.be.instanceof(TypeError);
        expect(res).to.be.undefined;
        done();
      });
    });

  it('readerWaitForHistoricalData can timeout',
    function(done) {
      // let the writer write 10000 samples - this should take a bit of time to
      // wait for
      for (let i = 0; i < 10000; i++) {
        dds.write(writer, typeSupport.copyin({ userID: 0, message: 1 }));
      }
      dds.readerWaitForHistoricalData(reader, 1, function(err, res) {
        let error = new ddserr.DDSError(res,
          'async dds_wait_for_historical_data failed: ');
        expect(error).to.be.instanceof(ddserr.DDSError).with
          .property('ddsErrCode', 10 /* timeout */);
        expect(err).to.be.null;
        done();
      });
    });
});

describe('C99 tests for creating topics ', function() {
  let dp = null;

  before(function() {
    dp = dds.participantCreate();
  });

  after(function(done) {
    this.timeout(SEC_TO_MILI(20));
    dds.entityDelete(dp, function(err, res) {
      expect(err).to.be.null;
      expect(res).to.be.null;
      done();
    });
  });

  // OK
  it('topicDescriptorCreate works as expected ', function() {
    this.timeout(10000);

    // create the topic descriptor as expected
    expect(dds.topicDescriptorCreate(
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    )).to.not.be.null;

    // catch the FFI TypeError with cb
    expect(
      () => dds.topicDescriptorCreate(0, 0, 0)
    ).to.throw(TypeError);

  });
  // OK
  it('topicCreate works as expected ', function() {
    this.timeout(10000);

    // the descriptor and dp we will create the topic with
    let desc = dds.topicDescriptorCreate(
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    );


    // create the topic as expected
    expect(dds.topicCreate(dp, desc, sampleTopicName)).to.not.be.null;

    // catch the DDSError with cb
    expect(
      () => dds.topicCreate(ref.alloc(pvoid), desc, sampleTopicName)
    ).to.throw(ddserr.DDSError).with.property('ddsErrCode').to.be.within(1, 12);

    // catch the FFI error with cb
    expect(
      () => dds.topicCreate('foo', 'foo', 0)
    ).to.throw(TypeError);

  });
});


describe('C99 tests for creating and deleting entities ', function() {

  // OK
  it('Can create and delete participants', function(done) {
    this.timeout(SEC_TO_MILI(20));

    // create the dp as expected
    let dp = dds.participantCreate();
    expect(dp).to.not.be.null;

    // catch the DDSError with cb
    expect(
      () => dds.participantCreate(231)
    ).to.throw(ddserr.DDSError).with.property('ddsErrCode').to.be.within(1, 12);

    // catch the FFI TypeError with cb
    expect(
      () => dds.participantCreate('foo', 'foo', 'foo')
    ).to.throw(TypeError);

    // delete dp
    dds.entityDelete(dp, function(err, res) {
      expect(err).to.be.null;
      expect(res).to.be.null;
      done(); // this will happen last in this test
    });
  });

  // OK
  it('Can create publishers', function(done) {
    this.timeout(SEC_TO_MILI(20));

    // the dp we create the publisher on
    let dp = dds.participantCreate();

    // create the publisher as expected
    let pub = dds.publisherCreate(dp);
    expect(pub).to.not.be.null;

    // catch the DDSError with cb
    // pass in a random pointer to get DDSError
    expect(
      () => dds.publisherCreate(ref.alloc(pvoid))
    ).to.throw(ddserr.DDSError).with.property('ddsErrCode').to.be.within(1, 12);

    // catch the FFI TypeError with cb
    expect(
      () => dds.publisherCreate('foo')
    ).to.throw(TypeError);

    dds.entityDelete(dp, function(err, res) {
      expect(err).to.be.null;
      expect(res).to.be.null;
      done(); // this happens last
    });
  });

  it('Can create writers', function(done) {
    this.timeout(SEC_TO_MILI(20));

    // set up our entities
    let dp = dds.participantCreate();
    let pub = dds.publisherCreate(dp);
    let desc = dds.topicDescriptorCreate(
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    );
    let topic = dds.topicCreate(dp, desc, sampleTopicName);

    // create the writer as expected
    expect(dds.writerCreate(pub, topic)).to.not.be.null;

    // catch the DDSError with cb
    expect(
      () => dds.writerCreate(ref.alloc(pvoid), topic)
    ).to.throw(ddserr.DDSError).with.property('ddsErrCode').to.be.within(1, 12);

    // catch the FFI TypeError with cb
    expect(
      () => dds.writerCreate('foo', 'foo')
    ).to.throw(TypeError);

    dds.entityDelete(dp, function(err, res) {
      expect(err).to.be.null;
      expect(res).to.be.null;
      done();
    });
  });

  it('Can create subscribers', function(done) {
    this.timeout(SEC_TO_MILI(20));

    // set up our dp
    let dp = dds.participantCreate();

    // create the subscriber as expected
    expect(dds.subscriberCreate(dp)).to.not.be.null;

    // catch DDSError with cb
    expect(
      () => dds.subscriberCreate(ref.alloc(pvoid))
    ).to.throw(ddserr.DDSError).with.property('ddsErrCode').to.be.within(1, 12);

    // catch the FFI TypeError with cb
    expect(
      () => dds.subscriberCreate('foo')
    ).to.throw(TypeError);

    dds.entityDelete(dp, function(err, res) {
      expect(err).to.be.null;
      expect(res).to.be.null;
      done();
    });
  });

  it('Can create readers', function(done) {
    this.timeout(SEC_TO_MILI(20));

    // set up our entities
    let dp = dds.participantCreate();
    let sub = dds.subscriberCreate(dp);
    let desc = dds.topicDescriptorCreate(
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    );
    let topic = dds.topicCreate(dp, desc, sampleTopicName);

    // create the reader on sub as expected
    expect(dds.readerCreate(sub, topic)).to.not.be.null;

    // catch the DDSError with cb
    // pass in a random pointer to get DDSError
    expect(
      () => dds.readerCreate(ref.alloc(pvoid), topic)
    ).to.throw(ddserr.DDSError).with.property('ddsErrCode').to.be.within(1, 12);

    // catch the FFI TypeError with cb
    expect(
      () => dds.readerCreate('foo', 'foo')
    ).to.throw(TypeError);

    dds.entityDelete(dp, function(err, res) {
      expect(err).to.be.null;
      expect(res).to.be.null;
      done();
    });
  });

  it('topicDescriptorDelete works as expected ', function() {
    this.timeout(SEC_TO_MILI(20));

    // set up our descriptor
    let desc = dds.topicDescriptorCreate(
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    );

    // delete desc as expected
    expect(dds.topicDescriptorDelete(desc)).to.not.be.null;

    // get FFI type error with cb
    expect(
      () => dds.topicDescriptorDelete('foo')
    ).to.throw(TypeError);
  });

});

describe('FFI C99 - reading and writing ', function() {
  // these are the entities used in the tests
  // we init. them in before() and delete them in after()
  var dp = null;
  var sampleDesc = null;
  var topic = null;
  var wr = null;
  var rd = null;
  var typeSupport = null;

  before(function() {
    dp = dds.participantCreate();
    sampleDesc = dds.topicDescriptorCreate(sampleTypeName,
      sampleTypeKey, sampleTopicXML);
    topic = dds.topicCreate(dp, sampleDesc, sampleTopicName);
    wr = dds.writerCreate(dp, topic).handle;
    rd = dds.readerCreate(dp, topic).handle;
    typeSupport = new ddstopic.TypeSupport(
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    );
  });

  after(function(done) {
    this.timeout(SEC_TO_MILI(20));
    dds.topicDescriptorDelete(sampleDesc);
    dds.entityDelete(dp, function(err, res) {
      expect(err).to.be.null;
      expect(res).to.be.null;
      done();
    });
  });

  it('can read 10 messages successfully with condition', function() {
    // write 10 messages
    for (let i = 0; i < 10; i++) {
      let sampleJSObj = { userID: i, message: 100 + i };
      let data = typeSupport.copyin(sampleJSObj);
      dds.write(wr, data);
    }

    // read our messages into an array
    let readArray = dds.readCond(
      rd,
      10,
      typeSupport.getRefType(),
      dds.readConditionCreate(rd, 127)
    );

    expect(readArray.length).to.equal(10);
    for (let i = 0; i < 10; i++) {
      expect(readArray[i].sample.userID).to.equal(i);
      expect(readArray[i].sample.message).to.equal(100 + i);
    }
  });

  it('Can dispose an instance', function() {
    const sample = {userID: 11, message: 2};
    const data = typeSupport.copyin(sample);

    dds.write(wr, data);

    expect(dds.instanceDispose(wr, data)).to.equal(0);

    let dataSet = dds.read(rd, 1, typeSupport.getRefType());
    expect(dataSet.length).to.equal(1);
    expect(dataSet[0].info.instance_state).to
      .equal(32 /* 32 = not_alive_disposed */);
  });

  it('Can asyncronously dispose an instance', function(done) {
    const sample = {userID: 12, message: 2};
    const data = typeSupport.copyin(sample);

    dds.write(wr, data);

    dds.instanceDisposeAsync(wr, data, function(err, res) {
      expect(err).to.be.null;
      expect(res).to.equal(0);
      sleep.msleep(100);
      let dataSet = dds.read(rd, 1, typeSupport.getRefType());
      expect(dataSet.length).to.equal(1);
      expect(dataSet[0].info.instance_state).to
        .equal(32 /* 32 = not_alive_disposed */);
      done();
    });
  });

  it('Can dispose an instance with a timestamp', function() {
    const sample = {userID: 13, message: 0};
    const data = typeSupport.copyin(sample);
    const testTs = 1000;

    dds.write(wr, data);

    expect(dds.instanceDisposeTs(wr, data, testTs)).to.equal(0);

    let dataSet = dds.read(rd, 1, typeSupport.getRefType());
    expect(dataSet.length).to.equal(1);
    expect(dataSet[0].info.instance_state).to
      .equal(32 /* 32 = not_alive_disposed */);
    // expect(dataSet[0].info.source_timestamp).to.equal(testTs);
  });

  it('Can asyncronously dispose an instance with a timestamp', function(done) {
    const sample = {userID: 14, message: 0};
    const data = typeSupport.copyin(sample);

    dds.write(wr, data);

    dds.instanceDisposeTsAsync(wr, data, 100, function(err, res) {
      expect(err).to.be.null;
      expect(res).to.equal(0);
      sleep.msleep(100);
      let dataSet = dds.read(rd, 1, typeSupport.getRefType());
      expect(dataSet.length).to.equal(1);
      expect(dataSet[0].info.instance_state).to
        .equal(32 /* 32 = not_alive_disposed */);
      done();
    });
  });

  it('Can unregister an instance', function() {
    const sample = {userID: 15, message: 0};
    const data = typeSupport.copyin(sample);

    dds.write(wr, data);

    expect(dds.instanceUnregister(wr, data, 0 /* DDS_HANDLE_NIL */))
      .to.equal(0);
  });

  it('Can asyncronously unregister an instance', function(done) {
    const sample = {userID: 15, message: 0};
    const data = typeSupport.copyin(sample);

    dds.write(wr, data);

    dds.instanceUnregisterAsync(wr, data, 0 /* DDS_HANDLE_NIL */,
      function(err, res) {
        expect(err).to.be.null;
        expect(res).to.equal(0);
        done();
      });
  });

  it('Can unregister an instance with a timestamp', function() {
    const sample = {userID: 16, message: 0};
    const data = typeSupport.copyin(sample);

    dds.write(wr, data);

    expect(dds.instanceUnregisterTs(wr, data, 0 /* DDS_HANDLE_NIL */, 1))
      .to.equal(0);
  });

  it('Can asyncronously unregister an instance with a timestamp',
    function(done) {
      const sample = {userID: 17, message: 0};
      const data = typeSupport.copyin(sample);

      dds.write(wr, data);

      dds.instanceUnregisterTsAsync(wr, data, 0 /* DDS_HANDLE_NIL */, 1,
        function(err, res) {
          expect(err).to.be.null;
          expect(res).to.equal(0);
          done();
        });
    });

});

describe('Reading topic with string', function() {
  // these are the entities used in the tests
  // we init. them in before() and delete them in after()
  var dp = null;
  var sampleDesc = null;
  var topic = null;
  var writer = null;
  var reader = null;
  var typeSupport = null;

  const stringTopicXML = '<MetaData version="1.0.0">' +
    '<Module name="StringTopicData">' +
    '<Struct name="Msg">' +
    '<Member name="userID"><Long/></Member>' +
    '<Member name="message"><Long/></Member>' +
    '<Member name="stringField"><String/></Member>' +
    '</Struct>' +
    '</Module>' +
    '</MetaData>';

  before(function() {
    dp = dds.participantCreate();
    sampleDesc = dds.topicDescriptorCreate('StringTopicData::Msg',
      'stringField', stringTopicXML);
    topic = dds.topicCreate(dp, sampleDesc, 'StringTopic');
    writer = dds.writerCreate(dp, topic).handle;
    reader = dds.readerCreate(dp, topic).handle;
    typeSupport = new ddstopic.TypeSupport(
      'StringTopicData::Msg',
      'stringField',
      stringTopicXML
    );
  });

  after(function(done) {
    this.timeout(SEC_TO_MILI(20));
    dds.topicDescriptorDelete(sampleDesc);
    dds.entityDelete(dp, function(err, res) {
      expect(err).to.be.null;
      expect(res).to.be.null;
      done();
    });
  });

  it('Can read 10 messages of a topic with a string field', function() {
    // write 10 messages
    for (let i = 0; i < 10; i++) {
      let sampleJSObj = { userID: i, message: 2 * i, stringField: 'foo' + i };
      let data = typeSupport.copyin(sampleJSObj);
      dds.write(writer, data);
    }

    // read our messages into an array
    var readArray = dds.read(reader, 10, typeSupport.getRefType());
    expect(readArray.length).to.equal(10);
    for (let i = 0; i < 10; i++) {
      expect(readArray[i].sample.userID).to.equal(i);
      expect(readArray[i].sample.message).to.equal(2 * i);
      expect(readArray[i].sample.stringField).to.equal('foo' + i);
    }
  });
});

describe('FFI interface to DDS listeners', function() {

  var dp = null;

  before(function() {
    dp = dds.participantCreate();
  });

  after(function(done) {
    this.timeout(SEC_TO_MILI(20));
    dds.entityDelete(dp, function(err, res) {
      expect(err).to.be.null;
      expect(res).to.be.null;
      done();
    });
  });

  it('receives publication match status', function(done){
    this.timeout(SEC_TO_MILI(5));
    const topicName = sampleTopicName + topicNameInstanceCounter++;
    var desc = dds.topicDescriptorCreate(
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    );
    var t = dds.topicCreate(dp, desc, topicName);
    var writerListenerPair = dds.writerCreate(dp, t, null, {
      onPublicationMatched: function(entity, status) {
        expect(entity).to.be.deep.equals(writerListenerPair.handle);
        expect(status.currentCount).to.be.above(0);
        expect(status.currentCountChange).to.be.equal(1);
        done();
      }});
    // eslint-disable-next-line no-unused-vars
    const rd = dds.readerCreate(dp, t).handle;
  });
});

describe('statusRead/take/getEnabled', function() {
  var dp = null;

  before(function() {
    dp = dds.participantCreate();
  });

  after(function(done) {
    this.timeout(SEC_TO_MILI(20));
    dds.entityDelete(dp, function(err, res) {
      expect(err).to.be.null;
      expect(res).to.be.null;
      done();
    });
  });

  it('Can read a status from an entity', function() {
    expect(dds.statusRead(dp, 0)).to.equal(0);
    expect(() => dds.statusRead('foo', 'foo')).to.throw(TypeError);
  });

  it('Can take a status from an entity', function() {
    expect(dds.statusTake(dp, 0)).to.equal(0);
    expect(() => dds.statusTake('foo', 'foo')).to.throw(TypeError);
  });

  it('Can get the enabled statuses on an entity', function() {
    expect(dds.statusGetEnabled(dp)).to.be.a('number');
    expect(() => dds.statusGetEnabled('foo')).to.throw(TypeError);
  });

  it('Can get the changed statuses on an entity', function() {
    expect(dds.statusChanges(dp)).to.be.a('number');
    expect(() => dds.statusChanges('foo')).to.throw(TypeError);
  });

});

/**
 * C99 Builtin topic tests: Just get code coverage. Tests
 * for communicating with builtin entities will be in the dcps tests.
 */
describe('Builtin Topic unit tests', function() {
  var dp = null;

  before(function() {
    dp = dds.participantCreate();
  });

  it('Can get the builtin subscriber', function() {
    expect(dds.getBuiltinSubscriber(dp)).to.not.be.null;
  });

  it('Can get the builtin readers from a builtin subscriber', function() {
    let builtinSub = dds.getBuiltinSubscriber(dp);

    expect(dds.findDataReader(builtinSub, 'DCPSParticipant')).to.not.be.null;
    expect(dds.findDataReader(builtinSub, 'DCPSTopic')).to.not.be.null;
    expect(dds.findDataReader(builtinSub, 'DCPSPublication')).to.not.be.null;
    expect(dds.findDataReader(builtinSub, 'DCPSSubscription'))
      .to.not.be.null;
  });
});

describe('Communication status tests', function() {
  let dp = null;
  let topic = null;
  let writer = null;
  let reader = null;

  before(function() {
    dp = dds.participantCreate();

    const desc = dds.topicDescriptorCreate(
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    );
    topic = dds.topicCreate(dp, desc, 'SampleTopic');
    expect(topic).to.not.be.null;
    writer = dds.writerCreate(dp, topic).handle;
    expect(writer).to.not.be.null;
    reader = dds.readerCreate(dp, topic).handle;
    expect(reader).to.not.be.null;
  });

  after(function(done) {
    this.timeout(SEC_TO_MILI(20));
    dds.entityDelete(dp, function(err, res) {
      expect(err).to.be.null;
      expect(res).to.be.null;
      done();
    });
  });

  it('getInconsistentTopicStatus test', function() {
    const status = dds.getInconsistentTopicStatus(topic);
    expect(status.totalCount).to.be.a('number');
    expect(status.totalCountChange).to.be.a('number');
  });

  it('getPublicationMatchedStatus test', function() {
    const status = dds.getPublicationMatchedStatus(writer);
    expect(status.totalCount).to.be.a('number');
    expect(status.totalCountChange).to.be.a('number');
    expect(status.currentCount).to.be.a('number');
    expect(status.currentCountChange).to.be.a('number');
    expect(status.lastSubscriptionHandle).to.be.a('number');
  });

  it('getLivelinessLostStatus test', function() {
    const status = dds.getLivelinessLostStatus(writer);
    expect(status.totalCount).to.be.a('number');
    expect(status.totalCountChange).to.be.a('number');
  });

  it('getOfferedDeadlineMissedStatus test', function() {
    const status = dds.getOfferedDeadlineMissedStatus(writer);
    expect(status.totalCount).to.be.a('number');
    expect(status.totalCountChange).to.be.a('number');
    expect(status.lastInstanceHandle).to.be.a('number');
  });

  it('getOfferedIncompatibleQosStatus test', function() {
    const status = dds.getOfferedIncompatibleQosStatus(writer);
    expect(status.totalCount).to.be.a('number');
    expect(status.totalCountChange).to.be.a('number');
    expect(status.lastPolicyId).to.be.a('number');
  });

  it('getSubscriptionMatchedStatus test', function() {
    const status = dds.getSubscriptionMatchedStatus(reader);
    expect(status.totalCount).to.be.a('number');
    expect(status.totalCountChange).to.be.a('number');
    expect(status.currentCount).to.be.a('number');
    expect(status.currentCountChange).to.be.a('number');
    expect(status.lastPublicationHandle).to.be.a('number');
  });

  it('getLivelinessChangedStatus test', function() {
    const status = dds.getLivelinessChangedStatus(reader);
    expect(status.aliveCount).to.be.a('number');
    expect(status.notAliveCount).to.be.a('number');
    expect(status.aliveCountChange).to.be.a('number');
    expect(status.notAliveCountChange).to.be.a('number');
    expect(status.lastPublicationHandle).to.be.a('number');
  });

  it('getSampleRejectedStatus test', function() {
    const status = dds.getSampleRejectedStatus(reader);
    expect(status.totalCount).to.be.a('number');
    expect(status.totalCountChange).to.be.a('number');
    expect(status.lastReason).to.be.a('number');
    expect(status.lastInstanceHandle).to.be.a('number');
  });

  it('getSampleLostStatus test', function() {
    const status = dds.getSampleLostStatus(reader);
    expect(status.totalCount).to.be.a('number');
    expect(status.totalCountChange).to.be.a('number');
  });

  it('getRequestedDeadlineMissedStatus test', function() {
    const status = dds.getRequestedDeadlineMissedStatus(reader);
    expect(status.totalCount).to.be.a('number');
    expect(status.totalCountChange).to.be.a('number');
    expect(status.lastInstanceHandle).to.be.a('number');
  });

  it('getRequestedIncompatibleQosStatus test', function() {
    const status = dds.getRequestedIncompatibleQosStatus(reader);
    expect(status.totalCount).to.be.a('number');
    expect(status.totalCountChange).to.be.a('number');
    expect(status.lastPolicyId).to.be.a('number');
  });


});
