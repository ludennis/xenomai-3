/*
 *                         Vortex OpenSplice
 *
 *   This software and documentation are Copyright 2006 to 2019 ADLINK
 *   Technology Limited, its affiliated companies and licensors. All rights
 *   reserved.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

'use strict';
const ref = require('ref');
const cico = require('./cico');
const fs = require('fs');

const u_factory = require('./union_factory');
const Enum = require('enum');
const ET = require('elementtree');
ET.XML;
const { spawn } = require('child_process');

const _MODULE_TAG = 'Module';
const _TYPEDEF_TAG = 'TypeDef';
const _STRUCT_TAG = 'Struct';
const _MEMBER_TAG = 'Member';
const _ARRAY_TAG = 'Array';
const _SEQUENCE_TAG = 'Sequence';
const _TYPE_TAG = 'Type';
const _ENUM_TAG = 'Enum';
const _ELEMENT_TAG = 'Element';
const _UNION_TAG = 'Union';

const _NAME_ATTRIBUTE = 'name';
const _SIZE_ATTRIBUTE = 'size';
const _VALUE_ATTRIBUTE = 'value';

const _MODULE_SEPARATOR = '::';

const _ENUM_TYPE = ref.types.int32;

/* Disable line-length check while we declare external
 * dependencies with long URLs
 */
/* eslint-disable max-len */
/**
 * The built-in NodeJS JavaScript Promise class
 * @external Promise
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises
 *
 * @alias external:Promise
 */

/**
  * The build-in NodeJS JavaScript Map class
  * @external Map
  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
  *
  * @alias external:Map
  */

/* eslint-enable max-len */

/**
 * The description of an IDL type, used in
 * {@link module:vortexdds.Topic|Topic} creation.
 *
 * Instances are not directed created by users.
 * Rather, they are obtained by calling
 * {@link module:vortexdds.importIDL|
 * importIDL()}
 * and passed to
 * {@link module:vortexdds.Participant#createTopic|Participant.createTopic()}
 * are part of the DDS topic creation/registration process.
 * @alias module:vortexdds.TypeSupport
 */
class TypeSupport {

  /**
   * Internal use only. Construct a TypeSupport instance
   */
  constructor(typename, keys, xml) {

    this._reftype;
    this._typeMap = new Map();

    this._typename = typename;
    this._keys = keys;
    this._xml = xml;

    this._init();
  }

  _init(){
    // parse xml metadata
    this._processTopicDescriptor();

    // set reftype
    this._reftype = this._typeMap.get(this._typename);
  }

  getClass(fullClassName){
    return this._typeMap.get(fullClassName);
  }

  getRefType(){
    return this._reftype;
  }

  getTypename(){
    return this._typename;
  }

  getKeys(){
    return this._keys;
  }

  getXML(){
    return this._xml;
  }

  /**
   * The fully qualified IDL type name
   * @readonly
   * @type {string}
   */
  get typename() {
    return this._typename;
  }

  /**
   * A comma separated list of key fields for the type.
   * May be empty, indicating the type has no key.
   * @readonly
   * @type {string}
   */
  get keys() {
    return this._keys;
  }

  /**
   * The OpenSplice XML type descriptor of the IDL type.
   * @readonly
   * @type {string}
   */
  get descriptor() {
    return this._xml;
  }

  _processTopicDescriptor() {

    let rootTree = ET.parse(this._xml);
    let rootElement = rootTree.getroot();

    this._processTopicDescriptorElement(rootElement, '');

  }

  _processTopicDescriptorElement(element, module) {
    if (element.tag === 'MetaData'){

      for (let child of element.getchildren()){
        this._processTopicDescriptorElement(child, module);
      }

    } else if (element.tag === _MODULE_TAG) {

      let newModule = element.attrib[_NAME_ATTRIBUTE];
      if (module !== null && module !== ''){
        newModule = module + _MODULE_SEPARATOR + newModule;
      }
      for (let child of element.getchildren()){
        this._processTopicDescriptorElement(child, newModule);
      }

    } else if (element.tag === _ENUM_TAG) {

      this._processEnumElement(element, module);

    } else if (element.tag === _TYPEDEF_TAG) {

      this._processTypeDefElement(element, module);

    } else if (element.tag === _STRUCT_TAG) {

      this._processStructElement(element, module);

    } else if (element.tag === _UNION_TAG) {

      this._processUnionElement(element, module);
    }
  };

  _processEnumElement(element, module){

    let enumJSOjb = {};
    let key = element.attrib[_NAME_ATTRIBUTE];
    let anEnum;

    if (module != null && module !== ''){
      key = module + _MODULE_SEPARATOR + key;
    }

    // iterate through enum children
    for (let child of element.getchildren()){
      if (child.tag === _ELEMENT_TAG){
        let enumLiteralName = child.attrib[_NAME_ATTRIBUTE];
        let enumLiteralValue = child.attrib[_VALUE_ATTRIBUTE];
        enumJSOjb[enumLiteralName] = parseInt(enumLiteralValue, 10);
      }
    }

    anEnum = new Enum(enumJSOjb);
    this._typeMap.set(key, anEnum);
  }

  _processTypeDefElement(element, module){

    let key = element.attrib[_NAME_ATTRIBUTE];
    let child = element.getItem(0);

    if (module != null && module !== ''){
      key = module + _MODULE_SEPARATOR + key;
    }

    if (child.tag === _TYPE_TAG){
      let name = child.attrib[_NAME_ATTRIBUTE];
      let referenceType;
      if ((!name.includes(_MODULE_SEPARATOR))
        && (module != null)
        && module !== ''){
        name = module + _MODULE_SEPARATOR + name;
      }
      referenceType = this._typeMap.get(name);
      this._typeMap.set(key, referenceType);

    } else if (child.tag === _SEQUENCE_TAG){
      let memberType = this._getSequenceType(child, module);
      this._typeMap.set(key, memberType);

    } else if (child.tag === _ARRAY_TAG){
      // TODO test
      let memberType = this._getArrayType(child, module);
      this._typeMap.set(key, memberType);

    } else {
      // primitive types
      let primitiveType = this._getPrimitiveRefTypeFor(child.tag);
      this._typeMap.set(key, primitiveType);
    }

  }

  _processStructElement(element, module){

    let jsObj = {};
    let key = element.attrib[_NAME_ATTRIBUTE];

    if (module != null && module !== ''){
      key = module + _MODULE_SEPARATOR + key;
    }

    // iterate through struct children
    for (let child of element.getchildren()){
      if (child.tag !== _MEMBER_TAG){
        continue;
      }

      let memberName = child.attrib[_NAME_ATTRIBUTE];
      let memberType = null;

      // Handle inner struct types
      if (child.getItem(0).tag === _TYPE_TAG){
        let typeName = child.getItem(0).attrib[_NAME_ATTRIBUTE];

        if ((module !== null)
          && (module !== '')
          && (!typeName.includes(_MODULE_SEPARATOR))){
          typeName = module + _MODULE_SEPARATOR + typeName;
        }

        // If typeName starts with ::, strip out
        if (typeName.startsWith(_MODULE_SEPARATOR)) {
          typeName = typeName.substring(2);
        }

        let referenceType = this._typeMap.get(typeName);
        if (referenceType instanceof Enum){
          memberType = _ENUM_TYPE;
        } else {
          memberType = referenceType;
        }

      } else if (child.getItem(0).tag === _ARRAY_TAG){
        let arrayElement = child.getItem(0);
        memberType = this._getArrayType(arrayElement, module);

      } else if (child.getItem(0).tag === _SEQUENCE_TAG){
        let seqElement = child.getItem(0);
        memberType = this._getSequenceType(seqElement, module);

      } else if (child.getItem(0).tag != null){
        memberType = this._getPrimitiveRefTypeFor(child.getItem(0).tag);
      }

      jsObj[memberName] = memberType;

    }
    // using json object as argument,
    // create new cico.Type class
    let cicoType = new cico.Type(jsObj);
    this._typeMap.set(key, cicoType);

  }

  _processUnionElement(element, module){
    let key = element.attrib[_NAME_ATTRIBUTE];
    if (module != null && module !== ''){
      key = module + _MODULE_SEPARATOR + key;
    }

    let union = u_factory.generateUnionClass(element, module, this);
    this._typeMap.set(key, union);
  }

  _getPrimitiveArrayType(element, length){
    let type = this._getPrimitiveRefTypeFor(element);
    return new cico.Array(type, length);
  }

  _getArrayType(arrayElement, module){

    let arrayType;

    let size = arrayElement.attrib[_SIZE_ATTRIBUTE];
    let length = parseInt(size, 10);
    let arrayTypeElement = arrayElement.getItem(0);

    if (arrayTypeElement.tag === _TYPE_TAG){
      let typeName = arrayTypeElement.attrib[_NAME_ATTRIBUTE];
      if ((module !== null)
          && (module !== '')
          && (!typeName.includes(_MODULE_SEPARATOR))){
        typeName = module + _MODULE_SEPARATOR + typeName;
      }
      let referenceType = this._typeMap.get(typeName);
      if (referenceType instanceof Enum){
        arrayType = new cico.Array(_ENUM_TYPE, length);
      } else {
        arrayType = new cico.Array(referenceType, length);
      }
    } else if (arrayTypeElement.tag === _SEQUENCE_TAG){
      let sType = this._getSequenceType(arrayTypeElement, module);
      arrayType = new cico.Array(sType, length);

    } else if (arrayTypeElement.tag === _ARRAY_TAG){
      let childArray = this._getArrayType(arrayTypeElement, module);
      arrayType = new cico.Array(childArray, length);

    } else {
      // type is a primitive ex. long
      arrayType = this._getPrimitiveArrayType(
        arrayTypeElement.tag,
        length
      );
    }

    return arrayType;

  }

  _getSequenceType(sElement, module){
    let sType;
    let size = sElement.attrib[_SIZE_ATTRIBUTE];
    let length = 0;
    if (size !== undefined){
      length = parseInt(size, 10);
    }

    let seqTypeElement = sElement.getItem(0);
    if (seqTypeElement.tag === _TYPE_TAG){
      // TODO  handle array types
      let typeName = seqTypeElement.attrib[_NAME_ATTRIBUTE];
      if ((module !== null)
        && (module !== '')
        && (!typeName.includes(_MODULE_SEPARATOR))){
        typeName = module + _MODULE_SEPARATOR + typeName;
      }
      let referenceType = this._typeMap.get(typeName);
      if (referenceType instanceof Enum){
        sType = new cico.Sequence(_ENUM_TYPE, length);
      } else {
        sType = new cico.Sequence(referenceType, length);
      }
    } else {
      // type is a primitive ex. long
      let sequenceType =
          this._getPrimitiveRefTypeFor(seqTypeElement.tag);
      sType = new cico.Sequence(sequenceType, length);
    }

    return sType;
  }

  _getPrimitiveRefTypeFor(idlTypeString){

    let refType;
    let typeString = idlTypeString.toLowerCase();

    switch (typeString) {
      case 'char':
        refType = ref.types.int8;
        break;
      case 'octet':
        refType = ref.types.uint8;
        break;
      case 'short':
        refType = ref.types.int16;
        break;
      case 'ushort':
        refType = ref.types.uint16;
        break;
      case 'long':
        refType = ref.types.int32;
        break;
      case 'ulong':
        refType = ref.types.uint32;
        break;
      case 'longlong':
        refType = ref.types.int64;
        break;
      case 'ulonglong':
        refType = ref.types.uint64;
        break;
      case 'float':
        refType = ref.types.float;
        break;
      case 'double':
        refType = ref.types.double;
        break;
      case 'string':
        refType = ref.types.CString;
        break;
      case 'boolean':
        refType = ref.types.bool;
        break;
      default:
        refType = ref.types.int32;
    }

    return refType;
  }

  copyin(jsobj) {
    return this._reftype.copyin(jsobj);
  }

  copyout(buf) {
    return this._reftype.copyout(buf);
  }

};

module.exports.TypeSupport = TypeSupport;

/**
  * Given an absolute path to an idl file,
  * processes the idl file using IDLPP and
  * return
  * {@link module:vortexdds.TypeSupport}
  * information on the processed types.
  *
  * This function executes asynchronously and
  * returns a {@link external:Promise|Promise}
  * to which you can attach callbacks in order
  * to handle the returned IDL type information.
  *
  * When the returned Promise resolves, its value is
  * a {@link external:Map|Map} whose key values
  * are fully-qualified IDL type names, and whose
  * entries are
  * {@link module:vortexdds.TypeSupport} objects.
  *
  * The function processes the IDL file as follows:
  * - attempt to find an xml file (a cached IDLPP result)
  * beside the idl file to parse the cached data.
  * - if the xml file is not found, IDLPP is called to process
  * the idl file.
  * - a TypeSupport object is created for
  * each topic in the IDL file and is added to a Map.
  * - a {@link external:Map|Map} entry is created
  * with key being the full topic name, and the value
  * being a
  * {@link module:vortexdds.TypeSupport|TypeSupport}
  * object.
  * - once all IDL types are processed, the
  * Promise is resolved with the generated
  * {@link external:Map|Map}.
  *
  * IDLPP is unavailable on OpenSplice RTS builds. So if you are
  * deploying your application onto that machine, you need to
  * invoke the "compile-idl" script (provided by the Node.js DCPS
  * API) from an environment where IDLPP is available.
  * Please refer to the OpenSplice Node.js DCPS API Guide's
  * "Compile IDL file into XML document" section for detailed information.
  *
  * @param {string} idlpath absolute path to idl file
  * @returns {external:Promise<external:Map<string,
  * module:vortexdds.TypeSupport>>}
  *
  * @example
  * // print all data types defined in an IDL file
  * const dds = require('vortexdds');
  * dds.importIDL('/home/adlink/myidl.idl')
  * .then(map => {
  *   console.log('Declared IDL types');
  *   for(const typename of map.keys()) {
  *     console.log(' type: ', typename);
  *   }
  * })
  * .catch(err => {
  *   console.log('IDL parsing error', err);
  * });
  *
  * @example
  * // register a topic...
  * const dds = require('vortexdds');
  * const dp = dds.Participant();
  * dds.importIDL('/home/adlink/myidl.idl')
  * .then(map => {
  *   console.log('Declared IDL types');
  *   const topic = dp.createTopic('MyTopic',
  *     map.get('mymod::MyType'));
  *   // ... do other processing ...
  * })
  * .catch(err => {
  *   console.log('IDL parsing error', err);
  * })
  * .then(_ => {
  *   // cleanup, no matter what
  *   dp.delete();
  * });
  *
  * @alias module:vortexdds.importIDL
  */
module.exports.importIDL = function importIDL(idlPath){

  const promise = new Promise(function(resolve, reject) {
    // try to read idlPath + '.xml', a cached IDLPP result
    fs.readFile(idlPath + '.xml', (err, data) => {

      var result = '';

      if (err) {
        // No, didn't find the file, spawn idlpp...
        const childProcess = spawn('idlpp', ['-l', 'pythondesc', idlPath]);

        childProcess.stdout.on('data', function(data) {
          result += data.toString();
        });

        childProcess.stderr.on('data', function(data) {
          result += data.toString();
        });

        childProcess.on('close', function(code) {
          if (code !== 0){
            reject(new Error(result));
          }
          // check for evaluation header, which is problematic
          const evalHeaderRE = /[^\n]*EVALUATION VERSION\r?\n/;
          if (evalHeaderRE.test(result)) {
            result = result.replace(evalHeaderRE, '');
          }
          let typeSupportMap = processIDLPP_XML(result);
          resolve(typeSupportMap);
        });

      } else {
        // read the idl file from the cache, parse it
        let typeSupportMap = processIDLPP_XML(data.toString('binary'));
        resolve(typeSupportMap);
      }

    });
  });

  return promise;
};

/**
  * An alias for {module:vortexdds.importIDL}.
  * @deprecated Use {@link module:vortexdds.importIDL}
  * @alias module:vortexdds.getTopicTypeSupportsForIDL
  */
module.exports.getTopicTypeSupportsForIDL = module.exports.importIDL;

function processIDLPP_XML(idlppXML){

  let typeSupportMap = new Map();
  let etree;

  try {
    etree = ET.parse(idlppXML);
  } catch (error){
    return typeSupportMap;
  }

  let topictypeArray = etree.findall('topictype');
  for (let i = 0; i < topictypeArray.length; i++) {
    let typeSupport = processTopicTypeElement(topictypeArray[i]);
    typeSupportMap.set(typeSupport.getTypename(), typeSupport);
  }

  return typeSupportMap;

};

function processTopicTypeElement(topictype){

  const typeName = topictype.findtext('id');
  const keys = topictype.findtext('keys');
  const xml = topictype.findtext('descriptor');

  const typeSupport = new TypeSupport(typeName, keys, xml);

  return typeSupport;

};
