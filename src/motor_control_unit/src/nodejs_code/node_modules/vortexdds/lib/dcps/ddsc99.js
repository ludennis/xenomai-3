/*
 *                         Vortex OpenSplice
 *
 *   This software and documentation are Copyright 2006 to 2019 ADLINK
 *   Technology Limited, its affiliated companies and licensors. All rights
 *   reserved.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

'use strict';

/**
 * ddsc99 for Node.js
 * @module ddsc99
 */


const ffi = require('ffi');
const ref = require('ref');
const StructType = require('ref-struct');
const ddserr = require('./ddserr');
const libs = require('./libs');

//  DDS constants used in this file
const DDS_DOMAIN_DEFAULT = 0x7fffffff;
// const DDS_RETCODE_TIMEOUT = 10;

// use in write_ts
const dds_time_t = ref.types.int64;

//  Special types used in C functions
//  general rule: pX means pointer to X
const pvoid = ref.refType(ref.types.void); // = void *

//  general dds types
const dds_entity_t = pvoid;
const pdds_entity_t = ref.refType(dds_entity_t);
const dds_domainid_t = ref.types.uint32;
const dds_duration_t = ref.types.int64;

// size of pointer
// this should be 4 on 32 bit machines, 8 on 64 bit machines
const pointerSize = ref.NULL_POINTER.buffer.byteLength;
module.exports.pointerSize = pointerSize;

// dds qos types
const dds_qos_t = ref.types.void;
const pdds_qos_t = ref.refType(dds_qos_t);

const dds_instance_handle_t = ref.types.uint64;

// dds topic types
const dds_topic_descriptor_t = pvoid;
const pdds_topic_descriptor_t = ref.refType(dds_topic_descriptor_t);

// Status structs for listeners and get_xxx_status methods
const dds_inconsistent_topic_status_t = StructType({
  totalCount: ref.types.uint32,
  totalCountChange: ref.types.int32,
});
const dds_offered_deadline_missed_status_t = StructType({
  totalCount: ref.types.uint32,
  totalCountChange: ref.types.int32,
  lastInstanceHandle: dds_instance_handle_t,
});
const dds_offered_incompatible_qos_status_t = StructType({
  totalCount: ref.types.uint32,
  totalCountChange: ref.types.int32,
  lastPolicyId: ref.types.uint32,
});
const dds_liveliness_lost_status_t = StructType({
  totalCount: ref.types.uint32,
  totalCountChange: ref.types.int32,
});
const dds_publication_matched_status_t = StructType({
  totalCount: ref.types.uint32,
  totalCountChange: ref.types.int32,
  currentCount: ref.types.uint32,
  currentCountChange: ref.types.int32,
  lastSubscriptionHandle: dds_instance_handle_t,
});

const dds_subscription_matched_status_t = StructType({
  totalCount: ref.types.uint32,
  totalCountChange: ref.types.int32,
  currentCount: ref.types.uint32,
  currentCountChange: ref.types.int32,
  lastPublicationHandle: dds_instance_handle_t,
});

const dds_sample_lost_status_t = StructType({
  totalCount: ref.types.uint32,
  totalCountChange: ref.types.int32,
});

const dds_liveliness_changed_status_t = StructType({
  aliveCount: ref.types.uint32,
  notAliveCount: ref.types.uint32,
  aliveCountChange: ref.types.int32,
  notAliveCountChange: ref.types.int32,
  lastPublicationHandle: dds_instance_handle_t,
});

const dds_sample_rejected_status_t = StructType({
  totalCount: ref.types.uint32,
  totalCountChange: ref.types.int32,
  lastReason: ref.types.int32, // dds_sample_rejected_status_kind
  lastInstanceHandle: dds_instance_handle_t,
});

const dds_requested_incompatible_qos_status_t = StructType({
  totalCount: ref.types.uint32,
  totalCountChange: ref.types.int32,
  lastPolicyId: ref.types.uint32,
});

const dds_requested_deadline_missed_status_t = StructType({
  totalCount: ref.types.uint32,
  totalCountChange: ref.types.int32,
  lastInstanceHandle: dds_instance_handle_t,
});

function defaultMapEntity(entity) {
  return entity;
}

function callbackWrapper(StatusType, userCallback, mapEntityFn) {
  return function(entity, status) {
    if (StatusType !== null) {
      userCallback(mapEntityFn(entity), new StatusType(status).toObject());
    } else {
      userCallback(mapEntityFn(entity));
    }
  };
}

const DDS_INCONSISTENT_TOPIC_STATUS = 1;
const DDS_OFFERED_DEADLINE_MISSED_STATUS = 2;
const DDS_REQUESTED_DEADLINE_MISSED_STATUS = 4;
const DDS_OFFERED_INCOMPATIBLE_QOS_STATUS = 32;
const DDS_REQUESTED_INCOMPATIBLE_QOS_STATUS = 64;
const DDS_SAMPLE_LOST_STATUS = 128;
const DDS_SAMPLE_REJECTED_STATUS = 256;
const DDS_DATA_ON_READERS_STATUS = 512;
const DDS_DATA_AVAILABLE_STATUS = 1024;
const DDS_LIVELINESS_LOST_STATUS = 2048;
const DDS_LIVELINESS_CHANGED_STATUS = 4096;
const DDS_PUBLICATION_MATCHED_STATUS = 8192;
const DDS_SUBSCRIPTION_MATCHED_STATUS = 16384;

const listenerStatusFlags = {
  onInconsistentTopic: DDS_INCONSISTENT_TOPIC_STATUS,
  onOfferedDeadlineMissed: DDS_OFFERED_DEADLINE_MISSED_STATUS,
  on_requested_deadline_missed: DDS_REQUESTED_DEADLINE_MISSED_STATUS,
  onOfferedIncompatibleQos: DDS_OFFERED_INCOMPATIBLE_QOS_STATUS,
  on_requested_incompatible_qos: DDS_REQUESTED_INCOMPATIBLE_QOS_STATUS,
  on_sample_lost: DDS_SAMPLE_LOST_STATUS,
  on_sample_rejected: DDS_SAMPLE_REJECTED_STATUS,
  on_data_on_readers: DDS_DATA_ON_READERS_STATUS,
  on_data_available: DDS_DATA_AVAILABLE_STATUS,
  onLivelinessLost: DDS_LIVELINESS_LOST_STATUS,
  on_liveliness_changed: DDS_LIVELINESS_CHANGED_STATUS,
  onPublicationMatched: DDS_PUBLICATION_MATCHED_STATUS,
  on_subscription_matched: DDS_SUBSCRIPTION_MATCHED_STATUS,
};

const listenerArgTypes = {
  onOfferedDeadlineMissed: dds_offered_deadline_missed_status_t,
  onOfferedIncompatibleQos: dds_offered_incompatible_qos_status_t,
  onLivelinessLost: dds_liveliness_lost_status_t,
  onPublicationMatched: dds_publication_matched_status_t,
  onRequestedDeadlineMissed: dds_requested_deadline_missed_status_t,
  onRequestedIncompatibleQos: dds_requested_incompatible_qos_status_t,
  onSampleRejected: dds_sample_rejected_status_t,
  onLivelinessChanged: dds_liveliness_changed_status_t,
  onDataAvailable: null,
  onSubscriptionMatched: dds_subscription_matched_status_t,
  onSampleLost: dds_sample_lost_status_t,
};

// listener structs methods
const dds_topiclistener_t = StructType({
  onInconsistentTopic: ffi.Function('void', [
    dds_entity_t,
    ref.refType(dds_inconsistent_topic_status_t),
  ]),
});

const dds_writerlistener_t = StructType({
  onOfferedDeadlineMissed: ffi.Function('void', [
    dds_entity_t,
    ref.refType(dds_offered_deadline_missed_status_t),
  ]),
  onOfferedIncompatibleQos: ffi.Function('void', [
    dds_entity_t,
    ref.refType(dds_offered_incompatible_qos_status_t),
  ]),
  onLivelinessLost: ffi.Function('void', [
    dds_entity_t,
    ref.refType(dds_liveliness_lost_status_t),
  ]),
  onPublicationMatched: ffi.Function('void', [
    dds_entity_t,
    ref.refType(dds_publication_matched_status_t),
  ]),
});

const dds_readerlistener_t = StructType({
  onRequestedDeadlineMissed: ffi.Function('void', [
    dds_entity_t,
    ref.refType(dds_requested_deadline_missed_status_t),
  ]),
  onRequestedIncompatibleQos: ffi.Function('void', [
    dds_entity_t,
    ref.refType(dds_requested_incompatible_qos_status_t),
  ]),
  onSampleRejected: ffi.Function('void', [
    dds_entity_t,
    ref.refType(dds_sample_rejected_status_t),
  ]),
  onLivelinessChanged: ffi.Function('void', [
    dds_entity_t,
    ref.refType(dds_liveliness_changed_status_t),
  ]),
  onDataAvailable: ffi.Function('void', [
    dds_entity_t,
  ]),
  onSubscriptionMatched: ffi.Function('void', [
    dds_entity_t,
    ref.refType(dds_subscription_matched_status_t),
  ]),
  onSampleLost: ffi.Function('void', [
    dds_entity_t,
    ref.refType(dds_sample_lost_status_t),
  ]),
});

// dds listener types
const pdds_participantlistener_t = pvoid;
// const dds_topiclistener_t = pvoid;
const pdds_topic_listener_t = ref.refType(dds_topiclistener_t);
const dds_publisherlistener_t = pvoid;
// const dds_writerlistener_t = pvoid;
const pdds_writerlistener_t = ref.refType(dds_writerlistener_t);
// for reader listener. may be removed later
const pdds_readerlistener_t = ref.refType(dds_readerlistener_t);

// dds waitset and condition types
const dds_waitset_t = pvoid;
const dds_condition_t = pvoid;
const pdds_condition_t = ref.refType(dds_condition_t);
const dds_attach_t = pvoid;
const dds_condition_seq = StructType({
  length: ref.types.uint32,
  buffer: pdds_condition_t,
  release: ref.types.int8,
});
const pdds_condition_seq = ref.refType(dds_condition_seq);

// used in dds_read, dds_take
const dds_sample_info_t = StructType({
  sample_state: ref.types.int32,
  view_state: ref.types.int32,
  instance_state: ref.types.int32,
  valid_data: ref.types.int8,
  source_timestamp: ref.types.int64,
  instance_handle: ref.types.uint64,
  publication_handle: ref.types.uint64,
  disposed_generation_count: ref.types.uint32,
  no_writers_generation_count: ref.types.uint32,
  sample_rank: ref.types.uint32,
  generation_rank: ref.types.uint32,
  absolute_generation_rank: ref.types.uint32,
  reception_timestamp: ref.types.int64,
});

// Bindings for libdcpsc99.so
const c99_bindings = {

  dds_topic_descriptor_create: [pdds_topic_descriptor_t, [
    ref.types.CString,
    ref.types.CString,
    ref.types.CString,
  ]],

  dds_topic_descriptor_delete: ['void', [
    pdds_topic_listener_t,
  ]],

  dds_participant_create: ['int', [
    pdds_entity_t,
    dds_domainid_t, // this is a uint32
    pdds_qos_t,
    pdds_participantlistener_t]],

  dds_entity_delete: ['void', [
    dds_entity_t]],

  dds_topic_create: ['int', [
    dds_entity_t,
    pdds_entity_t,
    pdds_topic_descriptor_t,
    ref.types.CString,
    pdds_qos_t,
    pdds_topic_listener_t]],

  dds_publisher_create: ['int', [
    dds_entity_t,
    pdds_entity_t,
    pdds_qos_t,
    dds_publisherlistener_t]],

  dds_writer_create: ['int', [
    dds_entity_t,
    pdds_entity_t,
    dds_entity_t,
    pdds_qos_t,
    pdds_writerlistener_t]],

  dds_subscriber_create: ['int', [
    dds_entity_t,
    pdds_entity_t,
    pdds_qos_t,
    pvoid,
  ]],

  dds_reader_create: ['int', [
    dds_entity_t,
    pdds_entity_t,
    dds_entity_t,
    pvoid,
    pdds_readerlistener_t,
  ]],

  dds_write: ['int', [
    dds_entity_t,
    pvoid]],

  dds_write_ts: ['int', [
    dds_entity_t,
    pvoid,
    dds_time_t,
  ]],

  dds_read: ['int', [
    dds_entity_t,
    'pointer',
    ref.types.uint32,
    'pointer',
    ref.types.uint32,
  ]],

  dds_take: ['int', [
    dds_entity_t,
    'pointer',
    ref.types.uint32,
    'pointer',
    ref.types.uint32,
  ]],

  dds_return_loan: ['void', [
    dds_entity_t,
    'pointer',
    ref.types.uint32,
  ]],

  dds_free: ['void', [
    pvoid,
  ]],

  dds_topic_find: [dds_entity_t, [
    dds_entity_t,
    ref.types.CString,
  ]],

  dds_topic_get_name: [ref.types.CString, [
    dds_entity_t,
  ]],

  dds_topic_get_metadescriptor: [ref.types.CString, [
    dds_entity_t,
  ]],

  dds_topic_get_keylist: [ref.types.CString, [
    dds_entity_t,
  ]],

  dds_topic_get_type_name: [ref.types.CString, [
    dds_entity_t,
  ]],

  dds_waitset_create: [dds_waitset_t, [],
  ],

  dds_waitset_delete: [ref.types.int, [
    dds_waitset_t,
  ]],

  dds_readcondition_create: [dds_condition_t, [
    dds_entity_t,
    ref.types.uint32,
  ]],

  dds_waitset_attach: [ref.types.int, [
    dds_waitset_t,
    dds_condition_t,
    dds_attach_t,
  ]],

  dds_waitset_detach: [ref.types.int, [
    dds_waitset_t,
    dds_condition_t,
  ]],

  dds_waitset_get_conditions: [ref.types.void, [
    dds_waitset_t,
    pdds_condition_seq,
  ]],

  dds_waitset_wait: [ref.types.int, [
    dds_waitset_t,
    'pointer',
    ref.types.size_t,
    dds_duration_t,
  ]],

  dds_guardcondition_create: [dds_condition_t, [
  ]],

  dds_guard_trigger: [ref.types.void, [
    dds_condition_t,
  ]],

  dds_guard_reset: [ref.types.void, [
    dds_condition_t,
  ]],

  dds_condition_triggered: [ref.types.int8, [
    dds_condition_t,
  ]],

  dds_condition_delete: [ref.types.void, [
    dds_condition_t,
  ]],

  dds_querycondition_create_sql: [dds_condition_t, [
    dds_entity_t,
    ref.types.uint32,
    ref.types.CString,
    'pointer',
    ref.types.uint32,
  ]],

  dds_read_cond: [ref.types.int, [dds_entity_t,
    'pointer',
    ref.types.uint32,
    'pointer',
    dds_condition_t,
  ]],

  dds_take_cond: [ref.types.int, [dds_entity_t,
    'pointer',
    ref.types.uint32,
    'pointer',
    dds_condition_t,
  ]],

  dds_reader_wait_for_historical_data: [ref.types.int, [
    dds_entity_t,
    dds_duration_t,
  ]],

  dds_statuscondition_get: [dds_condition_t, [
    dds_entity_t,
  ]],

  dds_status_set_enabled: [ref.types.int, [
    dds_entity_t,
    ref.types.uint32,
  ]],

  dds_status_take: [ref.types.int, [
    dds_entity_t,
    ref.refType(ref.types.uint32),
    ref.types.uint32,
  ]],

  dds_status_read: [ref.types.int, [
    dds_entity_t,
    ref.refType(ref.types.uint32),
    ref.types.uint32,
  ]],

  dds_status_get_enabled: [ref.types.uint32, [
    dds_entity_t,
  ]],

  dds_status_changes: [ref.types.uint32, [
    dds_entity_t,
  ]],

  dds_instance_register: [dds_instance_handle_t, [
    dds_entity_t,
    pvoid,
  ]],

  dds_instance_unregister: [ref.types.int, [
    dds_entity_t,
    pvoid,
    dds_instance_handle_t,
  ]],

  dds_instance_unregister_ts: [ref.types.int, [
    dds_entity_t,
    pvoid,
    dds_instance_handle_t,
    dds_time_t,
  ]],

  dds_instance_dispose: [ref.types.int, [
    dds_entity_t,
    pvoid,
  ]],

  dds_instance_dispose_ts: [ref.types.int, [
    dds_entity_t,
    pvoid,
    dds_time_t,
  ]],

  dds_time: [dds_time_t, []],

  dds_builtin_subscriber: [ref.types.int, [
    dds_entity_t,
    pdds_entity_t,
  ]],

  dds_datareader_find: [ref.types.int, [
    dds_entity_t,
    ref.types.CString,
    'pointer',
    ref.types.uint32,
  ]],

  dds_topic_get: [dds_entity_t, [
    dds_entity_t,
  ]],

  dds_get_inconsistent_topic_status: [ref.types.int, [
    dds_entity_t,
    ref.refType(dds_inconsistent_topic_status_t),
  ]],

  dds_get_publication_matched_status: [ref.types.int, [
    dds_entity_t,
    ref.refType(dds_publication_matched_status_t),
  ]],

  dds_get_liveliness_lost_status: [ref.types.int, [
    dds_entity_t,
    ref.refType(dds_liveliness_lost_status_t),
  ]],

  dds_get_offered_deadline_missed_status: [ref.types.int, [
    dds_entity_t,
    ref.refType(dds_offered_deadline_missed_status_t),
  ]],

  dds_get_offered_incompatible_qos_status: [ref.types.int, [
    dds_entity_t,
    ref.refType(dds_offered_incompatible_qos_status_t),
  ]],

  dds_get_subscription_matched_status: [ref.types.int, [
    dds_entity_t,
    ref.refType(dds_subscription_matched_status_t),
  ]],

  dds_get_liveliness_changed_status: [ref.types.int, [
    dds_entity_t,
    ref.refType(dds_liveliness_changed_status_t),
  ]],

  dds_get_sample_rejected_status: [ref.types.int, [
    dds_entity_t,
    ref.refType(dds_sample_rejected_status_t),
  ]],

  dds_get_sample_lost_status: [ref.types.int, [
    dds_entity_t,
    ref.refType(dds_sample_lost_status_t),
  ]],

  dds_get_requested_deadline_missed_status: [ref.types.int, [
    dds_entity_t,
    ref.refType(dds_requested_deadline_missed_status_t),
  ]],

  dds_get_requested_incompatible_qos_status: [ref.types.int, [
    dds_entity_t,
    ref.refType(dds_requested_incompatible_qos_status_t),
  ]],
};

const libdcpsc99 = ffi.Library(libs.libdds, c99_bindings);

// dds wrapper methods
/**
 * Wrapper for dds_participant_create. Returns a handle to a domain
 * particicpant on success.
 *
 * @param {number} domainId An integer 0 <= domainId <= 230
 * @param {pdds_qos_t} qos
 * @param {pdds_participantlistener_t} listener
 * @returns {dds_entity_t} participant handle on success
 * @throws {Error} on failure
 */
module.exports.participantCreate = function(
  domainId = DDS_DOMAIN_DEFAULT,
  qos = null,
  listener = null
) {
  const pEntity = ref.alloc(dds_entity_t);
  const status = libdcpsc99.dds_participant_create(
    pEntity,
    domainId,
    qos,
    listener
  );

  if (status !== 0) {
    throw new ddserr.DDSError(status,
      'Failed to create domain participant: ');
  }
  return pEntity.deref();
};

/**
 * Wrapper for dds_topic_descriptor_create. Returns a topic descriptor on
 * success.
 *
 * @param {string} typeName
 * @param {string} key
 * @param {string} xml
 * @returns {pdds_topic_descriptor_t} topic descriptor on success
 */
module.exports.topicDescriptorCreate = function(
  typeName,
  key,
  xml
) {
  return libdcpsc99.dds_topic_descriptor_create(typeName, key, xml);
};

/**
 * Wrapper for dds_topic_descriptor_delete.
 *
 * @param {pdds_topic_descriptor_t} topicDesc The topic_descriptor to free
 */
module.exports.topicDescriptorDelete = function(
  topicDesc
) {
  libdcpsc99.dds_topic_descriptor_delete(topicDesc);
};

/**
 *  Wrapper for dds_topic_create. Returns a handle to the topic on success.
 *
 *  @param {dds_entity_t} domainParticipant
 *  @param {string} topicName
 *  @param {pdds_topic_descriptor_t} descriptor
 *  @param {pdds_qos_t} qos
 *  @param {pdds_topic_listener_t} listener
 *  @param {mapEntityFn} Function called to map the C99 handle
 *  to another object of the caller's choice. Default returns
 *  this C99 handle.
 *  @returns {dds_entity_t} topic handle
 */
module.exports.topicCreate = function(
  domainParticipant,
  descriptor,
  topicName,
  qos = null,
  listener = null,
  mapEntityFn = defaultMapEntity,
) {

  const newTopic = ref.alloc(dds_entity_t);
  const linfo = createDDSListener(listener, dds_topiclistener_t, mapEntityFn);

  const status = libdcpsc99.dds_topic_create(
    domainParticipant,
    newTopic,
    descriptor,
    topicName,
    qos,
    linfo.l !== null ? linfo.l.ref() : null);

  if (status !== 0) {
    throw new ddserr.DDSError(status, 'Failed to create topic with name '
      + topicName + ' :');
  }

  return newTopic.deref();
};

/**
 * Wrapper for dds_writer_create. Returns a handle to a writer on success.
 *
 * @param {dds_entity_t} dpOrPub Our domain participant.
 * @param {dds_entity_t} topic
 * @param {pdds_qos_t} qos (default null)
 * @param {pdds_writerlistener_t} listener (default null)
 * @param {mapEntityFn} Function called to map the C99 handle
 * to another object of the caller's choice. Default returns
 * this C99 handle.
 * @returns {dds_entity_t|object} A handle the writer on success
 */
module.exports.writerCreate = function(
  dpOrPub,
  topic,
  qos = null,
  listener = null,
  mapEntityFn = defaultMapEntity,
) {
  let writer = null;
  let linfo = null;
  writer = ref.alloc(dds_entity_t);
  linfo = createDDSListener(
    listener,
    dds_writerlistener_t,
    mapEntityFn
  );
  const status = libdcpsc99.dds_writer_create(
    dpOrPub,
    writer,
    topic,
    qos,
    linfo.l ? linfo.l.ref() : null
  );

  if (status !== 0) {
    throw new ddserr.DDSError(status,
      'Failed to create writer: ');
  }
  setListenerFlags(writer.deref(), linfo.flags);

  return {handle: writer.deref(), linfo: linfo};
};

/**
 * Wrapper for dds_subscriber_create. Returns a a handle to a subscriber on
 * success.
 *
 * @param {dds_entity_t} participant domain participant
 * @param {pdds_qos_t} qos
 * @param {pdds_subscriberlistener_t} listener
 * @returns {dds_entity_t} subscriber handle on success
 * @throws {Error} on failure
 */
module.exports.subscriberCreate = function(
  participant,
  qos = null,
  listener = null
) {
  const subscriber = ref.alloc(dds_entity_t);
  const status = libdcpsc99.dds_subscriber_create(
    participant,
    subscriber,
    qos,
    listener
  );

  if (status !== 0) {
    throw new ddserr.DDSError(status,
      'Failed to create subscriber: ');
  }
  return subscriber.deref();
};

/**
 * Wrapper for dds_reader_create. Returns a handle to the reader on success.
 *
 * @param {dds_entity_t} sub
 * @param {dds_entity_t} topic
 * @param {pdds_qos_t} qos
 * @param {pdds_readerlistener_t} listener
 * @param {mapEntityFn} Function called to map the C99 handle
 * to another object of the caller's choice. Default returns
 * this C99 handle.
 * @returns {dds_entity_t|object} A handle the reader on success
 */
module.exports.readerCreate = function(
  ppOrSub,
  topic,
  qos = null,
  listener = null,
  mapEntityFn = defaultMapEntity
) {
  const reader = ref.alloc(dds_entity_t);
  const linfo = createDDSListener(listener, dds_readerlistener_t, mapEntityFn);

  const status = libdcpsc99.dds_reader_create(
    ppOrSub,
    reader,
    topic,
    qos,
    linfo.l ? linfo.l.ref() : null,
  );

  if (status !== 0) {
    throw new ddserr.DDSError(status, 'Failed to create reader: ');
  }
  setListenerFlags(reader.deref(), linfo.flags);

  return {handle: reader.deref(), linfo: linfo};
};

/**
 * Wrapper for dds_publisher_create. Returns a handle to a publisher on
 * success.
 *
 * @param {dds_entity_t} participant
 * @param {pdds_qos_t} qos
 * @param {pdds_publisherlistener_t} listener
 * @returns {dds_entity_t} publisher handle on success
 * @throws {Error} on failure
 */
module.exports.publisherCreate = function(
  participant,
  qos = null,
  listener = null
) {
  const publisher = ref.alloc(dds_entity_t);
  const status = libdcpsc99.dds_publisher_create(
    participant,
    publisher,
    qos,
    listener
  );

  if (status !== 0) {
    throw new ddserr.DDSError(status, 'Failed to create publisher: ');
  }
  return publisher.deref();
};


/**
 * Wrapper for dds_write. Returns 0 on success.
 *
 * Example: If we are writing on the Msg topic type, then we would write as
 * dds.write(writer, {userID: 1, message:2 }).
 *
 * @param {dds_entity_t} writer
 * @param {object} buf
 * @returns {number} 0 on success
 * @throws {Error} on failure
 */
module.exports.write = function(
  writer,
  buf
) {
  const status = libdcpsc99.dds_write(writer, buf);

  if (status !== 0) {
    throw new ddserr.DDSError(status, 'Failed to write: ');
  }
  return status;
};

/**
 * Asynchronous wrapper for dds_write.
 *
 * @param {dds_entity_t} writer
 * @param {object} buf data to write
 */
module.exports.writeAsync = function(
  writer,
  buf,
  cb
) {
  libdcpsc99.dds_write.async(writer, buf, cb);
};

/**
 * Wrapper for dds_write_ts.
 *
 * @param {dds_entity_t} wr The writer we are writing with
 * @param {pvoid} buf The data we are writing
 * @param {dds_time_t} tstamp The timestamp we are writing the sample with
 * @returns {number} 0 on success.
 * @throws {ddserr.DDSError} On failure
 */
module.exports.writeTs = function(
  writer,
  buf,
  tstamp
) {
  const status = libdcpsc99.dds_write_ts(writer, buf, tstamp);

  if (status !== 0) {
    throw new ddserr.DDSError(status, 'Failed to write with timestamp: ');
  };
  return status;
};

/**
 * Asynchronous wrapper for dds_write_ts.
 *
 * @param {dds_entity_t} writer
 * @param {object} buf data to write
 * @param {number} tstamp timestamp to write with
 */
module.exports.writeTsAsync = function(
  writer,
  buf,
  tstamp,
  cb
) {
  libdcpsc99.dds_write_ts.async(writer, buf, tstamp, cb);
};

function setListenerFlags(entity, flags) {
  if (flags !== 0) {
    const status = libdcpsc99.dds_status_set_enabled(entity, flags);
    if (status !== 0) {
      throw new ddserr.DDSError(status,
        'Could not enable enable appropriate listener status: ');
    }
  }
}

function createDDSListener(listener, DDSListenerType, mapEntityFn) {
  const result = { l: null, flags: 0};
  if (listener !== null) {
    result.l = new DDSListenerType();
    for (const [f, v] of Object.entries(listener)) {
      if (f in result.l) {
        result.flags |= listenerStatusFlags[f];
        result.l[f] = callbackWrapper(listenerArgTypes[f], v, mapEntityFn);
      }
    }
  }
  return result;
}

function copyOutSamples(
  samplesBuf,
  infosBuf,
  topicStruct,
  status
) {

  let arrayOfPairs = [];
  for (let i = 0; i < status; i++) {
    const data = topicStruct.copyout(
      ref.readPointer(
        samplesBuf,
        i * pointerSize,
        topicStruct.size
      )
    );

    const infoRef = ref.reinterpret(
      infosBuf,
      dds_sample_info_t.size,
      i * dds_sample_info_t.size
    );
    const infoStruct = ref.get(infoRef, 0, dds_sample_info_t);
    const infoCopy = infoStruct.toObject();
    infoCopy.valid_data = (infoStruct.valid_data === 1);
    const pair = {
      sample: data,
      info: infoCopy,
    };

    arrayOfPairs.push(pair);
  }
  return arrayOfPairs;
}

/**
 * Wrapper for dds_read.
 *
 * @param {dds_entity_t} reader
 * @param {number} maxSamples maximum number of samples to be read
 * @param {object} topicStruct topic type
 * @returns {object}  array of pairs (sample[i], sample_info[i])}
 * @throws {Error} on failure
 */
module.exports.read = function(
  reader,
  maxSamples,
  topicStruct
) {
  const samplesBuf = Buffer.alloc(pointerSize * maxSamples);
  const infosBuf = Buffer.alloc(dds_sample_info_t.size * maxSamples);

  const status = libdcpsc99.dds_read(
    reader,
    samplesBuf,
    maxSamples,
    infosBuf,
    0
  ); // status is also the # of samples read

  if (status < 0) {
    throw new ddserr.DDSError(status, 'Failed to read: ');
  }

  const arrayOfPairs = copyOutSamples(
    samplesBuf,
    infosBuf,
    topicStruct,
    status
  );

  if (status > 0) {
    libdcpsc99.dds_return_loan(reader, samplesBuf, maxSamples);
  }
  return arrayOfPairs;

};

/**
 * Wrapper for dds_take.
 *
 * @param {dds_entity_t} reader
 * @param {number} maxSamples maximum number of samples to be read
 * @param {object} topicStruct topic type
 * @returns {object}  array of pairs (sample[i], sample_info[i])}
 * @throws {Error} on failure
 */
module.exports.take = function(
  reader,
  maxSamples,
  topicStruct
) {
  const samplesBuf = Buffer.alloc(pointerSize * maxSamples);
  const infosBuf = Buffer.alloc(dds_sample_info_t.size * maxSamples);

  const status = libdcpsc99.dds_take(
    reader,
    samplesBuf,
    maxSamples,
    infosBuf,
    0
  ); // status is also the # of samples read

  if (status < 0) {
    throw new ddserr.DDSError(status, 'Failed to take: ');
  }

  const arrayOfPairs = copyOutSamples(
    samplesBuf,
    infosBuf,
    topicStruct,
    status
  );

  if (status > 0) {
    libdcpsc99.dds_return_loan(reader, samplesBuf, maxSamples);
  }

  return arrayOfPairs;
};

/**
 * Wrapper for dds_read_cond.
 *
 * @param {dds_entity_t} reader
 * @param {number} maxSamples maximum number of samples to be read.
 * @param {object} topicStruct A ref-struct instance which indicates the topic
 * type.
 * @param {dds_condition_t} cond to read with
 * @returns {object}  array of pairs (sample[i], sample_info[i])}.
 * @throws {Error} on failure
 */
module.exports.readCond = function(
  reader,
  maxSamples,
  topicStruct,
  cond
) {
  const samplesBuf = Buffer.alloc(pointerSize * maxSamples);
  const infosBuf = Buffer.alloc(dds_sample_info_t.size * maxSamples);

  const status = libdcpsc99.dds_read_cond(
    reader,
    samplesBuf,
    maxSamples,
    infosBuf,
    cond
  ); // status is also the # of samples read

  if (status < 0) {
    throw new ddserr.DDSError(status, 'Failed to read with condition: ');
  }

  const arrayOfPairs = copyOutSamples(
    samplesBuf,
    infosBuf,
    topicStruct,
    status
  );

  if (status > 0) {
    libdcpsc99.dds_return_loan(reader, samplesBuf, maxSamples);
  }

  return arrayOfPairs;
};

/**
 * Wrapper for dds_take_cond.
 *
 * @param {dds_entity_t} reader
 * @param {number} maxSamples maximum number of samples to be read
 * @param {object} topicStruct topic type
 * @param {dds_condition_t} condition to read with
 * @returns {object}  array of pairs (sample[i], sample_info[i])}
 * @throws {Error} on failure
 */
module.exports.takeCond = function(
  reader,
  maxSamples,
  topicStruct,
  condition
) {
  const samplesBuf = Buffer.alloc(pointerSize * maxSamples);
  const infosBuf = Buffer.alloc(dds_sample_info_t.size * maxSamples);

  const status = libdcpsc99.dds_take_cond(
    reader,
    samplesBuf,
    maxSamples,
    infosBuf,
    condition
  ); // status is also the # of samples read

  if (status < 0) {
    throw new ddserr.DDSError(status, 'Failed to take with condition: ');
  }

  const arrayOfPairs = copyOutSamples(
    samplesBuf,
    infosBuf,
    topicStruct,
    status
  );

  if (status > 0) {
    libdcpsc99.dds_return_loan(reader, samplesBuf, maxSamples);
  }

  return arrayOfPairs;
};

/**
 * Wrapper for dds_entity_delete. Deletes the given entity.
 *
 * @param {dds_entity_t} entity entity handle
 * @returns {object}

 */
module.exports.entityDelete = function(
  entity,
  cb
) {
  // we have to delete entities asynchronously, otherwise we
  // get deadlocks if an entity, or one if its children
  // registers a listener that must be called before
  // deletion
  libdcpsc99.dds_entity_delete.async(entity, cb);
};

/**
 * Promisified wrapper for dds_entity_delete. Deletes the given entity.
 *
 * @param {dds_entity_t} entity entity handle
 * @return {Promise}
 */
module.exports.entityDeletePromise = function(
  entity
) {
  return new Promise(function(resolve, reject) {
    libdcpsc99.dds_entity_delete.async(entity, function(err, res) {
      if (err !== null) {
        reject(err);
      }
      resolve(res);
    });
  });
};

/**
 * Wrapper for dds_free. Frees the memory at ptr and returns nothing on success.
 *
 * @param {pvoid} ptr A pointer to allocated memory
 * @returns {object}
 */
module.exports.free = function(
  ptr
) {
  libdcpsc99.dds_free(ptr);
};

/**
 * Asynchronous wrapper for dds_topic_find.
 *
 * Calls c99 dds_topic_find asynchronously,
 * with a callback.
 *
 * In the callback, returns result of: topic handle
 * or NULL if not found.   Else error.
 *
 * @param {dds_entity_t} pp participant handle
 * @param {string} name topic name
 * @param {function} cb callback on completion
 */
module.exports.topicFind = function(
  pp,
  name,
  cb
) {
  libdcpsc99.dds_topic_find.async(pp, name, cb);
};

/**
 * Wrapper for dds_topic_get_name. Returns the topic name attached to a given
 * topic handle on success.
 *
 * @param {dds_entity_t} topic
 * @returns {string} topic name on success
 * @throws {Error} on failure
 */
module.exports.topicGetName = function(
  topic
) {
  const name = libdcpsc99.dds_topic_get_name(topic);

  if (name === null) {
    throw new Error('Failed to get topic name');
  }
  return name;
};

/**
 * Wrapper for dds_topic_get_metadescriptor. Returns the metadescriptor attached
 * to a given topic handle on success.
 *
 * @param {dds_entity_t} topic topic handle
 * @returns {string} topic metadescriptor on success
 * @throws {Error} on failure
 */
module.exports.topicGetMetadescriptor = function(
  topic
) {
  const meta = libdcpsc99.dds_topic_get_metadescriptor(topic);

  if (meta === null) {
    throw new Error('Failed to get topic metadescriptor');
  }
  return meta;
};

/**
 * Wrapper for dds_topic_get_type_name. Returns the type name attached to a
 * given topic handle on success.
 *
 * @param {dds_entity_t} topic topic handle
 * @returns {string} topic type name on success
 * @throws {Error} on failure
 */
module.exports.topicGetTypeName = function(
  topic
) {
  const typename = libdcpsc99.dds_topic_get_type_name(topic);

  if (typename === null) {
    throw new Error('Failed to get topic type name');
  }
  return typename;
};

/**
 * Wrapper for dds_topic_get_keylist. Returns the key list attached to a given
 * topic handle on success.
 *
 * @param {dds_entity_t} topic topic handle
 * @returns {string} keylist on success
 * @throws {Error} on failure
 */
module.exports.topicGetKeylist = function(
  topic
) {
  const keylist = libdcpsc99.dds_topic_get_keylist(topic);

  if (keylist === null) {
    throw new Error('Failed to get topic keylist');
  }
  return keylist;
};

/**
 * Wrapper for dds_waitset_create. Returns a pointer to a waitset.
 *
 * @returns {dds_waitset_t} Pointer to a waitset.
 */
module.exports.waitsetCreate = function() {
  return libdcpsc99.dds_waitset_create();
};

/**
 * Wrapper for dds_waitset_delete.
 *
 * @param {dds_waitset_t} pointer to a waitset
 * @throws {Error} on failure
 */
module.exports.waitsetDelete = function(
  ws
) {
  const status = libdcpsc99.dds_waitset_delete(ws);

  if (status !== 0) {
    throw new ddserr.DDSError(status, 'Failed to delete waitset: ');
  }

};

/** Wrapper for dds_readcondition_create. Returns a read condition object.
 *
 * @param {dds_entity_t} reader
 * @param {number} mask
 *
 */
module.exports.readConditionCreate = function(
  reader,
  mask
) {
  return libdcpsc99.dds_readcondition_create(reader, mask);
};

/**
 * Wrapper for dds_condition_delete.
 *
 * @param {dds_condition_t} condition
 */
module.exports.conditionDelete = function(
  condition
) {
  return libdcpsc99.dds_condition_delete(condition);
};

/**
 * Wrapper for dds_guardcondition_create. Returns a guard condition object.
 *
 * @returns {dds_condition_t}
 */
module.exports.guardConditionCreate = function() {
  return libdcpsc99.dds_guardcondition_create();
};

/**
 * Wrapper for dds_guard_trigger. Triggers the guard.
 *
 * @param {dds_condition_t} guard
 */
module.exports.guardTrigger = function(
  guard
) {
  return libdcpsc99.dds_guard_trigger(guard);
};

/**
 * Wrapper for dds_guard_reset. Resets the guard.
 *
 * @param {dds_condition_t} guard
 */
module.exports.guardReset = function(
  guard
) {
  return libdcpsc99.dds_guard_reset(guard);
};

/**
 * Wrapper for dds_condition_triggered.
 *
 * @param {dds_condition_t} condition
 * @returns {boolean}
 */
module.exports.conditionTriggered = function(
  condition
) {
  return (libdcpsc99.dds_condition_triggered(condition) === 1);
};

/**
 * Wrapper for dds_waitset_attach.
 *
 * @param {dds_waitset_t} ws
 * @param {dds_condition_t} condition
 * @param {dds_attach_t} attach
 * @throws {Error} on failure
 */
module.exports.waitsetAttach = function(
  ws,
  condition,
  attach
) {
  const status = libdcpsc99.dds_waitset_attach(ws, condition, attach);
  if (status !== 0) {
    throw new ddserr
      .DDSError(status, 'Failed to attach condition to waitset: ');
  }
  return status;
};

/**
 * Wrapper for dds_waitset_detach.
 *
 * @param {dds_waitset_t} ws
 * @param {dds_condition_t} condition
 * @returns {number} status on success
 * @throws {Error} on failure
 */
module.exports.waitsetDetach = function(
  ws,
  condition
) {
  const status = libdcpsc99.dds_waitset_detach(ws, condition);
  if (status !== 0) {
    throw new ddserr
      .DDSError(status, 'Failed to detach condition from waitset');
  }
  return status;
};

/**
 * Wrapper for dds_querycondition_create_sql.
 *
 * @param {dds_entity_t} reader
 * @param {number} mask
 * @param {string} expr - sql expression
 * @param {array} params - parameters in sql expression
 * @param {number} maxp - number of parameters
 * @returns {dds_condition_t} handle to the condition
 * @throws {Error} on failure
 */
module.exports.queryConditionCreateSql = function(
  reader,
  mask,
  expr,
  params,
  maxp
) {
  const paramArrayBuf = Buffer.alloc(ref.types.CString.size * maxp);

  for (let i = 0; i < maxp; i++) {
    ref.types.CString.set(
      paramArrayBuf,
      ref.types.CString.size * i,
      params[i]
    );
  }
  const cond = libdcpsc99.dds_querycondition_create_sql(
    reader,
    mask,
    expr,
    paramArrayBuf,
    maxp
  );
  if (cond.deref() !== null) {
    // -1 translates into an error of 1 in ddserr
    throw new ddserr
      .DDSError(-1, 'Failed to create querycondition with SQL expression: ');
  }
  return cond;

};

/**
 * Wrapper for dds_status_set_enable
 *
 * @param {dds_entity_t} e - entity handle
 * @param {number} status mask
 * @returns {number} 0 on success
 */
module.exports.enableStatus = function(
  e,
  stat
) {
  const status = libdcpsc99.dds_status_set_enabled(e, stat);
  if (status !== 0) {
    throw new ddserr.DDSError(status, 'dds_status_set_enabled failed: ');
  }
  return status;
};

/**
 * Wrapper for dds_statuscondition_get
 *
 * @param {dds_entity_t} e entity handle
 * @return {dds_condition_t}
 */
module.exports.statusCondition = function(
  e
) {
  return libdcpsc99.dds_statuscondition_get(e);
};

/**
 * Wrapper for dds_instance_register
 *
 * @param {dds_entity_t} wr writer handle
 * @param {object} data - serialized data
 * @returns {dds_instance_handle_t} instance handle or null if not allocated
 */
module.exports.instanceRegister = function(
  wr,
  data
) {
  return libdcpsc99.dds_instance_register(wr, data);
};

/**
 * Wrapper for dds_instance_unregister
 * @param {dds_entity_t} wr writer handle
 * @param {object} data serialized data
 * @param {dds_instance_handle_t} handle instance handle
 * @returns {number} 0 on success
 * @throws {Error} on failure
 */
module.exports.instanceUnregister = function(
  wr,
  data,
  handle
) {
  const status = libdcpsc99.dds_instance_unregister(wr, data, handle);
  if (status !== 0) {
    throw new ddserr.DDSError(status, 'Failed to unregister instance: ');
  }
  return status;
};

/**
 * Asyncronous wrapper for dds_instance_unregister.
 * @param {dds_entity_t} wr writer handle
 * @param {object} data serialized data
 * @param {dds_instance_handle_t} handle instance handle
 * @param {function} cb callback
 */
module.exports.instanceUnregisterAsync = function(
  wr,
  data,
  handle,
  cb
) {
  libdcpsc99.dds_instance_unregister.async(wr, data, handle, cb);
};

/**
 * Wrapper for dds_instance_unregister_ts.
 *
 * @param {dds_entity_t} wr
 * @param {Buffer} data
 * @param {dds_instance_handle_t} handle
 * @param {dds_time_t} tstamp
 */
module.exports.instanceUnregisterTs = function(
  wr,
  data,
  handle,
  tstamp
) {
  const status = libdcpsc99
    .dds_instance_unregister_ts(wr, data, handle, tstamp);
  if (status !== 0) {
    throw new ddserr
      .DDSError(status, 'Failed to unregister instanc with timestamp: ');
  }
  return status;
};

/**
 * Asyncronous wrapper for dds_instance_unregister_ts.
 *
 * @param {dds_entity_t} wr
 * @param {Buffer} data
 * @param {dds_instance_handle_t} handle
 * @param {dds_time_t} tstamp
 * @param {function} cb
 */
module.exports.instanceUnregisterTsAsync = function(
  wr,
  data,
  handle,
  tstamp,
  cb
) {
  libdcpsc99.dds_instance_unregister_ts.async(wr, data, handle, tstamp, cb);
};

/**
 * Asynchronous wrapper for dds_waitset_wait.
 *
 * Calls c99 dds_waitset_wait asynchronously,
 * with a callback.
 *
 * In the callback, returns result of : 0 on timeout,
 * else number of signaled waitset conditions
 *
 * @param {dds_waitset_t} waitset waitset handle
 * @param {number} numConds number of attached conditions
 * @param {Buffer} attachedCondsBuf  pointer to an array of attached_conditions
 * based on the conditions associated with a waitset (can be NULL)
 * @param {number} timeout reltimeout timeout value
 * associated with a waitset
 * @param {function} cb callback
 */
module.exports.waitsetWait = function(
  waitset,
  numConds,
  attachedCondsBuf,
  timeout,
  cb
) {
  libdcpsc99.dds_waitset_wait.async(
    waitset,
    attachedCondsBuf,
    numConds,
    timeout,
    cb);
};

/**
 * Wrapper for dds_status_read.
 * @param {dds_entity_t} entity entity handle
 * @param {number} mask
 * @returns
 * @throws {Error} on failure
 */
module.exports.statusRead = function(
  entity,
  mask
) {
  const statPointer = ref.alloc(ref.types.uint32);
  const status = libdcpsc99.dds_status_read(entity, statPointer, mask);

  if (status !== 0) {
    throw new ddserr.DDSError(status, 'dds_status_read failed ');
  }
  return statPointer.deref();
};

/**
 * Wrapper for dds_status_take.
 * @param {dds_entity_t} entity entity handle
 * @param {number} mask
 * @returns
 * @throws {Error} on failure
 */
module.exports.statusTake = function(
  entity,
  mask
) {
  const statPointer = ref.alloc(ref.types.uint32);
  const status = libdcpsc99.dds_status_take(entity, statPointer, mask);
  /* c99 api note: the above call does not seem to return a nonzero number
  when mask does not correspond to the entity */
  if (status !== 0) {
    throw new ddserr.DDSError(status, 'dds_status_read failed ');
  }
  return statPointer.deref();
};

/**
 * Asynchronous wrapper for
 * dds_reader_wait_for_historical_data.
 *
 * Calls c99 dds_topic_find asynchronously,
 * with a callback.
 *
 * In the callback, returns result of: 0 on success,
 * or a negative value to indicate error.
 *
 * @param {dds_entity} reader reader on which to wait
 * for historical data
 * @param {dds_duration_t} timeout (nanoseconds)
 * how long to wait for historical data before time out
 * @param {function} cb callback on completion
 */
module.exports.readerWaitForHistoricalData = function(
  reader,
  timeout,
  cb
) {
  libdcpsc99.dds_reader_wait_for_historical_data.async(
    reader,
    timeout,
    cb
  );
};

/**
 * Wrapper for dds_status_get_enabled.
 */
module.exports.statusGetEnabled = function(
  entity
) {
  return libdcpsc99.dds_status_get_enabled(entity);
};

/**
 * Wrapper for dds_status_changes.
 */
module.exports.statusChanges = function(
  entity
) {
  return libdcpsc99.dds_status_changes(entity);
};

/**
 * Wrapper for dds_instance_dispose.
 *
 * @param {dds_entity_t} writer
 * @param {Buffer} data serialized data
 * @returns {number} 0 on success, non-zero indicating failure
 */
module.exports.instanceDispose = function(
  writer,
  data
) {
  const status = libdcpsc99.dds_instance_dispose(writer, data);

  if (status !== 0) {
    throw new ddserr.DDSError(status, 'dds_instance_dispose failed: ');
  }
  return status;
};

/**
 * Asynchronous wrapper for dds_instance_dispose.
 *
 * @param {dds_entity_t} writer
 * @param {Buffer} data
 * @param {function} cb callback executed upon completion of
 * dds_instance_dispose
 */
module.exports.instanceDisposeAsync = function(
  writer,
  data,
  cb
) {
  libdcpsc99.dds_instance_dispose.async(writer, data, cb);
};

/**
 * Wrapper for dds_instance_dispose_ts.
 *
 * @param {dds_entity_t} writer
 * @param {Buffer} data
 * @param {dds_time_t} tstamp
 */
module.exports.instanceDisposeTs = function(
  writer,
  data,
  tstamp
) {
  const status = libdcpsc99.dds_instance_dispose_ts(writer, data, tstamp);

  if (status !== 0) {
    throw new ddserr.DDSError(status, 'dds_instance_dispose_ts failed:');
  }

  return status;
};

/**
 * Asyncronous wrapper for dds_instance_dispose_ts
 *
 * @param {dds_entity_t} writer
 * @param {Buffer} data
 * @param {dds_time_t} tstamp
 * @param {function} cb
 */
module.exports.instanceDisposeTsAsync = function(
  writer,
  data,
  tstamp,
  cb
) {
  libdcpsc99.dds_instance_dispose_ts.async(writer, data, tstamp, cb);
};

/**
 * Wrapper for dds_builtin_subscriber
 *
 * @param {dds_entity_t} dp
 */
module.exports.getBuiltinSubscriber = function(
  dp
) {
  let sub = ref.alloc(pdds_entity_t);
  let status = libdcpsc99.dds_builtin_subscriber(dp, sub);

  if (status !== 0) {
    throw new ddserr.DDSError(status, 'dds_builtin_subscriber failed:');
  }

  return sub.deref();
};

/**
 * Wrapper for dds_subscriber_find_datareader
 *
 * @param {dds_entity_t} sub
 * @param {string} topicName
 * @param {number} maxMatches
 */
module.exports.findDataReader = function(
  sub,
  topicName,
) {
  let readerPtr = ref.alloc(dds_entity_t);

  let status = libdcpsc99.dds_datareader_find(sub, topicName,
    readerPtr, 1);

  if (status < 0) {
    throw new ddserr.DDSError(status,
      'dds_subscriber_find_datareader failed:');
  }

  return readerPtr.deref();
};

/**
 * Wrapper for dds_get_topic
 *
 * @param {dds_entity_t} readerOrWriter
 * @returns {dds_entity_t}
 */
module.exports.getTopicFromEntity = function(
  readerOrWriter
) {
  return libdcpsc99.dds_topic_get(readerOrWriter);
};

/**
 * Wrapper for dds_get_inconsistent_topic_status
 *
 * @param {dds_entity_t} topic
 * @returns {dds_inconsistent_topic_status_t}
 */
module.exports.getInconsistentTopicStatus = function(topic) {

  const status = ref.alloc(dds_inconsistent_topic_status_t);
  const result = libdcpsc99.dds_get_inconsistent_topic_status(topic, status);

  if (result !== 0) {
    throw new ddserr.DDSError(
      result,
      'dds_get_inconsistent_topic_status failed '
    );
  }

  return status.deref().toObject();
};

/**
 * Wrapper for dds_get_publication_matched_status
 *
 * @param {dds_entity_t} writer
 * @returns {dds_publication_matched_status_t}
 */
module.exports.getPublicationMatchedStatus = function(writer) {

  const status = ref.alloc(dds_publication_matched_status_t);
  const result = libdcpsc99.dds_get_publication_matched_status(writer, status);

  if (result !== 0) {
    throw new ddserr.DDSError(
      result,
      'dds_get_publication_matched_status failed '
    );
  }

  return status.deref().toObject();
};

/**
 * Wrapper for dds_get_liveliness_lost_status
 *
 * @param {dds_entity_t} writer
 * @returns {dds_liveliness_lost_status_t}
 */
module.exports.getLivelinessLostStatus = function(writer) {

  const status = ref.alloc(dds_liveliness_lost_status_t);
  const result = libdcpsc99.dds_get_liveliness_lost_status(writer, status);

  if (result !== 0) {
    throw new ddserr.DDSError(
      result,
      'dds_get_liveliness_lost_status failed '
    );
  }

  return status.deref().toObject();
};

/**
 * Wrapper for dds_get_offered_deadline_missed_status
 *
 * @param {dds_entity_t} writer
 * @returns {dds_offered_deadline_missed_status_t}
 */
module.exports.getOfferedDeadlineMissedStatus = function(writer) {

  const status = ref.alloc(dds_offered_deadline_missed_status_t);
  const result =
    libdcpsc99.dds_get_offered_deadline_missed_status(writer, status);

  if (result !== 0) {
    throw new ddserr.DDSError(
      result,
      'dds_get_offered_deadline_missed_status failed '
    );
  }

  return status.deref().toObject();
};

/**
 * Wrapper for dds_get_offered_incompatible_qos_status
 *
 * @param {dds_entity_t} writer
 * @returns {dds_offered_incompatible_qos_status_t}
 */
module.exports.getOfferedIncompatibleQosStatus = function(writer) {

  const status = ref.alloc(dds_offered_incompatible_qos_status_t);
  const result =
    libdcpsc99.dds_get_offered_incompatible_qos_status(writer, status);

  if (result !== 0) {
    throw new ddserr.DDSError(
      result,
      'dds_get_offered_incompatible_qos_status failed '
    );
  }

  return status.deref().toObject();
};

/**
 * Wrapper for dds_get_subscription_matched_status
 *
 * @param {dds_entity_t} reader
 * @returns {dds_subscription_matched_status_t}
 */
module.exports.getSubscriptionMatchedStatus = function(reader) {

  const status = ref.alloc(dds_subscription_matched_status_t);
  const result = libdcpsc99.dds_get_subscription_matched_status(reader, status);

  if (result !== 0) {
    throw new ddserr.DDSError(
      result,
      'dds_get_subscription_matched_status failed '
    );
  }

  return status.deref().toObject();
};

/**
 * Wrapper for dds_get_liveliness_changed_status
 *
 * @param {dds_entity_t} reader
 * @returns {dds_liveliness_changed_status_t}
 */
module.exports.getLivelinessChangedStatus = function(reader) {

  const status = ref.alloc(dds_liveliness_changed_status_t);
  const result = libdcpsc99.dds_get_liveliness_changed_status(reader, status);

  if (result !== 0) {
    throw new ddserr.DDSError(
      result,
      'dds_get_liveliness_changed_status failed '
    );
  }

  return status.deref().toObject();
};

/**
 * Wrapper for dds_get_sample_rejected_status
 *
 * @param {dds_entity_t} reader
 * @returns {dds_sample_rejected_status_t}
 */
module.exports.getSampleRejectedStatus = function(reader) {

  const status = ref.alloc(dds_sample_rejected_status_t);
  const result = libdcpsc99.dds_get_sample_rejected_status(reader, status);

  if (result !== 0) {
    throw new ddserr.DDSError(
      result,
      'dds_get_sample_rejected_status failed '
    );
  }

  return status.deref().toObject();
};

/**
 * Wrapper for dds_get_sample_lost_status
 *
 * @param {dds_entity_t} reader
 * @returns {dds_sample_lost_status_t}
 */
module.exports.getSampleLostStatus = function(reader) {

  const status = ref.alloc(dds_sample_lost_status_t);
  const result = libdcpsc99.dds_get_sample_lost_status(reader, status);

  if (result !== 0) {
    throw new ddserr.DDSError(
      result,
      'dds_get_sample_lost_status failed '
    );
  }

  return status.deref().toObject();
};

/**
 * Wrapper for dds_get_requested_deadline_missed_status
 *
 * @param {dds_entity_t} reader
 * @returns {dds_requested_deadline_missed_status_t}
 */
module.exports.getRequestedDeadlineMissedStatus = function(reader) {

  const status = ref.alloc(dds_requested_deadline_missed_status_t);
  const result =
    libdcpsc99.dds_get_requested_deadline_missed_status(reader, status);

  if (result !== 0) {
    throw new ddserr.DDSError(
      result,
      'dds_get_requested_deadline_missed_status failed '
    );
  }

  return status.deref().toObject();
};

/**
 * Wrapper for dds_get_requested_incompatible_qos_status
 *
 * @param {dds_entity_t} reader
 * @returns {dds_requested_incompatible_qos_status_t}
 */
module.exports.getRequestedIncompatibleQosStatus = function(reader) {

  const status = ref.alloc(dds_requested_incompatible_qos_status_t);
  const result =
    libdcpsc99.dds_get_requested_incompatible_qos_status(reader, status);

  if (result !== 0) {
    throw new ddserr.DDSError(
      result,
      'dds_get_requested_incompatible_qos_status failed '
    );
  }

  return status.deref().toObject();
};
