/*
 *                         Vortex OpenSplice
 *
 *   This software and documentation are Copyright 2006 to 2019 ADLINK
 *   Technology Limited, its affiliated companies and licensors. All rights
 *   reserved.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

'use strict';

/**
 * QoS for Node.js
 * @module qosc99
 */

const ffi = require('ffi');
const ref = require('ref');
const ddserr = require('./ddserr');
const libs = require('./libs');

//  Special types used in C functions
const pvoid = ref.refType(ref.types.void);
const ppvoid = ref.refType(pvoid);
const puint32 = ref.refType(ref.types.uint32);
const pint32 = ref.refType(ref.types.int32);
const pint64 = ref.refType(ref.types.int64);
const pbool = ref.refType(ref.types.bool);
const psize_t = ref.refType(ref.types.int32);
const pCString = ref.refType(ref.types.CString);
const ppCString = ref.refType(pCString);

// Selected types from qos.h
const dds_qos_t = ref.types.void;
const pdds_qos_t = ref.refType(dds_qos_t);

// Selected types from dds.h
const dds_entity_t = pvoid;
const pdds_entity_t = ref.refType(dds_entity_t);

// QoS bindings for libdcpsc99.so
const qos_bindings = {
  dds_qos_create: [pdds_qos_t, [
  ]],

  dds_qos_delete: ['void', [
    pdds_qos_t,
  ]],

  dds_qos_reset: ['void', [
    pdds_qos_t,
  ]],

  dds_free: ['void', [
    pvoid,
  ]],

  dds_qosprovider_create: ['int', [
    pdds_entity_t,
    ref.types.CString,
    ref.types.CString,
  ]],

  dds_qosprovider_get_participant_qos: ['int', [
    dds_entity_t,
    pdds_qos_t,
    ref.types.CString,
  ]],

  dds_qosprovider_get_topic_qos: ['int', [
    dds_entity_t,
    pdds_qos_t,
    ref.types.CString,
  ]],

  dds_qosprovider_get_subscriber_qos: ['int', [
    dds_entity_t,
    pdds_qos_t,
    ref.types.CString,
  ]],

  dds_qosprovider_get_reader_qos: ['int', [
    dds_entity_t,
    pdds_qos_t,
    ref.types.CString,
  ]],

  dds_qosprovider_get_writer_qos: ['int', [
    dds_entity_t,
    pdds_qos_t,
    ref.types.CString,
  ]],

  dds_qosprovider_get_publisher_qos: ['int', [
    dds_entity_t,
    pdds_qos_t,
    ref.types.CString,
  ]],

  dds_qos_get: ['void', [
    dds_entity_t,
    pdds_qos_t,
  ]],

  dds_get_default_participant_qos: ['void', [
    pdds_qos_t,
  ]],

  dds_get_default_topic_qos: ['void', [
    pdds_qos_t,
  ]],

  dds_get_default_publisher_qos: ['void', [
    pdds_qos_t,
  ]],

  dds_get_default_subscriber_qos: ['void', [
    pdds_qos_t,
  ]],

  dds_get_default_writer_qos: ['void', [
    pdds_qos_t,
  ]],

  dds_get_default_reader_qos: ['void', [
    pdds_qos_t,
  ]],

  dds_qget_userdata: ['void', [
    pdds_qos_t,
    ppvoid,
    psize_t,
  ]],

  dds_qget_topicdata: ['void', [
    pdds_qos_t,
    ppvoid,
    psize_t,
  ]],

  dds_qget_groupdata: ['void', [
    pdds_qos_t,
    ppvoid,
    psize_t,
  ]],

  dds_qget_durability: ['void', [
    pdds_qos_t,
    pint32,
  ]],

  dds_qget_history: ['void', [
    pdds_qos_t,
    pint32,
    pint32,
  ]],

  dds_qget_resource_limits: ['void', [
    pdds_qos_t,
    pint32,
    pint32,
    pint32,
  ]],

  dds_qget_presentation: ['void', [
    pdds_qos_t,
    pint32,
    pbool,
    pbool,
  ]],

  dds_qget_lifespan: ['void', [
    pdds_qos_t,
    pint64,
  ]],

  dds_qget_deadline: ['void', [
    pdds_qos_t,
    pint64,
  ]],

  dds_qget_latency_budget: ['void', [
    pdds_qos_t,
    pint64,
  ]],

  dds_qget_ownership: ['void', [
    pdds_qos_t,
    pint32,
  ]],

  dds_qget_ownership_strength: ['void', [
    pdds_qos_t,
    pint32,
  ]],

  dds_qget_liveliness: ['void', [
    pdds_qos_t,
    pint32,
    pint64,
  ]],

  dds_qget_time_based_filter: ['void', [
    pdds_qos_t,
    pint64,
  ]],

  dds_qget_partition: ['void', [
    pdds_qos_t,
    puint32,
    ppCString,
  ]],

  dds_qget_reliability: ['void', [
    pdds_qos_t,
    pint32,
    pint64,
  ]],

  dds_qget_transport_priority: ['void', [
    pdds_qos_t,
    pint32,
  ]],

  dds_qget_destination_order: ['void', [
    pdds_qos_t,
    pint32,
  ]],

  dds_qget_writer_data_lifecycle: ['void', [
    pdds_qos_t,
    pbool,
  ]],

  dds_qget_reader_data_lifecycle: ['void', [
    pdds_qos_t,
    pint64,
    pint64,
  ]],

  dds_qget_durability_service: ['void', [
    pdds_qos_t,
    pint64,
    pint32,
    pint32,
    pint32,
    pint32,
    pint32,
  ]],

  dds_qset_userdata: ['void', [
    pdds_qos_t,
    pvoid,
    ref.types.size_t,
  ]],

  dds_qset_topicdata: ['void', [
    pdds_qos_t,
    pvoid,
    ref.types.size_t,
  ]],

  dds_qset_groupdata: ['void', [
    pdds_qos_t,
    pvoid,
    ref.types.size_t,
  ]],

  dds_qset_durability: ['void', [
    pdds_qos_t,
    ref.types.int32,
  ]],

  dds_qset_history: ['void', [
    pdds_qos_t,
    ref.types.int32,
    ref.types.int32,
  ]],

  dds_qset_resource_limits: ['void', [
    pdds_qos_t,
    ref.types.int32,
    ref.types.int32,
    ref.types.int32,
  ]],

  dds_qset_presentation: ['void', [
    pdds_qos_t,
    ref.types.int32,
    ref.types.bool,
    ref.types.bool,
  ]],

  dds_qset_lifespan: ['void', [
    pdds_qos_t,
    ref.types.int64,
  ]],

  dds_qset_deadline: ['void', [
    pdds_qos_t,
    ref.types.int64,
  ]],

  dds_qset_latency_budget: ['void', [
    pdds_qos_t,
    ref.types.int64,
  ]],

  dds_qset_ownership: ['void', [
    pdds_qos_t,
    ref.types.int32,
  ]],

  dds_qset_ownership_strength: ['void', [
    pdds_qos_t,
    ref.types.int32,
  ]],

  dds_qset_liveliness: ['void', [
    pdds_qos_t,
    ref.types.int32,
    ref.types.int64,
  ]],

  dds_qset_time_based_filter: ['void', [
    pdds_qos_t,
    ref.types.int64,
  ]],

  dds_qset_partition: ['void', [
    pdds_qos_t,
    ref.types.uint32,
    'pointer',
  ]],

  dds_qset_reliability: ['void', [
    pdds_qos_t,
    ref.types.int32,
    ref.types.int64,
  ]],

  dds_qset_transport_priority: ['void', [
    pdds_qos_t,
    ref.types.int32,
  ]],

  dds_qset_destination_order: ['void', [
    pdds_qos_t,
    ref.types.int32,
  ]],

  dds_qset_writer_data_lifecycle: ['void', [
    pdds_qos_t,
    ref.types.bool,
  ]],

  dds_qset_reader_data_lifecycle: ['void', [
    pdds_qos_t,
    ref.types.int64,
    ref.types.int64,
  ]],

  dds_qset_durability_service: ['void', [
    pdds_qos_t,
    ref.types.int64,
    ref.types.int32,
    ref.types.int32,
    ref.types.int32,
    ref.types.int32,
    ref.types.int32,
  ]],
};

const libqos = ffi.Library(libs.libdds, qos_bindings);

// qos wrapper functions
/**
 * Wrapper for dds_qos_create.
 * Allocate memory and initializes to default values for qos
 *
 * @returns {pdds_qos_t|number} Returns a pointer to the
 * allocated memory for dds_qos_t structure, 0 if unsuccessful
*/
module.exports.qosCreate = function() {
  return libqos.dds_qos_create();
};

/**
 * Wrapper for dds_qos_delete.
 * Delete the memory allocated to qos.
 * The qos must be deleted once.
 * Calling the qosDelete() to delete an already
 * deleted qos can corrupt the memory.
 *
 * @param {pdds_qos_t} qos qos pointer to the structure
 */
module.exports.qosDelete = function(qos) {
  libqos.dds_qos_delete(qos);
};

/**
 * Wrapper for dds_qos_reset.
 * This operation results in resetting the qos structure
 * contents to default qos values.
 *
 * @param {pdds_qos_t} qos qos pointer to the structure
 */
module.exports.qosReset = function(qos) {
  libqos.dds_qos_reset(qos);
};

/**
 * Wrapper for dds_free
 * Delete the qos provider using dds_free
 *
 * @param {pvoid} qosProvider
 */

module.exports.qosProviderDelete = function(
  qosProvider,
) {
  libqos.dds_free(qosProvider);
};


/**
 * Wrapper for dds_qosprovider_create.
 * Create a dds qos provider using the uri and profile
 *
 * @param {string} uri
 * @param {string} profile
 * @returns {dds_entity_t} qos provider
 */
module.exports.qosProviderCreate = function(uri, profile) {

  const qp = ref.alloc(dds_entity_t);
  const status = libqos.dds_qosprovider_create(qp, uri, profile);

  if (status !== 0) {
    throw new ddserr.DDSError(status,
      'Failed to create qosprovider: ');
  }
  return qp.deref();
};

/**
 * Wrapper for dds_qosprovider_get_participant_qos.
 * Given the QoSProvider, retrieve the value of the domain participant qos.
 *
 * @param {dds_entity_t} qp
 * @param {pdds_qos_t} qos
 * @param {string} id
 */
module.exports.qosProviderGetParticipantQos = function(
  qp,
  qos,
  id = null
) {
  const status = libqos.dds_qosprovider_get_participant_qos(qp, qos, id);

  if (status !== 0) {
    throw new ddserr.DDSError(status,
      'Failed to get participant qos using qosprovider: ');
  }
};

/**
 * Wrapper for dds_qosprovider_get_topic_qos.
 * Given the QoSProvider, retrieve the value of the topic qos.
 *
 * @param {dds_entity_t} qp
 * @param {pdds_qos_t} qos
 * @param {string} id
 */
module.exports.qosProviderGetTopicQos = function(
  qp,
  qos,
  id = null
) {
  const status = libqos.dds_qosprovider_get_topic_qos(qp, qos, id);

  if (status !== 0) {
    throw new ddserr.DDSError(status,
      'Failed to get topic qos using qosprovider: ');
  }
};

/**
 * Wrapper for dds_qosprovider_get_publisher_qos.
 * Given the QoSProvider, retrieve the value of the publisher qos.
 *
 * @param {dds_entity_t} qp
 * @param {pdds_qos_t} qos
 * @param {string} id
 */
module.exports.qosProviderGetPublisherQos = function(
  qp,
  qos,
  id = null
) {
  const status = libqos.dds_qosprovider_get_publisher_qos(qp, qos, id);

  if (status !== 0) {
    throw new ddserr.DDSError(status,
      'Failed to get publisher qos using qosprovider: ');
  }
};

/**
 * Wrapper for dds_qosprovider_get_subscriber_qos.
 * Given the QoSProvider, retrieve the value of the subscriber qos.
 *
 * @param {dds_entity_t} qp
 * @param {pdds_qos_t} qos
 * @param {string} id
 */
module.exports.qosProviderGetSubscriberQos = function(
  qp,
  qos,
  id = null
) {
  const status = libqos.dds_qosprovider_get_subscriber_qos(
    qp,
    qos,
    id);

  if (status !== 0) {
    throw new ddserr.DDSError(status,
      'Failed to get subscriber qos using qosprovider: ');
  }
};

/**
 * Wrapper for dds_qosprovider_get_reader_qos.
 * Given the QoSProvider, retrieve the value of the reader qos.
 *
 * @param {dds_entity_t} qp
 * @param {pdds_qos_t} qos
 * @param {string} id
 */
module.exports.qosProviderGetReaderQos = function(
  qp,
  qos,
  id = null
) {
  const status = libqos.dds_qosprovider_get_reader_qos(qp, qos, id);

  if (status !== 0) {
    throw new ddserr.DDSError(status,
      'Failed to get reader qos using qosprovider: ');
  }
};

/**
 * Wrapper for dds_qosprovider_get_writer_qos.
 * Given the QoSProvider, retrieve the value of the writer qos.
 *
 * @param {dds_entity_t} qp
 * @param {pdds_qos_t} qos
 * @param {string} id
 */
module.exports.qosProviderGetWriterQos = function(
  qp,
  qos,
  id = null
) {
  const status = libqos.dds_qosprovider_get_writer_qos(qp, qos, id);

  if (status !== 0) {
    throw new ddserr.DDSError(status,
      'Failed to get writer qos using qosprovider: ');
  }
};

/**
 * Wrapper for dds_qos_get. Get the existing set of QoS policies
 * for the entity
 *
 * @param {dds_entity_t} entity
 * @param {pdds_qos_t} qos
 */
module.exports.qosGet = function(entity, qos) {
  libqos.dds_qos_get(entity, qos);
};

/**
 * Wrapper for dds_get_default_participant_qos.
 * Retrieves the default value of the domain participant qos.
 *
 * @param {pdds_qos_t} qos
 */
module.exports.defaultParticipantQos = function(qos) {
  libqos.dds_get_default_participant_qos(qos);
};

/**
 * Wrapper for dds_get_default_topic_qos.
 * Retrieves the default value of the topic qos.
 *
 * @param {pdds_qos_t} qos
 */
module.exports.defaultTopicQos = function(qos) {
  libqos.dds_get_default_topic_qos(qos);
};

/**
 * Wrapper for dds_get_default_publisher_qos.
 * Retrieves the default value of the publisher qos.
 *
 * @param {pdds_qos_t} qos
 */
module.exports.defaultPublisherQos = function(qos) {
  libqos.dds_get_default_publisher_qos(qos);
};

/**
 * Wrapper for dds_get_default_subscriber_qos.
 * Retrieves the default value of the subscriber qos.
 *
 * @param {pdds_qos_t} qos
 */
module.exports.defaultSubscriberQos = function(qos) {
  libqos.dds_get_default_subscriber_qos(qos);
};

/**
 * Wrapper for dds_get_default_writer_qos.
 * Retrieves the default value of the writer qos.
 *
 * @param {pdds_qos_t} qos
 */
module.exports.defaultWriterQos = function(qos) {
  libqos.dds_get_default_writer_qos(qos);
};

/**
 * Wrapper for dds_get_default_reader_qos.
 * Retrieves the default value of the reader qos.
 *
 * @param {pdds_qos_t} qos
 */
module.exports.defaultReaderQos = function(qos) {
  libqos.dds_get_default_reader_qos(qos);
};

/**
 * Wrapper for dds_qget_userdata.
 * Get the userdata policy.
 *
 * @param {pdds_qos_t} qos
 * @returns {Buffer}
 */
module.exports.getUserdata = function(qos) {
  const value = ref.alloc(pvoid);
  const size = ref.alloc(ref.types.size_t);
  libqos.dds_qget_userdata(qos, value, size);

  const pointer = ref.alloc('pointer', value.deref());
  const dataBuffer = ref.readPointer(pointer, 0, size.deref());
  return dataBuffer;
};

/**
 * Wrapper for dds_qget_topicdata.
 * Get the topicdata policy.
 *
 * @param {pdds_qos_t} qos
 * @returns {Buffer}
 */
module.exports.getTopicdata = function(qos) {
  const value = ref.alloc(pvoid);
  const size = ref.alloc(ref.types.size_t);
  libqos.dds_qget_topicdata(qos, value, size);

  const pointer = ref.alloc('pointer', value.deref());
  const dataBuffer = ref.readPointer(pointer, 0, size.deref());
  return dataBuffer;
};

/**
 * Wrapper for dds_qget_groupdata.
 * Get the groupdata policy.
 *
 * @param {pdds_qos_t} qos
 * @returns {Buffer}
 */
module.exports.getGroupdata = function(qos) {
  const value = ref.alloc(pvoid);
  const size = ref.alloc(ref.types.size_t);
  libqos.dds_qget_groupdata(qos, value, size);

  const pointer = ref.alloc('pointer', value.deref());
  const dataBuffer = ref.readPointer(pointer, 0, size.deref());
  return dataBuffer;
};

/**
 * Wrapper for dds_qget_durability.
 * Get the durability qos policy.
 *
 * @param {pdds_qos_t} qos
 * @returns {number} durability policy kind
 */
module.exports.getDurability = function(qos) {
  const kind = ref.alloc(ref.types.int32);
  libqos.dds_qget_durability(qos, kind);
  return kind.deref();
};

/**
 * Wrapper for dds_qget_history.
 * Get the history qos policy.
 *
 * @param {pdds_qos_t} qos
 * @returns {object} a javascript object {kind, depth}
 */
module.exports.getHistory = function(qos) {
  const kind = ref.alloc(ref.types.int32);
  const depth = ref.alloc(ref.types.int32);
  libqos.dds_qget_history(qos, kind, depth);

  return {
    kind: kind.deref(),
    depth: depth.deref(),
  };
};

/**
 * Wrapper for dds_qget_resource_limits.
 * Get the resource limits qos policy.
 *
 * @param {pdds_qos_t} qos
 * @returns {object} a javascript object {maxSamples, maxInstances,
 * maxSamplesPerInstance}
 */
module.exports.getResourceLimits = function(qos) {
  const maxSamples = ref.alloc(ref.types.int32);
  const maxInstances = ref.alloc(ref.types.int32);
  const maxSamplesPerInstance = ref.alloc(ref.types.int32);
  libqos.dds_qget_resource_limits(
    qos,
    maxSamples,
    maxInstances,
    maxSamplesPerInstance
  );

  return {
    maxSamples: maxSamples.deref(),
    maxInstances: maxInstances.deref(),
    maxSamplesPerInstance: maxSamplesPerInstance.deref(),
  };
};

/**
 * Wrapper for dds_qget_presentation.
 * Get the presentation qos policy.
 *
 * @param {pdds_qos_t} qos
 * @returns {object} a javascript object {accessScope,
 * coherentAccess, orderedAccess}
 */
module.exports.getPresentation = function(qos) {
  const accessScope = ref.alloc(ref.types.int32);
  const coherentAccess = ref.alloc(ref.types.bool);
  const orderedAccess = ref.alloc(ref.types.bool);
  libqos.dds_qget_presentation(
    qos,
    accessScope,
    coherentAccess,
    orderedAccess
  );

  return {
    accessScope: accessScope.deref(),
    coherentAccess: coherentAccess.deref(),
    orderedAccess: orderedAccess.deref(),
  };
};

/**
 * Wrapper for dds_qget_lifespan.
 * Get the lifespan qos policy.
 *
 * @param {pdds_qos_t} qos
 * @returns {number} lifespan duration
 */
module.exports.getLifespan = function(qos) {
  const lifespan = ref.alloc(ref.types.int64);
  libqos.dds_qget_lifespan(qos, lifespan);
  return lifespan.deref();
};

/**
 * Wrapper for dds_qget_deadline.
 * Get the deadline qos policy.
 *
 * @param {pdds_qos_t} qos
 * @returns {number} deadline
 */
module.exports.getDeadline = function(qos) {
  const deadline = ref.alloc(ref.types.int64);
  libqos.dds_qget_deadline(qos, deadline);
  return deadline.deref();
};

/**
 * Wrapper for dds_qget_latency_budget.
 * Get the latency budget qos policy.
 *
 * @param {pdds_qos_t} qos
 * @returns {number} latency budget duration
 */
module.exports.getLatencyBudget = function(qos) {
  const duration = ref.alloc(ref.types.int64);
  libqos.dds_qget_latency_budget(qos, duration);
  return duration.deref();
};

/**
 * Wrapper for dds_qget_ownership.
 * Get the ownership qos policy.
 *
 * @param {pdds_qos_t} qos
 * @returns {number} ownership policy kind
 */
module.exports.getOwnership = function(qos) {
  const kind = ref.alloc(ref.types.int32);
  libqos.dds_qget_ownership(qos, kind);
  return kind.deref();
};

/**
 * Wrapper for dds_qget_ownership_strength.
 * Get the ownership strength qos policy.
 *
 * @param {pdds_qos_t} qos
 * @returns {number} value of the ownership strength
 */
module.exports.getOwnershipStrength = function(qos) {
  const value = ref.alloc(ref.types.int32);
  libqos.dds_qget_ownership_strength(qos, value);
  return value.deref();
};

/**
 * Wrapper for dds_qget_liveliness.
 * Get the liveliness qos policy.
 *
 * @param {pdds_qos_t} qos
 * @returns {object} a javascript object {livelinessKind, leaseDuration}
 */
module.exports.getLiveliness = function(qos) {
  const kind = ref.alloc(ref.types.int32);
  const leaseDuration = ref.alloc(ref.types.int64);
  libqos.dds_qget_liveliness(qos, kind, leaseDuration);

  return {
    kind: kind.deref(),
    leaseDuration: leaseDuration.deref(),
  };
};

/**
 * Wrapper for dds_qget_time_based_filter.
 * Get the timebased filter qos policy.
 *
 * @param {pdds_qos_t} qos
 * @returns {number} minimum separation
 */
module.exports.getTimebasedFilter = function(qos) {
  const minSeparation = ref.alloc(ref.types.int64);
  libqos.dds_qget_time_based_filter(qos, minSeparation);
  return minSeparation.deref();
};

/**
 * Wrapper for dds_qget_partition.
 * Get the logical partition qos policy.
 *
 * @param {pdds_qos_t} qos
 * @returns {string[]} an array of partition names
 */
module.exports.getPartition = function(qos) {

  let pn = ref.alloc(ref.types.uint32);
  let partitions = ref.alloc(pCString);
  libqos.dds_qget_partition(qos, pn, partitions);

  let pBuffer = null;
  let partitionArray = [];

  for (let i = 0; i < pn.deref(); i++) {
    pBuffer = ref.get(partitions.deref(), 8 * i, ref.getType(partitions));
    partitionArray.push(ref.readCString(pBuffer, 0));
  }
  return partitionArray;
};

/**
 * Wrapper for dds_qget_reliability.
 * Get the reliability qos policy.
 *
 * @param {pdds_qos_t} qos
 * @returns {object} a javascript object {reliabilityKind, maxBlockingTime}
 */
module.exports.getReliability = function(qos) {
  const kind = ref.alloc(ref.types.int32);
  const maxBlockingTime = ref.alloc(ref.types.int64);
  libqos.dds_qget_reliability(qos, kind, maxBlockingTime);

  return {
    kind: kind.deref(),
    maxBlockingTime: maxBlockingTime.deref(),
  };
};

/**
 * Wrapper for dds_qget_transport_priority.
 * Get the transport priority qos policy.
 *
 * @param {pdds_qos_t} qos
 * @returns {number} transport priority value
 */
module.exports.getTransportPriority = function(qos) {
  const value = ref.alloc(ref.types.int32);
  libqos.dds_qget_transport_priority(qos, value);
  return value.deref();
};

/**
 * Wrapper for dds_qget_destination_order.
 * Get the destination order qos policy.
 *
 * @param {pdds_qos_t} qos
 * @returns {number} destination order policy kind
 */
module.exports.getDestinationOrder = function(qos) {
  const kind = ref.alloc(ref.types.int32);
  libqos.dds_qget_destination_order(qos, kind);
  return kind.deref();
};

/**
 * Wrapper for dds_qget_writer_data_lifecycle.
 * Get the writer data lifecycle qos policy.
 *
 * @param {pdds_qos_t} qos
 * @returns {boolean}
 */
module.exports.getWriterDataLifecycle = function(qos) {
  const autodisposeUnregisteredInstances = ref.alloc(ref.types.bool);
  libqos.dds_qget_writer_data_lifecycle(qos, autodisposeUnregisteredInstances);
  return autodisposeUnregisteredInstances.deref();
};

/**
 * Wrapper for dds_qget_reader_data_lifecycle.
 * Get the reader data lifecycle qos policy.
 *
 * @param {pdds_qos_t} qos
 * @returns {object} a javascript object {autopurgeNoWriterSamples,
 * autopurgeDisposedSamplesDelay}
 */
module.exports.getReaderDataLifecycle = function(qos) {
  const autopurgeNoWriterSamples = ref.alloc(ref.types.int64);
  const autopurgeDisposedSamplesDelay = ref.alloc(ref.types.int64);
  libqos.dds_qget_reader_data_lifecycle(
    qos,
    autopurgeNoWriterSamples,
    autopurgeDisposedSamplesDelay
  );

  return {
    autopurgeNoWriterSamples: autopurgeNoWriterSamples.deref(),
    autopurgeDisposedSamplesDelay: autopurgeDisposedSamplesDelay.deref(),
  };
};

/**
 * Wrapper for dds_qget_durability_service.
 * Get the durability service qos policy.
 *
 * @param {pdds_qos_t} qos
 * @returns {object} a javascript object {serviceCleanupDelay, historyKind,
 * historyDepth, maxSamples, maxInstances, maxSamplesPerInstance}
 */
module.exports.getDurabilityService = function(qos) {

  const serviceCleanupDelay = ref.alloc(ref.types.int64);
  const historyKind = ref.alloc(ref.types.int32);
  const historyDepth = ref.alloc(ref.types.int32);
  const maxSamples = ref.alloc(ref.types.int32);
  const maxInstances = ref.alloc(ref.types.int32);
  const maxSamplesPerInstance = ref.alloc(ref.types.int32);
  libqos.dds_qget_durability_service(
    qos,
    serviceCleanupDelay,
    historyKind,
    historyDepth,
    maxSamples,
    maxInstances,
    maxSamplesPerInstance
  );

  return {
    serviceCleanupDelay: serviceCleanupDelay.deref(),
    historyKind: historyKind.deref(),
    historyDepth: historyDepth.deref(),
    maxSamples: maxSamples.deref(),
    maxInstances: maxInstances.deref(),
    maxSamplesPerInstance: maxSamplesPerInstance.deref(),
  };
};

/**
 * Wrapper for dds_qset_userdata.
 * Set the userdata policy in the qos structure.
 *
 * @param {pdds_qos_t} qos
 * @param {Buffer} data
 */
module.exports.setUserdata = function(qos, data) {
  if (data instanceof Buffer) {
    libqos.dds_qset_userdata(qos, data, data.length);
  } else {
    throw new Error('Error in setUserdata: Buffer ' +
      'data expected');
  }
};

/**
 * Wrapper for dds_qset_topicdata.
 * Set the topicdata policy in the qos structure.
 *
 * @param {pdds_qos_t} qos
 * @param {Buffer} data
 */
module.exports.setTopicdata = function(qos, data) {
  if (data instanceof Buffer) {
    libqos.dds_qset_topicdata(qos, data, data.length);
  } else {
    throw new Error('Error in setTopicdata: Buffer ' +
      'data expected');
  }
};

/**
 * Wrapper for dds_qset_groupdata.
 * Set the groupdata policy in the qos structure.
 *
 * @param {pdds_qos_t} qos
 * @param {Buffer} data
 */
module.exports.setGroupdata = function(qos, data) {
  if (data instanceof Buffer) {
    libqos.dds_qset_groupdata(qos, data, data.length);
  } else {
    throw new Error('Error in setGroupdata: Buffer ' +
      'data expected');
  }
};

/**
 * Wrapper for dds_qset_durability.
 * Set the durability policy in the qos structure.
 *
 * @param {pdds_qos_t} qos
 * @param {number} kind
 */
module.exports.setDurability = function(qos, kind) {
  libqos.dds_qset_durability(qos, kind);
};

/**
 * Wrapper for dds_qset_history.
 * Set the history policy in the qos structure.
 *
 * @param {pdds_qos_t} qos
 * @param {number} kind
 * @param {number} depth
 */
module.exports.setHistory = function(qos, kind, depth) {
  libqos.dds_qset_history(qos, kind, depth);
};

/**
 * Wrapper for dds_qset_resource_limits.
 * Set the resource limits policy in the qos structure.
 *
 * @param {pdds_qos_t} qos
 * @param {number} maxSamples
 * @param {number} maxInstances
 * @param {number} maxSamplesPerInstance
 */
module.exports.setResourceLimits = function(
  qos,
  maxSamples,
  maxInstances,
  maxSamplesPerInstance) {
  libqos.dds_qset_resource_limits(
    qos,
    maxSamples,
    maxInstances,
    maxSamplesPerInstance
  );
};

/**
 * Wrapper for dds_qset_presentation.
 * Set the presentation policy in the qos structure.
 *
 * @param {pdds_qos_t} qos
 * @param {number} accessScope
 * @param {boolean} coherentAccess
 * @param {boolean} orderedAccess
 */
module.exports.setPresentation = function(
  qos,
  accessScope,
  coherentAccess,
  orderedAccess
) {
  libqos.dds_qset_presentation(
    qos,
    accessScope,
    coherentAccess,
    orderedAccess
  );
};

/**
 * Wrapper for dds_qset_lifespan.
 * Set the lifespan policy in the qos structure.
 *
 * @param {pdds_qos_t} qos
 * @param {number} lifespan
 */
module.exports.setLifespan = function(qos, lifespan) {
  libqos.dds_qset_lifespan(qos, lifespan);
};

/**
 * Wrapper for dds_qset_deadline.
 * Set the deadline policy in the qos structure.
 *
 * @param {pdds_qos_t} qos
 * @param {number} deadline
 */
module.exports.setDeadline = function(qos, deadline) {
  libqos.dds_qset_deadline(qos, deadline);
};

/**
 * Wrapper for dds_qset_latency_budget.
 * Set the latency budget policy in the qos structure.
 *
 * @param {pdds_qos_t} qos
 * @param {number} duration
 */
module.exports.setLatencyBudget = function(qos, duration) {
  libqos.dds_qset_latency_budget(qos, duration);
};

/**
 * Wrapper for dds_qset_ownership.
 * Set the ownership qos policy in the qos structure.
 *
 * @param {pdds_qos_t} qos
 * @param {number} kind
 */
module.exports.setOwnership = function(qos, kind) {
  libqos.dds_qset_ownership(qos, kind);
};

/**
 * Wrapper for dds_qset_ownership_strength.
 * Set the ownership strength in the qos structure.
 *
 * @param {pdds_qos_t} qos
 * @param {number} value
 */
module.exports.setOwnershipStrength = function(qos, value) {
  libqos.dds_qset_ownership_strength(qos, value);
};

/**
 * Wrapper for dds_qset_liveliness.
 * Set the liveliness policy in the qos structure.
 *
 * @param {pdds_qos_t} qos
 * @param {number} kind
 * @param {number} leaseDuration
 */
module.exports.setLiveliness = function(
  qos,
  kind,
  leaseDuration) {
  libqos.dds_qset_liveliness(qos, kind, leaseDuration);
};

/**
 * Wrapper for dds_qset_time_based_filter.
 * set the time based filter policy in the qos structure.
 *
 * @param {pdds_qos_t} qos
 * @param {number} minSeparation
 */
module.exports.setTimebasedFilter = function(qos, minSeparation) {
  libqos.dds_qset_time_based_filter(qos, minSeparation);
};

/**
 * Wrapper for dds_qset_partition.
 * set the partition name in the qos structure.
 *
 * @param {pdds_qos_t} qos
 * @param {string[]} partitionArray
 */
module.exports.setPartition = function(
  qos,
  partitionArray
) {
  if (!(partitionArray instanceof Array)){
    throw new Error('Error in setParttion: non array input');
  }

  const partitionArrayBuf = Buffer.alloc(
    ref.types.CString.size * partitionArray.length
  );

  for (let i = 0; i < partitionArray.length; i++) {
    ref.types.CString.set(
      partitionArrayBuf,
      ref.types.CString.size * i,
      partitionArray[i]
    );
  }

  libqos.dds_qset_partition(
    qos,
    partitionArray.length,
    partitionArrayBuf
  );

};

/**
 * Wrapper for dds_qset_reliability.
 * Set the reliability policy in the qos structure.
 *
 * @param {pdds_qos_t} qos
 * @param {number} kind
 * @param {number} maxBlockingTime
 */
module.exports.setReliability = function(
  qos,
  kind,
  maxBlockingTime) {
  libqos.dds_qset_reliability(qos, kind, maxBlockingTime);
};

/**
 * Wrapper for dds_qset_transport_priority.
 * Set the transport priority policy in the qos structure.
 *
 * @param {pdds_qos_t} qos
 * @param {number} value
 */
module.exports.setTransportPriority = function(qos, value) {
  libqos.dds_qset_transport_priority(qos, value);
};

/**
 * Wrapper for dds_qset_destination_order.
 * Set the destination order policy in the qos structure.
 *
 * @param {pdds_qos_t} qos
 * @param {number} kind
 */
module.exports.setDestinationOrder = function(qos, kind) {
  libqos.dds_qset_destination_order(qos, kind);
};

/**
 * Wrapper for dds_qset_writer_data_lifecycle.
 * Set the writer data lifecycle policy in the qos structure.
 *
 * @param {pdds_qos_t} qos
 * @param {boolean} autodisposeUnregisteredInstances true : dispose the
 * instance automatically each time when it is unregistered,
 * false : automatic disposition will not happen upon unregistration
 */
module.exports.setWriterDataLifecycle = function(
  qos,
  autodisposeUnregisteredInstances) {
  libqos.dds_qset_writer_data_lifecycle(qos, autodisposeUnregisteredInstances);
};

/**
 * Wrapper for dds_qset_reader_data_lifecycle.
 * Set the reader data lifecycle policy in the qos structure.
 *
 * @param {pdds_qos_t} qos
 * @param {number} autopurgeNoWriterSamples
 * @param {number} autopurgeDisposedSamplesDelay
 */
module.exports.setReaderDataLifecycle = function(
  qos,
  autopurgeNoWriterSamples,
  autopurgeDisposedSamplesDelay) {
  libqos.dds_qset_reader_data_lifecycle(
    qos,
    autopurgeNoWriterSamples,
    autopurgeDisposedSamplesDelay
  );
};

/**
 * Wrapper for dds_qset_durability_service.
 * Set the durability service qos.
 *
 *
 * @param {pdds_qos_t} qos
 * @param {number} serviceCleanupDelay
 * @param {number} historyKind
 * @param {number} historyDepth
 * @param {number} maxSamples
 * @param {number} maxInstances
 * @param {number} maxSamplesPerInstance
 */
module.exports.setDurabilityService = function(
  qos,
  serviceCleanupDelay,
  historyKind,
  historyDepth,
  maxSamples,
  maxInstances,
  maxSamplesPerInstance) {
  libqos.dds_qset_durability_service(
    qos,
    serviceCleanupDelay,
    historyKind,
    historyDepth,
    maxSamples,
    maxInstances,
    maxSamplesPerInstance
  );
};
