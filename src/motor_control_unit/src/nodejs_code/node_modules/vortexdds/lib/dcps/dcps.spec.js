/*
 *                         Vortex OpenSplice
 *
 *   This software and documentation are Copyright 2006 to 2019 ADLINK
 *   Technology Limited, its affiliated companies and licensors. All rights
 *   reserved.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

'use strict';
/* eslint-env node, mocha */

const dcps = require('./dcps');
const ddsqos = require('./qos');
const ddserr = require('./ddserr');
const expect = require('chai').expect;
const TypeSupport = require('./ddstopic').TypeSupport;

/* Topic Descriptor Information */
const sampleTypeName = 'HelloWorldData::Msg';
const sampleTypeKey = 'userID';
const sampleTopicXML = '<MetaData version="1.0.0">' +
  '<Module name="HelloWorldData">' +
  '<Struct name="Msg">' +
  '<Member name="userID"><Long/></Member>' +
  '<Member name="message"><Long/></Member>' +
  '</Struct>' +
  '</Module>' +
  '</MetaData>';
const sampleTopicName = 'HelloWorldData_Msg';

function createSampleTopic(participant, topicname, qos = null) {
  let typeSupport = new TypeSupport(sampleTypeName, sampleTypeKey,
    sampleTopicXML);
  return participant.createTopic(
    topicname,
    typeSupport,
    qos
  );
}

function SEC_TO_NANO(n) {
  return n * 1000000000;
}

function SEC_TO_MILI(n) {
  return n * 1000;
}

describe('DCPS create and delete tests', function() {
  let dp = null;

  before(function() {
    this.timeout(10000);
    dp = new dcps.Participant();
  });

  after(async function() {
    this.timeout(SEC_TO_MILI(20));
    await dp.delete();
  });

  it('Can create a domain participant', function() {
    expect(dp.handle).to.not.be.null;
  });

  it('Participant constructor fails with invalid domain id', function() {
    expect(function() {
      // eslint-disable-next-line no-unused-vars
      const participant = new dcps.Participant(500);
    }).to.throw(ddserr.DDSError).with
      .property('ddsErrCode').to.be.within(1, 12);
  });

  it('delete twice test', async function() {
    this.timeout(10000);
    const participant = new dcps.Participant();

    await participant.delete();

    expect(participant.handle).to.be.null;
  });


  /* TopicDescriptor class tests */
  it('create a topic descriptor', function() {
    const topicDescriptor = new dcps.TopicDescriptor(
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    );
    expect(topicDescriptor.cAddr).to.not.be.null;
  });

  it('delete a topic descriptor', function() {
    const topicDescriptor = new dcps.TopicDescriptor(
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    );
    expect(function() {
      topicDescriptor.delete();
    }).not.to.throw(Error);
  });

  it('delete a topic descriptor twice', function() {
    const topicDescriptor = new dcps.TopicDescriptor(
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    );
    topicDescriptor.delete();
    expect(function() {
      topicDescriptor.delete();
    }).not.to.throw(Error);
  });

  it('accessing the c address after a delete throws an error', function() {
    const topicDescriptor = new dcps.TopicDescriptor(
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    );
    topicDescriptor.delete();
    expect(function() {
      topicDescriptor.cAddr;
    }).to.throw(ReferenceError);
  });

  it('get entity qos test', function() {
    this.timeout(10000);
    const pqos = dp.qos;
    expect(pqos).to.not.be.null;
    pqos.delete();
  });

  it('get topic descriptor name,key and metadescriptor', function() {
    const topicDescriptor = new dcps.TopicDescriptor(
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    );
    expect(topicDescriptor.typeName).to.equal(sampleTypeName);
    expect(topicDescriptor.keyList).to.equal(sampleTypeKey);
    expect(topicDescriptor.metaDescriptor).to.equal(sampleTopicXML);
  });

  /* End of TopicDescriptor class tests */

  it('Can get the reliability QoS set on a Topic', function() {
    const tqos = ddsqos.QoS.topicDefault();
    tqos.reliability =
      { kind: ddsqos.ReliabilityKind.Reliable, maxBlockingTime: 0 };

    const top = createSampleTopic(dp, 'QoSGetterTopic', tqos);

    expect(top.qos.reliability).to.deep
      .equal({ kind: ddsqos.ReliabilityKind.Reliable, maxBlockingTime: 0 });
  });

  it('Can get the reliability QoS on a Topic installed on a Writer',
    function() {
      const tqos = ddsqos.QoS.topicDefault();
      tqos.reliability =
        { kind: ddsqos.ReliabilityKind.Reliable, maxBlockingTime: 0 };

      const top = createSampleTopic(dp, 'QoSGetterTopic2', tqos);

      const wr = dp.createWriter(top);

      expect(wr.topic.qos.reliability)
        .to.deep
        .equal({ kind: ddsqos.ReliabilityKind.Reliable, maxBlockingTime: 0 });
    });
});

describe('DCPS tests', function() {

  function createStringTopic1() {
    const stringTopicXML = '<MetaData version="1.0.0">' +
      '<Module name="StringTopicData1">' +
      '<Struct name="Msg">' +
      '<Member name="userID"><Long/></Member>' +
      '<Member name="message"><Long/></Member>' +
      '<Member name="stringField"><String/></Member>' +
      '</Struct>' +
      '</Module>' +
      '</MetaData>';
    return new dcps.Topic(
      dp,
      'StringTopic1',
      'StringTopicData1::Msg',
      'stringField',
      stringTopicXML
    );
  }

  function createStringTopic2() {
    const stringTopicXML = '<MetaData version="1.0.0">' +
      '<Module name="StringTopicData2">' +
      '<Struct name="Msg">' +
      '<Member name="userID"><Long/></Member>' +
      '<Member name="message"><String/></Member>' +
      '</Struct>' +
      '</Module>' +
      '</MetaData>';
    return new dcps.Topic(
      dp,
      'StringTopic2',
      'StringTopicData2::Msg',
      'message',
      stringTopicXML
    );
  }

  let dp = null;

  before(function() {
    dp = new dcps.Participant();
  });

  after(async function() {
    this.timeout(SEC_TO_MILI(20));
    await dp.delete();
  });

  it('createTopic function test', function() {
    const topic = createSampleTopic(dp, 'SampleTopic');
    expect(topic).to.not.be.null;
  });

  it('createReader function test', function() {
    const topic = createSampleTopic(dp, 'SampleTopic');
    const reader = dp.createReader(topic);
    expect(reader).to.not.be.null;
  });

  it('createWriter function test', function() {
    const topic = createSampleTopic(dp, 'SampleTopic');
    const writer = dp.createWriter(topic);
    expect(writer).to.not.be.null;
  });

  it('createWriter uses topic qos if qos is null', function() {
    const tqos = ddsqos.QoS.topicDefault();
    tqos.reliability = {
      kind: ddsqos.ReliabilityKind.BestEffort,
      maxBlockingTime: 100,
    };

    const topic = createSampleTopic(dp, 'SampleTopicForWriter', tqos);
    const writer = dp.createWriter(topic, null);

    const writerqos = writer.qos;
    expect(writerqos.reliability).to.be.deep.equal(tqos.reliability);
  });

  it('createPublisher function test', function() {
    const publisher = dp.createPublisher();
    expect(publisher).to.not.be.null;
  });

  it('createSubscriber function test', function() {
    const subscriber = dp.createSubscriber();
    expect(subscriber).to.not.be.null;
  });

  /* Topic class tests */
  it('Topic create fails with null topicHandle', function() {
    expect(function() {
      // eslint-disable-next-line no-unused-vars
      const tp = new dcps.Topic(dp, 'HelloWorldData_Msg', null, null, null);
    }).to.throw(Error);
  });

  it('create a topic', function() {
    const topic = new dcps.Topic(
      dp,
      'HelloWorldData_Msg',
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML
    );
    expect(topic.handle).to.not.be.null;
  });

  it('findTopic', function(done) {
    let promise = dp.findTopic('HelloWorldData_Msg');
    promise.then((result) => {
      expect(result).to.not.be.null;
      done();
    }).catch((err) => {
      done(new Error('find topic Promise reject: ' + err));
    });
  });

  it('Can find a topic over the wire, and write on that topic',
    async function() {
      this.timeout(SEC_TO_MILI(10));
      // create the topic
      const tqos = ddsqos.QoS.topicDefault();
      tqos.durability = { kind: ddsqos.DurabilityKind.Transient };
      const top = createSampleTopic(dp, 'OverWireTopic', tqos);

      // create a reader with this topic
      const rd = dp.createReader(top);

      // find the topic over the wire
      const foundTopic = await dp.findTopic('OverWireTopic');

      // create a writer with this found topic
      // and write with it
      const qos = new ddsqos.QoS({
        reliability: { kind: ddsqos.ReliabilityKind.BestEffort }});
      const wr = dp.createWriter(foundTopic, qos);

      wr.write({ userID: 1, message: 2 });

      expect(rd.read(1)[0].sample).to.deep.equal({ userID: 1, message: 2 });
    });

  it('gets the descriptor and topic name', function() {
    const topic = createSampleTopic(dp, 'SampleTopic');
    expect(topic.name).to.equal('SampleTopic');
    expect(topic.descriptor).to.not.be.null;
  });

  /* End of Topic class tests */

  /* Writer class tests */
  it('Writer create fails with null topic', function() {
    expect(function() {
      // eslint-disable-next-line no-unused-vars
      const wr = dp.createWriter(null, null, null);
    }).to.throw(TypeError);
  });

  it('Writer.reliable is true when writer QoS is reliable', function() {
    const wqos = ddsqos.QoS.writerDefault();
    wqos.reliability =
      { kind: ddsqos.ReliabilityKind.Reliable, maxBlockingTime: 0 };
    const topic = createSampleTopic(dp, 'WriterReliableFlagTopic1');
    const wr = dp.createWriter(topic, wqos);

    expect(wr.reliable).to.equal(true);
  });

  it('Writer.reliable is true when Topic QoS is reliable', function() {
    const tqos = ddsqos.QoS.topicDefault();
    tqos.reliability =
      { kind: ddsqos.ReliabilityKind.Reliable, maxBlockingTime: 0 };
    // console.log(tqos.reliability);
    // console.log(tqos.isReliable());
    const topic = createSampleTopic(dp, 'WriterReliableFlagTopic2', tqos);
    const wr = dp.createWriter(topic);
    expect(wr.reliable).to.equal(true);
  });

  it('Writer.reliable is false when writer QoS and Topic QoS are non-reliable',
    function() {
      const topic = createSampleTopic(dp, 'WriterReliableFlagTopic3');
      const qos = new ddsqos.QoS({
        reliability: { kind: ddsqos.ReliabilityKind.BestEffort }});
      const wr = dp.createWriter(topic, qos);
      expect(wr.reliable).to.equal(false);
    });

  it('create a writer', function() {
    const topic = createSampleTopic(dp, 'HelloWorldData_Msg');
    const writer = dp.createWriter(topic);
    expect(writer.handle).to.not.be.null;
  });

  it('write data', function() {
    const topic = createSampleTopic(dp, 'HelloWorldData_Msg');
    const qos = new ddsqos.QoS({
      reliability: { kind: ddsqos.ReliabilityKind.BestEffort }});
    const writer = dp.createWriter(topic, qos);
    const sampleJSObj = {
      userID: 5,
      message: 14,
    };
    const status = writer.write(sampleJSObj);
    expect(status).to.be.equal(0);
  });

  /* End of Wrtier class tests */

  /* Reader class tests */
  it('create a reader', function() {
    const topic = createSampleTopic(dp, 'HelloWorldData_Msg');
    const reader = dp.createReader(topic);
    expect(reader.handle).to.not.be.null;
  });

  it('Reader create fails with null topic', function() {
    expect(function() {
      // eslint-disable-next-line no-unused-vars
      const rd = dp.createReader(null);
    }).to.throw(TypeError);
  });

  it('read sample', function() {
    const topic = createSampleTopic(dp, 'HelloWorldData_Msg');
    const qos = new ddsqos.QoS({
      reliability: { kind: ddsqos.ReliabilityKind.BestEffort }});
    const reader = dp.createReader(topic, qos);
    const writer = dp.createWriter(topic, qos);

    const numberOfSample = 15;

    // write 15 messages
    for (let i = 0; i < numberOfSample; i++) {
      let sampleJSObj = {
        userID: i,
        message: i + 1,
      };
      writer.write(sampleJSObj);
    }

    const readArray = reader.read(numberOfSample);
    expect(readArray.length).to.equal(numberOfSample);
  });

  it('read sample with condition', function() {
    const topic = createSampleTopic(dp, 'HelloWorldData_Msg');
    const qos = new ddsqos.QoS({
      reliability: { kind: ddsqos.ReliabilityKind.BestEffort }});
    const reader = dp.createReader(topic, qos);
    const writer = dp.createWriter(topic, qos);

    const numberOfSample = 15;

    // write 15 messages
    for (let i = 0; i < numberOfSample; i++) {
      let sampleJSObj = {
        userID: i,
        message: i + 1,
      };
      writer.write(sampleJSObj);
    }

    const readArray = reader.readCond(
      numberOfSample,
      reader.createReadCondition(dcps.StateMask.any)
    );
    expect(readArray.length).to.equal(numberOfSample);
    expect(readArray[0].info.valid_data).to.equal(true);
  });

  it('Sample with invalid data should have null non-key fields',
    async function() {
      const participant = new dcps.Participant();
      const participant2 = new dcps.Participant();

      let topic = createSampleTopic(dp, 'InvalidDataTopic');

      const qos = new ddsqos.QoS({
        reliability: { kind: ddsqos.ReliabilityKind.BestEffort }});

      const writer = participant.createWriter(topic, qos);
      const reader = participant2.createReader(topic, qos);

      // just write one sample
      writer.write({ userID: 1, message: 2 });

      /* eslint-disable-next-line no-unused-vars */
      let dataSet = reader.take(1);

      // delete both of our participants
      await participant.delete();
      await participant2.delete();
    });

  it('take sample', function() {
    const topic = createSampleTopic(dp, 'HelloWorldData_Msg2');
    const qos = new ddsqos.QoS({
      reliability: { kind: ddsqos.ReliabilityKind.BestEffort }});
    const reader = dp.createReader(topic, qos);
    const writer = dp.createWriter(topic, qos);

    const numberOfSample = 15;

    // write 15 messages
    for (let i = 0; i < numberOfSample; i++) {
      let sampleJSObj = {
        userID: i,
        message: i + 1,
      };
      writer.write(sampleJSObj);
    }

    const readArray = reader.take(numberOfSample);
    expect(readArray.length).to.equal(numberOfSample);
  });

  it('take sample with condition', function() {
    const topic = createSampleTopic(dp, 'HelloWorldData_Msg2');
    const qos = new ddsqos.QoS({
      reliability: { kind: ddsqos.ReliabilityKind.BestEffort }});
    const reader = dp.createReader(topic, qos);
    const writer = dp.createWriter(topic, qos);

    const numberOfSample = 15;

    // write 15 messages
    for (let i = 0; i < numberOfSample; i++) {
      let sampleJSObj = {
        userID: i,
        message: i + 1,
      };
      writer.write(sampleJSObj);
    }

    const readArray = reader.takeCond(
      numberOfSample,
      reader.createReadCondition(dcps.StateMask.any)
    );
    expect(readArray.length).to.equal(numberOfSample);
  });

  it('Can read 10 samples from a topic with a string field ' +
    '(long, long, string)', function() {
    const topic = createStringTopic1();
    const qos = new ddsqos.QoS({
      reliability: { kind: ddsqos.ReliabilityKind.BestEffort }});
    const reader = dp.createReader(topic, qos);
    const writer = dp.createWriter(topic, qos);

    // write 10 messages
    for (let i = 0; i < 10; i++) {
      writer.write({ userID: i, message: 2 * i, stringField: 'foo' + i });
    }

    // read in all 10, expect the correct messages
    let dataOut = reader.read(10);
    for (let i = 0; i < 10; i++) {
      expect(dataOut[i].sample.userID).to.equal(i);
      expect(dataOut[i].sample.message).to.equal(2 * i);
      expect(dataOut[i].sample.stringField).to.equal('foo' + i);
    }
  });

  it('Can read 10 samples from a topic with a string field (long, string)',
    function() {
      const topic = createStringTopic2();
      const qos = new ddsqos.QoS({
        reliability: { kind: ddsqos.ReliabilityKind.BestEffort }});
      const reader = dp.createReader(topic, qos);
      const writer = dp.createWriter(topic, qos);

      // write 10 messages
      for (let i = 0; i < 10; i++) {
        writer.write({ userID: i, message: 'foo' + i });
      }

      // read in all 10, expect the correct messages
      let dataOut = reader.read(10);
      for (let i = 0; i < 10; i++) {
        expect(dataOut[i].sample.userID).to.equal(i);
        expect(dataOut[i].sample.message).to.equal('foo' + i);
      }
    });

  /* End of Reader class tests */

  /* Subscriber class tests */
  it('create a subscriber', function() {
    const subscriber = dp.createSubscriber();
    expect(subscriber.handle).to.not.be.null;
  });

  it('create a reader using subscriber', function() {
    const subscriber = dp.createSubscriber();
    const topic = createSampleTopic(dp, 'HelloWorldData_Msg');
    const reader = subscriber.createReader(topic);
    expect(reader.handle).to.not.be.null;
  });

  it('Subscriber create fails with null participant', function() {
    expect(function() {
      // eslint-disable-next-line no-unused-vars
      const sub = new dcps.Subscriber(null);
    }).to.throw(TypeError);
  });
  /* End of Subscriber class tests */

  /* Publisher class tests */
  it('create a publisher', function() {
    const publisher = new dcps.Publisher(dp);
    expect(publisher.handle).to.not.be.null;
  });

  it('create a writer using publisher', function() {
    const publisher = dp.createPublisher();
    const topic = createSampleTopic(dp, 'HelloWorldData_Msg');
    const writer = publisher.createWriter(topic);
    expect(writer.handle).to.not.be.null;
  });

  it('Publisher create fails with null participant', function() {
    expect(function() {
      // eslint-disable-next-line no-unused-vars
      const pb = new dcps.Publisher(null);
    }).to.throw(TypeError);
  });
  /* End of Publisher class tests */

  it('Can asynchronously wait for historical data', function(done) {
    // let topic = createSampleTopic('HelloWorldData_Msg');
    const rd = dp.createReader(createSampleTopic(dp, 'HelloWorldData_Msg'));
    // expect to complete right away with no error
    const promise = rd.waitForHistoricalData(0);
    promise.then((result) => {
      expect(result).to.equal(0);
      done();
    }).catch((error) => {
      done(new Error('Unexpected error: ' + error));
    });
  });

});

describe('Conditions and Waitset tests', function() {
  let dp = null;
  let reader = null;
  let topic = null;

  function createHelloWorldTopic() {

    return new dcps.Topic(
      dp,
      sampleTopicName,
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML);
  }

  before(function() {
    dp = new dcps.Participant();
    topic = createHelloWorldTopic();
    reader = dp.createReader(topic);
  });

  after(async function() {
    this.timeout(SEC_TO_MILI(20));
    await dp.delete();
  });

  it('Read condition tests', function() {
    const cond = reader.createReadCondition(dcps.StateMask.any);
    expect(cond).to.not.be.null;
    expect(cond.handle).to.not.be.null;
    expect(cond.triggered()).to.equal(false);
    expect(function() {
      cond.delete();
    }).to.not.throw(Error);
  });

  it('Guard condition tests', function() {
    const guardCond = new dcps.GuardCondition();
    expect(guardCond).to.not.be.null;
    expect(guardCond.triggered()).to.equal(false);
    guardCond.trigger();
    expect(guardCond.triggered()).to.equal(true);
    guardCond.reset();
    expect(guardCond.triggered()).to.equal(false);
  });

  it('Can set the data_available status on a participant', function() {
    const statCond = dp.createStatusCondition();
    expect(function() {
      statCond.enable(dcps.StatusMask.data_available);
    }).to.not.throw(Error);
  });

  it('Can set the inconsistent_topic status on a topic', function() {
    const statCond = topic.createStatusCondition();
    expect(function() {
      statCond.enable(dcps.StatusMask.inconsistent_topic);
    }).to.not.throw(Error);
  });

  it('Can set the data_on_readers status on a subscriber', function() {
    const sub = dp.createSubscriber();
    const statCond = sub.createStatusCondition();
    expect(function() {
      statCond.enable(dcps.StatusMask.data_on_readers);
    }).to.not.throw(Error);
  });

  it('Can set the sample_rejected status on a data reader', function() {
    const rd = dp.createReader(topic);
    const statCond = rd.createStatusCondition();
    expect(function() {
      statCond.enable(dcps.StatusMask.sample_rejected);
    }).to.not.throw(Error);
  });

  it('Can set the liveliness_lost status on a data writer', function() {
    const rd = dp.createWriter(topic);
    const statCond = rd.createStatusCondition();
    expect(function() {
      statCond.enable(dcps.StatusMask.liveliness_lost);
    }).to.not.throw(Error);
  });

  it('Cannot set the data_on_readers status on a topic', function() {
    const statCond = topic.createStatusCondition();
    expect(function() {
      statCond.enable(dcps.StatusMask.data_on_readers);
    }).to.throw(Error);
  });

  it('StatusCondition tests', function() {
    const statCond = dp.createStatusCondition();
    expect(statCond).to.not.be.null;
    statCond.enable(dcps.StatusMask.data_available);
    expect(statCond.mask).to.equal(dcps.StatusMask.data_available);

    const statCond2 = dp.createStatusCondition(
      dcps.StatusMask.data_available);
    expect(statCond2.mask).to.equal(dcps.StatusMask.data_available);
  });

  it('CreateQueryCondition function', function() {
    const queryCond = reader.createQueryCondition(
      dcps.StateMask.any,
      'userID = %0',
      ['10']
    );
    expect(queryCond).to.not.be.null;
  });

  it('Can call the Waitset constructor with a condition', function() {
    let ws = new dcps.Waitset(new dcps.GuardCondition());
    expect(ws.conditions.length).to.equal(1);
  });

  // can asyncronously wait and timeout
  it('Can asynchronously wait on a waitset and timeout', function(done) {
    const ws = new dcps.Waitset();

    const promise = ws.wait(Math.pow(10, 9));
    promise.then((result) => {
      done(new Error('Unexpected result'));
    }).catch((error) => {
      expect(error).to.be.instanceof(ddserr.DDSError);
      expect(error.ddsErrCode).to.equal(ddserr.DDSErrorCode.TIMEOUT);
      done();
    });

  });

  it('Can asynchronously wait on a waitset and unblock when '
    + 'the condition is met', function(done) {
    const ws = new dcps.Waitset();
    const cond = new dcps.GuardCondition();
    ws.attach(cond);

    const promise = ws.wait(Math.pow(10, 9));
    cond.trigger();
    promise.then((result) => {
      expect(result.length).to.equal(1);
      expect(result[0]).to.be.instanceof(dcps.GuardCondition);
      done();
    }).catch((error) => {
      done(new Error('Unexpected error: ' + error));
    });
  });

  it('Can create a status condition on each type of entity.', function() {
    // for a participant
    const dp = new dcps.Participant();
    let statCond = dp.createStatusCondition();
    expect(function() {
      statCond.enable(dcps.StatusMask.data_available);
    }).to.not.throw(Error);

    // for a publisher
    const pub = dp.createPublisher();
    statCond = pub.createStatusCondition();
    expect(function() {
      statCond.enable(dcps.StatusMask.publication_matched);
    }).to.not.throw(Error);

    // for a writer
    const wr = pub.createWriter(topic);
    statCond = wr.createStatusCondition();
    expect(function() {
      statCond.enable(dcps.StatusMask.publication_matched);
    }).to.not.throw(Error);

    // for a topic
    statCond = topic.createStatusCondition();
    expect(function() {
      statCond.enable(dcps.StatusMask.inconsistent_topic);
    }).to.not.throw(Error);

    // for a subscriber
    const sub = dp.createSubscriber();
    statCond = sub.createStatusCondition();
    expect(function() {
      statCond.enable(dcps.StatusMask.data_on_readers);
    }).to.not.throw(Error);

    // for a reader
    const rd = sub.createReader(topic);
    statCond = rd.createStatusCondition();
    expect(function() {
      statCond.enable(dcps.StatusMask.subscription_matched);
    }).to.not.throw(Error);

    // get an error as the mask does not correspond to the entity
    // inconsistent topic is not valid for a reader
    expect(function() {
      statCond.enable(dcps.StatusMask.inconsistent_topic);
    }).to.throw(Error);
  });

});

describe('DCPS input type checking tests', function() {
  let dp = null;

  before(function() {
    dp = new dcps.Participant();
  });

  after(async function() {
    this.timeout(SEC_TO_MILI(20));
    await dp.delete();
    // dp.delete();
  });

  it('Participant create throws TypeError for invalid domainId type',
    function() {
      expect(() =>
        new dcps.Participant('domainId')).to.throw(TypeError);
    });

  it('Participant create throws TypeError for invalid qos type',
    function() {
      expect(() =>
        new dcps.Participant(dcps.DDSConstants.DDS_DOMAIN_DEFAULT, 'qos')
      ).to.throw(TypeError);
    });

  it('Topic create throws TypeError for invalid participant type',
    function() {
      expect(() =>
        new dcps.Topic('dp')).to.throw(TypeError);
    });

  it('Topic create throws TypeError for invalid topicName type',
    function() {
      expect(() =>
        new dcps.Topic(dp, 123)).to.throw(TypeError);
    });

  it('Topic create throws TypeError for invalid typeName type',
    function() {
      expect(() =>
        new dcps.Topic(dp, 'HelloWorld', 123)).to.throw(TypeError);
    });

  it('Topic create throws TypeError for invalid keys type',
    function() {
      expect(() =>
        new dcps.Topic(dp, 'HelloWorld', sampleTypeName, 123)
      ).to.throw(TypeError);
    });

  it('Topic create throws TypeError for invalid xml type', function() {
    expect(() =>
      new dcps.Topic(dp, 'HelloWorld', sampleTypeName, sampleTypeKey, 123)
    ).to.throw(TypeError);
  });

  it('Topic create throws TypeError for invalid typeSupport type',
    function() {
      expect(() =>
        new dcps.Topic(
          dp,
          'HelloWorld',
          sampleTypeName,
          sampleTypeKey,
          sampleTopicXML,
          null,
          'typeSupport'
        )
      ).to.throw(TypeError);
    });

  it('Topic create throws TypeError for invalid qos type', function() {
    expect(() =>
      new dcps.Topic(
        dp,
        'HelloWorld',
        sampleTypeName,
        sampleTypeKey,
        sampleTopicXML,
        null,
        null,
        'qos'
      )
    ).to.throw(TypeError);
  });

  it('Topic create with valid qos type', function() {
    let tqos = ddsqos.QoS.topicDefault();
    let topic = new dcps.Topic(
      dp,
      'HelloWorld',
      sampleTypeName,
      sampleTypeKey,
      sampleTopicXML,
      null,
      null,
      tqos
    );
    expect(topic.handle).to.not.be.null;
    tqos.delete();
  });

  it('findTopic throws TypeError for invalid topicName type', function() {
    expect(() => dp.findTopic(123)).to.throw(TypeError);
  });

  it('Publisher create throws TypeError for invalid participant type',
    function() {
      expect(() =>
        new dcps.Publisher('dp')).to.throw(TypeError);
    });

  it('Publisher create throws TypeError for invalid qos type', function() {
    expect(() =>
      dp.createPublisher('qos')).to.throw(TypeError);
  });

  it('Writer create throws TypeError for invalid participant|publisher type',
    function() {
      expect(() =>
        new dcps.Writer('dpOrPub')).to.throw(TypeError);
    });

  it('Writer create throws TypeError for invalid topic type', function() {
    expect(() =>
      dp.createWriter('topic')).to.throw(TypeError);
  });

  it('Writer create throws TypeError for invalid qos type', function() {
    var topic = createSampleTopic(dp, 'HelloWorld');
    expect(() =>
      dp.createWriter(topic, 'qos')).to.throw(TypeError);
  });

  it('Writer write throws TypeError for null data', function() {
    const qos = new ddsqos.QoS({
      reliability: { kind: ddsqos.ReliabilityKind.BestEffort }});
    var writer = dp.createWriter(createSampleTopic(dp, 'HelloWorld'), qos);
    expect(() =>
      writer.write(null)).to.throw(TypeError);
  });

  it('Subscriber create throws TypeError for invalid participant type',
    function() {
      expect(() =>
        new dcps.Subscriber('dp')).to.throw(TypeError);
    });

  it('Subscriber create throws TypeError for invalid qos type', function() {
    expect(() =>
      dp.createSubscriber('qos')).to.throw(TypeError);
  });

  it('Reader create throws TypeError for invalid participant|subscriber type',
    function() {
      expect(() =>
        new dcps.Reader('dpOrSub')).to.throw(TypeError);
    });

  it('Reader create throws TypeError for invalid topic type', function() {
    expect(() =>
      dp.createReader('topic')).to.throw(TypeError);
  });

  it('Reader create throws TypeError for invalid qos type', function() {
    var topic = createSampleTopic(dp, 'HelloWorld');
    expect(() =>
      dp.createReader(topic, 'qos')).to.throw(TypeError);
  });

  it('read throws TypeError for invalid maxSample type', function() {
    var rd = dp.createReader(createSampleTopic(dp, 'HelloWorldData'));
    expect(() =>
      rd.read('maxSample')).to.throw(TypeError);
  });

  it('readCond throws TypeError for invalid maxSample type', function() {
    var rd = dp.createReader(createSampleTopic(dp, 'HelloWorldData'));
    expect(() =>
      rd.readCond('maxSample')).to.throw(TypeError);
  });

  it('readCond throws TypeError for invalid condition type', function() {
    var rd = dp.createReader(createSampleTopic(dp, 'HelloWorldData'));
    expect(() =>
      rd.readCond(5, 'condition')).to.throw(TypeError);
  });

  it('take throws TypeError for invalid maxSample type', function() {
    var rd = dp.createReader(createSampleTopic(dp, 'HelloWorldData'));
    expect(() =>
      rd.take('maxSample')).to.throw(TypeError);
  });

  it('takeCond throws TypeError for invalid maxSample type', function() {
    var rd = dp.createReader(createSampleTopic(dp, 'HelloWorldData'));
    expect(() =>
      rd.takeCond('maxSample')).to.throw(TypeError);
  });

  it('takeCond throws TypeError for invalid condition type', function() {
    var rd = dp.createReader(createSampleTopic(dp, 'HelloWorldData'));
    expect(() =>
      rd.takeCond(5, 'condition')).to.throw(TypeError);
  });

  it('waitForHistoricalData throws TypeError for invalid timeout type',
    function() {
      let rd = dp.createReader(createSampleTopic(dp, 'HelloWorldData_Msg'));
      expect(function() {
        rd.waitForHistoricalData(dp);
      }).to.throw(TypeError);
    });

  it('ReadCondition create throws TypeError for invalid reader type',
    function() {
      expect(() =>
        new dcps.ReadCondition('reader')).to.throw(TypeError);
    });

  it('createReadCondition throws TypeError for invalid mask type',
    function() {
      const reader = dp.createReader(
        createSampleTopic(dp, 'HelloWorldData_Msg'));
      expect(() =>
        reader.createReadCondition('mask')).to.throw(TypeError);
    });

  it('QueryCondition create throws TypeError for invalid reader type',
    function() {
      expect(() =>
        new dcps.QueryCondition('reader')).to.throw(TypeError);
    });

  it('createQueryCondition throws TypeError for invalid mask type',
    function() {
      const reader = dp.createReader(
        createSampleTopic(dp, 'HelloWorldData_Msg'));
      expect(() => reader.createQueryCondition('mask')).to.throw(TypeError);
    });

  it('createQueryCondition throws TypeError for invalid expression type',
    function() {
      const reader = dp.createReader(
        createSampleTopic(dp, 'HelloWorldData_Msg'));
      expect(() => reader.createQueryCondition(dcps.StateMask.any, 123))
        .to.throw(TypeError);
    });

  it('createQueryCondition throws TypeError for invalid params type',
    function() {
      const reader = dp.createReader(
        createSampleTopic(dp, 'HelloWorldData_Msg'));
      expect(() =>
        reader.createQueryCondition(dcps.StateMask.any,
          'userID = %0',
          'params')).to.throw(TypeError);
    });

  it('StatusCondition throws TypeError for invalid entity type', function() {
    expect(() =>
      new dcps.StatusCondition('dp')).to.throw(TypeError);
  });

  it('StatusCondition throws TypeError for invalid mask type', function() {
    expect(() =>
      dp.createStatusCondition('mask')).to.throw(TypeError);
  });

  it('enable StatusCondition throws TypeError for invalid mask type',
    function() {
      const statusCond = dp.createStatusCondition();
      expect(() =>
        statusCond.enable('mask')).to.throw(TypeError);
    });

  it('Waitset create throws TypeError for invalid condition type', function() {
    expect(() =>
      new dcps.Waitset('cond')).to.throw(TypeError);
  });

  it('Waitset attach throws TypeError for invalid condition type', function() {
    let waitset = new dcps.Waitset();
    expect(() =>
      waitset.attach('cond')).to.throw(TypeError);
  });

  it('Waitset detach throws TypeError for invalid condition type', function() {
    let waitset = new dcps.Waitset();
    expect(() =>
      waitset.detach('cond')).to.throw(TypeError);
  });

  it('Waitset wait throws TypeError for invalid timeout type',
    function() {
      let waitset = new dcps.Waitset();
      expect(() =>
        waitset.wait(waitset)).to.throw(TypeError);
    });

  it('TopicDescriptor create throws TypeError for invalid typeName type',
    function() {
      expect(() =>
        new dcps.TopicDescriptor(123)).to.throw(TypeError);
    });

  it('TopicDescriptor create throws TypeError for invalid key type',
    function() {
      expect(() =>
        new dcps.TopicDescriptor(sampleTypeName, 123)).to.throw(TypeError);
    });

  it('TopicDescriptor create throws TypeError for invalid xml type',
    function() {
      expect(() =>
        new dcps.TopicDescriptor(sampleTypeName, sampleTypeKey, 123)
      ).to.throw(TypeError);
    });

  it('Entity readStatus and takeStatus throw TypeError for invalid mask type',
    function() {
      expect(() => dp.readStatus('mask')).to.throw(TypeError);
      expect(() => dp.takeStatus('mask')).to.throw(TypeError);
    });

});

describe('readStatus, takeStatus, enabledStatuses, statusChanges tests',
  function() {
    let dp = null;

    before(function() {
      dp = new dcps.Participant();
    });

    after(async function() {
      this.timeout(SEC_TO_MILI(20));
      await dp.delete();
    });

    it('Can get the status of an entity', function() {
      expect(dp.statusChanges()).to.be.a('number');
    });
  });

describe('Writer write methods', function() {
  let dp = null;
  before(function() {
    dp = new dcps.Participant();
  });

  after(async function() {
    this.timeout(SEC_TO_MILI(20));
    await dp.delete();
  });

  describe('Writer with non-reliable QoS', function() {
    it('Writer.write succeeds when Writer has non-reliable QoS',
      function() {
        let topic = createSampleTopic(dp, 'nonReliableQoSWriteTopic');
        const qos = new ddsqos.QoS({
          reliability: { kind: ddsqos.ReliabilityKind.BestEffort }});
        let wr2 = dp.createWriter(topic, qos);

        expect(function() {
          wr2.write({ userID: 0, message: 0 });
        }).to.not.throw(Error);
      });


    it('Writer.writeTs succeeds when Writer has non-reliable QoS',
      function() {
        let topic = createSampleTopic(dp, 'nonReliableQoSWriteTsTopic');
        const qos = new ddsqos.QoS({
          reliability: { kind: ddsqos.ReliabilityKind.BestEffort }});
        let wr = dp.createWriter(topic, qos);
        let rd = dp.createReader(topic, qos);

        wr.writeTs({ userID: 1, message: 2 }, 123);

        let dataSet = rd.read(1);
        expect(dataSet[0].sample).to.deep.equal({ userID: 1, message: 2 });
        expect(dataSet[0].info.source_timestamp).to.equal(123);
      });

  });

  describe('Writer with a reliable QoS', function() {
    it('Writer.write throws Error when reliable QoS is set', function() {
      let qos = ddsqos.QoS.writerDefault();
      qos.reliability =
        { kind: ddsqos.ReliabilityKind.Reliable, maxBlockingTime: 0 };
      let topic = createSampleTopic(dp, 'reliableQoSWriteTopic');
      let wr = dp.createWriter(topic, qos);

      expect(function() {
        wr.write({ userID: 0, message: 0 });
      }).to.throw(ddserr.DDSError).with.property('ddsErrCode',
        ddserr.DDSErrorCode.ILLEGAL_OPERATION);
    });

    it('Writer.writeReliable suceeds when Writer has reliable QoS',
      async function() {
        let wqos = ddsqos.QoS.writerDefault();
        wqos.reliability =
          { kind: ddsqos.ReliabilityKind.Reliable, maxBlockingTime: 0 };

        let rqos = ddsqos.QoS.readerDefault();
        rqos.reliability =
          { kind: ddsqos.ReliabilityKind.Reliable, maxBlockingTime: 0 };

        let topic = createSampleTopic(dp, 'reliableQoSWriteReliableTopic');
        let wr = dp.createWriter(topic, wqos);
        let rd = dp.createReader(topic, rqos);

        // write the message
        await wr.writeReliable({ userID: 1, message: 2 });

        // wait for the reader to get the message
        let ws = new dcps.Waitset();
        let statCond = new dcps.StatusCondition(rd,
          dcps.StatusMask.data_available);
        ws.attach(statCond);

        const twoSeconds = 2 * Math.pow(10, 9);
        const numTriggeredConditions = await ws.wait(twoSeconds);

        // make sure ws.wait completed normally, one triggered condition
        expect(numTriggeredConditions).to.deep.equal([statCond]);

        // now we can read
        expect(rd.read(1)[0].sample).to.deep.equal(
          { userID: 1, message: 2 });
      });

    it('Writer.writeTs throws Error when reliable QoS is set', function() {
      let qos = ddsqos.QoS.writerDefault();
      qos.reliability =
        { kind: ddsqos.ReliabilityKind.Reliable, maxBlockingTime: 0 };
      let topic = createSampleTopic(dp, 'reliableQoSWriteTsTopic');
      let wr = dp.createWriter(topic, qos);

      expect(function() {
        wr.writeTs({ userID: 0, message: 0 });
      }).to.throw(ddserr.DDSError).with.property('ddsErrCode',
        ddserr.DDSErrorCode.ILLEGAL_OPERATION);
    });

    it('Writer.writeTsReliable succeeds when Writer has reliable QoS',
      async function() {
        let wqos = ddsqos.QoS.writerDefault();
        wqos.reliability =
          { kind: ddsqos.ReliabilityKind.Reliable, maxBlockingTime: 0 };

        let rqos = ddsqos.QoS.readerDefault();
        rqos.reliability =
          { kind: ddsqos.ReliabilityKind.Reliable, maxBlockingTime: 0 };

        let topic = createSampleTopic(dp, 'reliableQoSWriteTsReliableTopic');
        let wr = dp.createWriter(topic, wqos);
        let rd = dp.createReader(topic, rqos);

        // write the message
        await wr.writeTsReliable({ userID: 1, message: 2 }, 123);

        // wait for the reader to get the message
        let ws = new dcps.Waitset();
        let statCond = new dcps.StatusCondition(rd,
          dcps.StatusMask.data_available);
        ws.attach(statCond);

        const triggeredConditions = await ws.wait(SEC_TO_NANO(2));

        // make sure ws.wait completed normally, one triggered condition
        expect(triggeredConditions).to.deep.equal([statCond]);

        // now we can read
        let dataSet = rd.read(1);
        expect(dataSet[0].sample).to.deep.equal(
          { userID: 1, message: 2 });
        expect(dataSet[0].info.source_timestamp).to.equal(123);
      });
  });
});

describe('Disposing and unregistering instances', function() {
  let dp = null;

  before(function() {
    dp = new dcps.Participant();
  });

  after(async function() {
    this.timeout(SEC_TO_MILI(20));
    await dp.delete();
  });

  describe('Writer with a non-reliable QoS', function() {
    it('Writer.dispose succeeds when Writer has non-reliable QoS', function() {
      let topic = createSampleTopic(dp, 'nonReliableDisposeTopic');
      const qos = new ddsqos.QoS({
        reliability: { kind: ddsqos.ReliabilityKind.BestEffort }});
      let wr = dp.createWriter(topic, qos);
      // let rd = dp.createReader(topic);
      const sample = { userID: 1, message: 2 };

      wr.write(sample);

      expect(function() {
        wr.dispose(sample);
      }).to.not.throw(Error);
    });

    it('Writer.disposeTs succeeds when Writer has non-reliable QoS',
      function() {
        let topic = createSampleTopic(dp, 'nonReliableDisposeTopic');
        const qos = new ddsqos.QoS({
          reliability: { kind: ddsqos.ReliabilityKind.BestEffort }});
        let wr = dp.createWriter(topic, qos);
        const sample = { userID: 1, message: 2 };

        wr.write(sample);

        expect(function() {
          wr.disposeTs(sample, 0);
        }).to.not.throw(Error);
      });


    it('Writer.unregister succeeds when Writer has non-reliable QoS',
      function() {
        let topic = createSampleTopic(dp, 'nonReliableQoSUnregisterTopic');
        const qos = new ddsqos.QoS({
          reliability: { kind: ddsqos.ReliabilityKind.BestEffort }});
        let wr = dp.createWriter(topic, qos);
        // let rd = dp.createReader(topic);
        const sample = { userID: 13, message: 23 };

        wr.write(sample);

        expect(function() {
          wr.unregister(sample);
        }).to.not.throw(Error);

      });

    it('Writer.unregisterTs succeeds when Writer has non-reliable QoS',
      function() {
        let topic = createSampleTopic(dp, 'nonReliableQoSUnregisterTsTopic');
        const qos = new ddsqos.QoS({
          reliability: { kind: ddsqos.ReliabilityKind.BestEffort }});
        let wr = dp.createWriter(topic, qos);
        // let rd = dp.createReader(topic);
        const sample = { userID: 13, message: 23 };

        wr.writeTs(sample, 1);

        expect(function() {
          wr.unregisterTs(sample, 2);
        }).to.not.throw(Error);
      });
  });

  describe('Writer with a reliable QoS', function() {
    it('Writer.dispose throws Error Writer has a reliable QoS', function() {
      let wqos = ddsqos.QoS.writerDefault();
      wqos.reliability =
        { kind: ddsqos.ReliabilityKind.Reliable, maxBlockingTime: 0 };

      let topic = createSampleTopic(dp, 'reliableQoSDisposeTopic');
      let wr = dp.createWriter(topic, wqos);

      expect(function() {
        wr.dispose({ userID: 0, message: 0 });
      }).to.throw(ddserr.DDSError).with.property('ddsErrCode',
        ddserr.DDSErrorCode.ILLEGAL_OPERATION);
    });

    it('Writer.disposeReliable succeeds with reliable QoS', async function() {
      let wqos = ddsqos.QoS.writerDefault();
      wqos.reliability =
        { kind: ddsqos.ReliabilityKind.Reliable, maxBlockingTime: 0 };

      let rqos = ddsqos.QoS.readerDefault();
      rqos.reliability =
        { kind: ddsqos.ReliabilityKind.Reliable, maxBlockingTime: 0 };

      let topic = createSampleTopic(dp, 'reliableQoSDisposeReliableTopic');

      let wr = dp.createWriter(topic, wqos);
      // let rd = dp.createReader(topic, rqos);
      const sample = { userID: 1, message: 2 };

      await wr.writeReliable(sample);

      expect(async function() {
        await wr.disposeReliable(sample);
      }).to.not.throw(Error);
    });

    it('Writer.disposeTs throws Error when Writer has reliable QoS',
      function() {
        let wqos = ddsqos.QoS.writerDefault();
        wqos.reliability =
          { kind: ddsqos.ReliabilityKind.Reliable, maxBlockingTime: 0 };

        let topic = createSampleTopic(dp, 'reliableQoSDisposeTopic');
        let wr = dp.createWriter(topic, wqos);

        expect(function() {
          wr.disposeTs({ userID: 0, message: 1 });
        }).to.throw(ddserr.DDSError).with.property('ddsErrCode',
          ddserr.DDSErrorCode.ILLEGAL_OPERATION);
      });

    it('Writer.disposeTsReliable succeeds when Writer has reliable QoS',
      async function() {
        let wqos = ddsqos.QoS.writerDefault();
        wqos.reliability =
          { kind: ddsqos.ReliabilityKind.Reliable, maxBlockingTime: 0 };

        let rqos = ddsqos.QoS.readerDefault();
        rqos.reliability =
          { kind: ddsqos.ReliabilityKind.Reliable, maxBlockingTime: 0 };

        let topic = createSampleTopic(dp, 'reliableQoSDisposeTsReliableTopic');

        let wr = dp.createWriter(topic, wqos);
        // let rd = dp.createReader(topic, rqos);
        const sample = { userID: 1, message: 2 };

        await wr.writeTsReliable(sample, 1);

        expect(async function() {
          await wr.disposeTsReliable(sample, 2);
        }).to.not.throw(Error);
      });

    it('Writer.unregister throws Error when Writer has reliable QoS',
      function() {
        let wqos = ddsqos.QoS.writerDefault();
        wqos.reliability =
          { kind: ddsqos.ReliabilityKind.Reliable, maxBlockingTime: 0 };

        let topic = createSampleTopic(dp, 'reliableQoSUnregisterTopic');

        let wr = dp.createWriter(topic, wqos);

        expect(function() {
          wr.unregister({ userID: 0, message: 1 });
        }).to.throw(ddserr.DDSError).with.property('ddsErrCode',
          ddserr.DDSErrorCode.ILLEGAL_OPERATION);
      });

    it('Writer.unregisterReliable succeeds when Writer has reliable QoS',
      async function() {
        let wqos = ddsqos.QoS.writerDefault();
        wqos.reliability =
          { kind: ddsqos.ReliabilityKind.Reliable, maxBlockingTime: 0 };
        let topic = createSampleTopic(dp, 'reliableQoSUnregisterReliableTopic');
        let wr = dp.createWriter(topic, wqos);

        let sample = { userID: 0, message: 0 };

        await wr.writeReliable(sample);

        expect(async function() {
          await wr.unregisterReliable(sample);
        }).to.not.throw(Error);
      });

    it('Writer.unregisterTs throws Error when Writer has reliable QoS',
      function() {
        let wqos = ddsqos.QoS.writerDefault();
        wqos.reliability =
          { kind: ddsqos.ReliabilityKind.Reliable, maxBlockingTime: 0 };

        let topic = createSampleTopic(dp, 'reliableQoSUnregisterTsTopic');
        let wr = dp.createWriter(topic, wqos);

        expect(function() {
          wr.unregisterTs({ userID: 0, message: 1 });
        }).to.throw(ddserr.DDSError).with.property('ddsErrCode',
          ddserr.DDSErrorCode.ILLEGAL_OPERATION);
      });

    it('Writer.unregisterTsReliable succeeds when Writer has reliable QoS',
      async function() {
        let wqos = ddsqos.QoS.writerDefault();
        wqos.reliability =
          { kind: ddsqos.ReliabilityKind.Reliable, maxBlockingTime: 0 };

        let rqos = ddsqos.QoS.readerDefault();
        rqos.reliability =
          { kind: ddsqos.ReliabilityKind.Reliable, maxBlockingTime: 0 };

        let topic = createSampleTopic(dp, 'reliableQoSUnregisterTsTopic');

        let wr = dp.createWriter(topic, wqos);
        // let rd = dp.createReader(topic, rqos);
        const sample = { userID: 1, message: 2 };

        await wr.writeTsReliable(sample, 1);

        expect(async function() {
          await wr.unregisterTsReliable(sample, 1);
        }).to.not.throw(Error);
      });
  });
});

/**
 * Builtin topic tests.
 */
describe('Builtin topic tests', function() {
  var dp = null;

  before(function() {
    dp = new dcps.Participant();
  });

  function stringToByteArray(str) {
    let byteArray = [];
    for (let i = 0; i < str.length; i++) {
      byteArray.push(str[i].charCodeAt(0));
    }
    return byteArray;
  }

  function compareArrays(a1, a2) {
    if (a1.length !== a2.length) {
      return false;
    }

    for (let i = 0; i < a1.length; i++) {
      if (a1[i] !== a2[i]) {
        return false;
      }
    }

    return true;
  }

  it('Can use DCPSParticipant to detect other participants',
    async function() {
      this.timeout(10000);
      let participantUserData = 'participant user data';
      // we want to detect dp2 with a reader on DCPSParticipant
      let dpqos = new ddsqos.QoS(); // ddsqos.QoS.participantDefault();
      dpqos.userdata = { value: participantUserData };
      let rawData = stringToByteArray(participantUserData);

      // eslint-disable-next-line no-unused-vars
      let dp2 = new dcps.Participant(dcps.DDSConstants.DDS_DOMAIN_DEFAULT,
        dpqos);

      let builtinSub = dp.getBuiltinSubscriber();
      let builtinReader = builtinSub.findBuiltinDataReader('DCPSParticipant');

      while (true) {
        let dataSet = builtinReader.take(1);
        if (dataSet.length > 0) {
          if (dataSet[0].info.valid_data) {
            if (compareArrays(dataSet[0].sample.user_data.value, rawData)) {
              break;
            }
          }
        }
      }

    });

  it('Can use DCPSTopic to detect topics', async function() {
    this.timeout(10000);
    let topicTopicData = 'topic topic data';
    let tqos = ddsqos.QoS.topicDefault(); // new ddsqos.QoS();
    tqos.topicdata = { value: topicTopicData };
    let rawData = stringToByteArray(topicTopicData);
    // eslint-disable-next-line no-unused-vars
    let newTopic = createSampleTopic(dp, 'DCPSTopicTestTopic', tqos);

    let builtinSub = dp.getBuiltinSubscriber();
    let builtinReader = builtinSub.findBuiltinDataReader('DCPSTopic');

    let queryCond = builtinReader
      .createQueryCondition(dcps.StateMask.sample.not_read, 'name=%0',
        ['DCPSTopicTestTopic']);
    let ws = new dcps.Waitset();
    ws.attach(queryCond);

    await ws.wait(SEC_TO_NANO(1));

    let dataSet = builtinReader.takeCond(1, queryCond);
    expect(dataSet[0].sample.topic_data.value).to.deep.equal(rawData);
  });

  it('Can use DCPSPublication to detect data writers', async function() {
    this.timeout(10000);
    let publisherGroupData = 'publisher group data';
    let wqos = ddsqos.QoS.writerDefault();
    wqos.groupdata = { value: publisherGroupData };
    let rawData = stringToByteArray(publisherGroupData);
    let newTopic = createSampleTopic(dp, 'DCPSPublicationTestTopic');
    // eslint-disable-next-line no-unused-vars
    let newWriter = dp.createWriter(newTopic, wqos);

    let builtinSub = dp.getBuiltinSubscriber();
    let builtinReader = builtinSub.findBuiltinDataReader('DCPSPublication');

    let queryCond = builtinReader
      .createQueryCondition(dcps.StateMask.sample.not_read, 'topic_name=%0',
        ['DCPSPublicationTestTopic']);

    let ws = new dcps.Waitset();
    ws.attach(queryCond);

    await ws.wait(SEC_TO_NANO(1));

    let dataSet = builtinReader.takeCond(1, queryCond);
    expect(dataSet[0].sample.group_data.value).to.deep.equal(rawData);
  });

  it('Can use DCPSSubscription to detect data readers', async function() {
    this.timeout(10000);
    let subscriberGroupData = 'subscriber group data';
    let rqos = ddsqos.QoS.readerDefault();
    rqos.groupdata = { value: subscriberGroupData };
    let rawData = stringToByteArray(subscriberGroupData);
    let newTopic = createSampleTopic(dp, 'DCPSSubscriptionTestTopic');
    // eslint-disable-next-line no-unused-vars
    let newWriter = dp.createReader(newTopic, rqos);

    let builtinSub = dp.getBuiltinSubscriber();
    let builtinReader = builtinSub.findBuiltinDataReader('DCPSSubscription');

    let queryCond = builtinReader
      .createQueryCondition(dcps.StateMask.sample.not_read, 'topic_name=%0',
        ['DCPSSubscriptionTestTopic']);

    let ws = new dcps.Waitset();
    ws.attach(queryCond);

    await ws.wait(SEC_TO_NANO(1));

    let dataSet = builtinReader.takeCond(1, queryCond);
    expect(dataSet[0].sample.group_data.value).to.deep.equal(rawData);
  });
});

describe('Communication status of topic, reader and writer tests',
  function() {
    let dp = null;
    let topic = null;
    let writer = null;
    let reader = null;

    before(function() {
      dp = new dcps.Participant();
      topic = createSampleTopic(dp, 'sampleHelloWorldTopic');
      writer = dp.createWriter(topic);
      reader = dp.createReader(topic);
    });

    after(async function() {
      this.timeout(SEC_TO_MILI(20));
      await dp.delete();
    });

    it('get inconsistentTopicStatus test', function() {
      const status = topic.inconsistentTopicStatus;
      expect(status).to.have.all.keys('totalCount', 'totalCountChange');
      expect(status.totalCount).to.be.a('number');
      expect(status.totalCountChange).to.be.a('number');
    });

    it('get publicationMatchedStatus test', function() {
      const status = writer.publicationMatchedStatus;
      expect(status).to.have.all.keys(
        'totalCount',
        'totalCountChange',
        'currentCount',
        'currentCountChange',
        'lastSubscriptionHandle'
      );
      expect(status.totalCount).to.be.a('number');
      expect(status.totalCountChange).to.be.a('number');
      expect(status.currentCount).to.be.a('number');
      expect(status.currentCountChange).to.be.a('number');
      expect(status.lastSubscriptionHandle).to.be.a('number');
    });

    it('get livelinessLostStatus test', function() {
      const status = writer.livelinessLostStatus;
      expect(status).to.have.all.keys(
        'totalCount',
        'totalCountChange'
      );
      expect(status.totalCount).to.be.a('number');
      expect(status.totalCountChange).to.be.a('number');
    });

    it('get offeredDeadlineMissedStatus test', function() {
      const status = writer.offeredDeadlineMissedStatus;
      expect(status).to.have.all.keys(
        'totalCount',
        'totalCountChange',
        'lastInstanceHandle'
      );
      expect(status.totalCount).to.be.a('number');
      expect(status.totalCountChange).to.be.a('number');
      expect(status.lastInstanceHandle).to.be.a('number');
    });

    it('get offeredIncompatibleQosStatus test', function() {
      const status = writer.offeredIncompatibleQosStatus;
      expect(status).to.have.all.keys(
        'totalCount',
        'totalCountChange',
        'lastPolicyId'
      );
      expect(status.totalCount).to.be.a('number');
      expect(status.totalCountChange).to.be.a('number');
      expect(status.lastPolicyId).to.be.a('number');
    });

    it('get subscriptionMatchedStatus test', function() {
      const status = reader.subscriptionMatchedStatus;
      expect(status).to.have.all.keys(
        'totalCount',
        'totalCountChange',
        'currentCount',
        'currentCountChange',
        'lastPublicationHandle'
      );
      expect(status.totalCount).to.be.a('number');
      expect(status.totalCountChange).to.be.a('number');
      expect(status.currentCount).to.be.a('number');
      expect(status.currentCountChange).to.be.a('number');
      expect(status.lastPublicationHandle).to.be.a('number');
    });

    it('get livelinessChangedStatus test', function() {
      const status = reader.livelinessChangedStatus;
      expect(status).to.have.all.keys(
        'aliveCount',
        'notAliveCount',
        'aliveCountChange',
        'notAliveCountChange',
        'lastPublicationHandle'
      );
      expect(status.aliveCount).to.be.a('number');
      expect(status.notAliveCount).to.be.a('number');
      expect(status.aliveCountChange).to.be.a('number');
      expect(status.notAliveCountChange).to.be.a('number');
      expect(status.lastPublicationHandle).to.be.a('number');
    });

    it('get sampleRejectedStatus test', function() {
      const status = reader.sampleRejectedStatus;
      expect(status).to.have.all.keys(
        'totalCount',
        'totalCountChange',
        'lastReason',
        'lastInstanceHandle'
      );
      expect(status.totalCount).to.be.a('number');
      expect(status.totalCountChange).to.be.a('number');
      expect(status.lastReason).to.be.a('number');
      expect(status.lastInstanceHandle).to.be.a('number');
    });

    it('get sampleLostStatus test', function() {
      const status = reader.sampleLostStatus;
      expect(status).to.have.all.keys(
        'totalCount',
        'totalCountChange'
      );
      expect(status.totalCount).to.be.a('number');
      expect(status.totalCountChange).to.be.a('number');
    });

    it('get requestedDeadlineMissedStatus test', function() {
      const status = reader.requestedDeadlineMissedStatus;
      expect(status).to.have.all.keys(
        'totalCount',
        'totalCountChange',
        'lastInstanceHandle'
      );
      expect(status.totalCount).to.be.a('number');
      expect(status.totalCountChange).to.be.a('number');
      expect(status.lastInstanceHandle).to.be.a('number');
    });

    it('get requestedIncompatibleQosStatus test', function() {
      const status = reader.requestedIncompatibleQosStatus;
      expect(status).to.have.all.keys(
        'totalCount',
        'totalCountChange',
        'lastPolicyId'
      );
      expect(status.totalCount).to.be.a('number');
      expect(status.totalCountChange).to.be.a('number');
      expect(status.lastPolicyId).to.be.a('number');
    });

  });
