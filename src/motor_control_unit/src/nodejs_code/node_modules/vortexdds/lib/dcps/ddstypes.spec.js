/*
 *                         Vortex OpenSplice
 *
 *   This software and documentation are Copyright 2006 to 2019 ADLINK
 *   Technology Limited, its affiliated companies and licensors. All rights
 *   reserved.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

'use strict';
/* eslint-env node, mocha */

const dds = require('./index');
const expect = require('chai').expect;
const path = require('path');

function SEC_TO_MILI(n) {
  return n * 1000;
}

describe('Primitive dds types', function() {

  const idlName = 'test_data' + path.sep + 'ddstypes.idl';
  const idl = __dirname + path.sep + '..'
                + path.sep + '..' + path.sep + idlName;
  let dp = null;

  before(function() {
    dp = new dds.Participant();
  });

  after(async function() {
    this.timeout(SEC_TO_MILI(20));
    await dp.delete();
  });

  function getSamplesAfterReadWriteTest(
    typeSupport,
    topicName,
    sampleJSObjArr) {

    const topic = dp.createTopic(topicName, typeSupport);

    expect(topic).to.not.be.null;

    const qos = new dds.QoS({
      reliability: { kind: dds.ReliabilityKind.BestEffort }});

    const reader = dp.createReader(topic, qos);
    expect(reader).to.not.be.null;
    const writer = dp.createWriter(topic, qos);
    expect(writer).to.not.be.null;

    const numSamples = sampleJSObjArr.length;

    // write samples
    for (let i = 0; i < numSamples; i++) {
      const status = writer.write(sampleJSObjArr[i]);
      expect(status).to.be.equal(0);
    }

    // take samples
    const readArray = reader.take(numSamples);
    expect(readArray).to.not.be.null;
    expect(readArray.length).equals(numSamples);

    return readArray;
  }

  function testReadWriteSamples(typeSupport, topicName, sampleJSObjArr) {

    // Creates topic, reader, writer. Writes and takes samples.
    // Returns samples array after take.
    const readArray = getSamplesAfterReadWriteTest(
      typeSupport,
      topicName,
      sampleJSObjArr
    );

    // verify that the data read is equivalent to
    // data samples written out
    for (let i = 0; i < readArray.length; i++) {
      const sampleItem = readArray[i].sample;
      expect(sampleItem).deep.equal(sampleJSObjArr[i]);
    }
  }

  it('read and write long type samples', function(done) {

    dds.importIDL(idl).then((result) => {

      const typeSupport = result.get('TypeTest::TypeTestlong');

      const jsData = [{
        key: 2,
        cBefore: 5,
        testData: 0x01020304, // long
        cAfter: 9,
      },
      {
        key: 3,
        cBefore: 8,
        testData: 0x03040506, // long
        cAfter: 1,
      },
      {
        key: 4,
        cBefore: 6,
        testData: 0x04050607, // long
        cAfter: 7,
      }];

      testReadWriteSamples(typeSupport, 'TypeTestlongTopic', jsData);

      done();
    }).catch(function(err){
      done(new Error('Error in read/write TypeTestlong test ' + err));
    });

  });


  it('read and write longlong type samples', function(done) {

    dds.importIDL(idl).then((result) => {

      const typeSupport = result.get('TypeTest::TypeTestlonglong');

      const jsData = [{
        key: 2,
        cBefore: 5,
        testData: 9007199254740992, // long long
        cAfter: 9,
      },
      {
        key: 3,
        cBefore: 8,
        testData: -9007199254740992, // long long
        cAfter: 1,
      },
      {
        key: 4,
        cBefore: 6,
        testData: 0x04050607080000, // long long
        cAfter: 7,
      }];

      testReadWriteSamples(typeSupport, 'TypeTestlonglongTopic', jsData);

      done();
    }).catch(function(err){
      done(new Error('Error in read/write TypeTestlonglong test ' + err));
    });

  });

  it('read and write float type samples', function(done) {

    dds.importIDL(idl).then((result) => {

      const typeSupport = result.get('TypeTest::TypeTestfloat');

      const jsData = [{
        key: 2,
        cBefore: 5,
        testData: 0.125, // float
        cAfter: 9,
      },
      {
        key: 3,
        cBefore: 8,
        testData: -9.375, // float
        cAfter: 1,
      },
      {
        key: 4,
        cBefore: 6,
        testData: 5.0009765625, // float
        cAfter: 7,
      }];

      testReadWriteSamples(typeSupport, 'TypeTestfloatTopic', jsData);

      done();
    }).catch(function(err){
      done(new Error('Error in read/write TypeTestfloat test ' + err));
    });

  });

  it('read and write short type samples', function(done) {

    dds.importIDL(idl).then((result) => {

      const typeSupport = result.get('TypeTest::TypeTestshort');

      const jsData = [{
        key: 2,
        cBefore: 5,
        testData: 0x0105, // short
        cAfter: 9,
      },
      {
        key: 3,
        cBefore: 8,
        testData: 0x0203, // short
        cAfter: 1,
      },
      {
        key: 4,
        cBefore: 6,
        testData: 0x0409, // short
        cAfter: 7,
      }];

      testReadWriteSamples(typeSupport, 'TypeTestshortTopic', jsData);

      done();
    }).catch(function(err){
      done(new Error('Error in read/write TypeTestshort test ' + err));
    });

  });

  it('read and write char type samples', function(done) {

    dds.importIDL(idl).then((result) => {

      const typeSupport = result.get('TypeTest::TypeTestchar');

      const jsData = [{
        key: 2,
        cBefore: 5,
        testData: 3, // char 'a'
        cAfter: 9,
      },
      {
        key: 3,
        cBefore: 8,
        testData: 9, // char
        cAfter: 1,
      },
      {
        key: 4,
        cBefore: 6,
        testData: 2, // char
        cAfter: 7,
      }];

      testReadWriteSamples(typeSupport, 'TypeTestcharTopic', jsData);

      done();
    }).catch(function(err){
      done(new Error('Error in read/write TypeTestchar test ' + err));
    });

  });

  it('read and write octet type samples', function(done) {

    dds.importIDL(idl).then((result) => {

      const typeSupport = result.get('TypeTest::TypeTestoctet');

      const jsData = [{
        key: 2,
        cBefore: 5,
        testData: 11, // octet
        cAfter: 9,
      },
      {
        key: 3,
        cBefore: 8,
        testData: 24, // octet
        cAfter: 1,
      },
      {
        key: 4,
        cBefore: 6,
        testData: 17, // octet
        cAfter: 7,
      }];

      testReadWriteSamples(typeSupport, 'TypeTestoctetTopic', jsData);

      done();
    }).catch(function(err){
      done(new Error('Error in read/write TypeTestoctet test ' + err));
    });

  });

  it('read and write double type samples', function(done) {

    dds.importIDL(idl).then((result) => {

      const typeSupport = result.get('TypeTest::TypeTestdouble');

      const jsData = [{
        key: 2,
        cBefore: 5,
        testData: 9007199254740992.125, // double
        cAfter: 9,
      },
      {
        key: 3,
        cBefore: 8,
        testData: -9007199254740992.125, // double
        cAfter: 1,
      },
      {
        key: 4,
        cBefore: 6,
        testData: 9007199254740992.001953125, // double
        cAfter: 7,
      }];

      testReadWriteSamples(typeSupport, 'TypeTestdoubleTopic', jsData);

      done();
    }).catch(function(err){
      done(new Error('Error in read/write TypeTestdouble test ' + err));
    });

  });

  it('read and write string type samples', function(done) {

    dds.importIDL(idl).then((result) => {

      const typeSupport = result.get('TypeTest::TypeTeststring');

      const jsData = [{
        key: 2,
        cBefore: 5,
        testData: 'testdata_1', // string
        cAfter: 9,
      },
      {
        key: 3,
        cBefore: 8,
        testData: 'testdata_2', // string
        cAfter: 1,
      },
      {
        key: 4,
        cBefore: 6,
        testData: 'testdata_3', // string
        cAfter: 7,
      }];

      testReadWriteSamples(typeSupport, 'TypeTeststringTopic', jsData);

      done();
    }).catch(function(err){
      done(new Error('Error in read/write TypeTeststring test ' + err));
    });

  });

  it('read and write boolean type samples', function(done) {

    dds.importIDL(idl).then((result) => {

      const typeSupport = result.get('TypeTest::TypeTestbool');

      const jsData = [{
        key: 2,
        cBefore: 5,
        testData: true, // boolean
        cAfter: 9,
      },
      {
        key: 3,
        cBefore: 8,
        testData: false, // boolean
        cAfter: 1,
      },
      {
        key: 4,
        cBefore: 6,
        testData: true, // boolean
        cAfter: 7,
      }];

      testReadWriteSamples(typeSupport, 'TypeTestboolTopic', jsData);

      done();
    }).catch(function(err){
      done(new Error('Error in read/write TypeTestbool test ' + err));
    });

  });

  it('read and write unsigned long type samples', function(done) {

    dds.importIDL(idl).then((result) => {

      const typeSupport = result.get('TypeTest::TypeTestulong');

      const jsData = [{
        key: 2,
        cBefore: 5,
        testData: 8, // ulong
        cAfter: 9,
      },
      {
        key: 3,
        cBefore: 8,
        testData: 9, // ulong
        cAfter: 1,
      },
      {
        key: 4,
        cBefore: 6,
        testData: 3, // ulong
        cAfter: 7,
      }];

      testReadWriteSamples(typeSupport, 'TypeTestulongTopic', jsData);

      done();
    }).catch(function(err){
      done(new Error('Error in read/write TypeTestulong test ' + err));
    });

  });

  it('read and write unsigned longlong type samples', function(done) {

    dds.importIDL(idl).then((result) => {

      const typeSupport = result.get('TypeTest::TypeTestulonglong');

      const jsData = [{
        key: 2,
        cBefore: 5,
        testData: 0xFFFFFFFFFF000, // ulonglong
        cAfter: 9,
      },
      {
        key: 3,
        cBefore: 8,
        testData: 50000000, // ulonglong
        cAfter: 1,
      },
      {
        key: 4,
        cBefore: 6,
        testData: 500, // ulonglong
        cAfter: 7,
      }];

      testReadWriteSamples(typeSupport, 'TypeTestulonglongTopic', jsData);

      done();
    }).catch(function(err){
      done(new Error('Error in read/write TypeTestulonglong test ' + err));
    });

  });

  it('read and write unsigned short type samples', function(done) {

    dds.importIDL(idl).then((result) => {

      const typeSupport = result.get('TypeTest::TypeTestushort');

      const jsData = [{
        key: 2,
        cBefore: 5,
        testData: 4, // ushort
        cAfter: 9,
      },
      {
        key: 3,
        cBefore: 8,
        testData: 7, // ushort
        cAfter: 1,
      },
      {
        key: 4,
        cBefore: 6,
        testData: 2, // ushort
        cAfter: 7,
      }];

      testReadWriteSamples(typeSupport, 'TypeTestushortTopic', jsData);

      done();
    }).catch(function(err){
      done(new Error('Error in read/write TypeTestushort test ' + err));
    });

  });

  it('read and write enum type samples', function(done) {

    dds.importIDL(idl).then((result) => {

      const typeSupport = result.get('TypeTest::TypeTestenum');
      const myEnum = typeSupport.getClass('TypeTest::Color');

      expect(myEnum).is.not.null;

      const jsData = [{
        key: 2,
        cBefore: 5,
        testData: myEnum.RED.value, // enum
        cAfter: 9,
      },
      {
        key: 3,
        cBefore: 8,
        testData: myEnum.BLUE.value, // enum
        cAfter: 1,
      },
      {
        key: 4,
        cBefore: 6,
        testData: myEnum.GREEN.value, // enum
        cAfter: 7,
      }];

      testReadWriteSamples(typeSupport, 'TypeTestenumTopic', jsData);

      done();
    }).catch(function(err){
      done(new Error('Error in read/write TypeTestenum test ' + err));
    });

  });

  it('read and write array type samples', function(done) {

    dds.importIDL(idl).then((result) => {

      const typeSupport = result.get('TypeTest::TypeTestarray');

      const jsData = [{
        key: 2,
        cBefore: 5,
        testData: [1, 3, 4], // array of long
        cAfter: 9,
      },
      {
        key: 3,
        cBefore: 8,
        testData: [2, 1, 6], // array of long
        cAfter: 1,
      },
      {
        key: 4,
        cBefore: 6,
        testData: [3, 1, 0], // array of long
        cAfter: 7,
      }];

      testReadWriteSamples(typeSupport, 'TypeTestarrayTopic', jsData);

      done();
    }).catch(function(err){
      done(new Error('Error in read/write TypeTestarray test ' + err));
    });

  });

  it('read and write sequence type samples', function(done) {

    dds.importIDL(idl).then((result) => {

      const typeSupport = result.get('TypeTest::TypeTestseq');

      const jsData = [{
        key: 2,
        cBefore: 5,
        testData: [1, -6, 7], // sequence of long
        cAfter: 9,
      },
      {
        key: 3,
        cBefore: 8,
        testData: [], // sequence of long
        cAfter: 1,
      },
      {
        key: 4,
        cBefore: 6,
        testData: [-3, 2], // sequence of long
        cAfter: 7,
      }];

      testReadWriteSamples(typeSupport, 'TypeTestseqTopic', jsData);

      done();
    }).catch(function(err){
      done(new Error('Error in read/write TypeTestseq test ' + err));
    });

  });

  it('read and write bounded sequence type samples', function(done) {

    dds.importIDL(idl).then((result) => {

      const typeSupport = result.get('TypeTest::TypeTestboundedseq');

      const jsData = [{
        key: 2,
        cBefore: 5,
        testData: [1, 6, 7], // bounded sequence of long
        cAfter: 9,
      },
      {
        key: 3,
        cBefore: 8,
        testData: [], // bounded sequence of long
        cAfter: 1,
      },
      {
        key: 4,
        cBefore: 6,
        testData: [5], // bounded sequence of long
        cAfter: 7,
      }];

      testReadWriteSamples(typeSupport, 'TypeTestboundedseqTopic', jsData);

      done();
    }).catch(function(err){
      done(new Error('Error in read/write TypeTestboundedseq test ' + err));
    });

  });

  it('write bounded sequence type fails to write if sequence' +
  ' size is larger than bound' +
  ': (OSPL-12125)', function(done) {

    dds.importIDL(idl).then((result) => {

      const typeSupport = result.get('TypeTest::TypeTestboundedseq');
      // sequence bound is 3

      const jsData = [{
        key: 2,
        cBefore: 5,
        testData: [1, 6, 7, 9], // bounded sequence of long
        cAfter: 9,
      },
      {
        key: 4,
        cBefore: 6,
        testData: [5, 2, 1, 0, 3], // bounded sequence of long
        cAfter: 7,
      }];

      expect(function() {
        getSamplesAfterReadWriteTest(
          typeSupport,
          'TypeTestboundedseqNotEqualTopic',
          jsData);
      }).to.throw(Error);
      done();

    }).catch(function(err){
      done(new Error(
        'Error in read/write TypeTestboundedseq ignore extra data test ' + err
      ));
    });

  });

  it('read and write array of sequence type samples: ' +
  '(OSPL-12123)', function(done) {

    dds.importIDL(idl).then((result) => {

      const typeSupport = result.get('TypeTest::TypeTestseqarray');

      const jsData = [{
        key: 2,
        cBefore: 5,
        testData: [ // array of sequence of long
          [1],
          [8, 4, 3],
          [2, 3, 7],
        ],
        cAfter: 9,
      },
      {
        key: 3,
        cBefore: 8,
        testData: [ // array of sequence of long
          [3, 5, 1],
          [1, 4, 5],
          [7, 4, 2],
        ],
        cAfter: 1,
      },
      {
        key: 4,
        cBefore: 6,
        testData: [ // array of sequence of long
          [2, 6, 7],
          [5, 6, 1],
          [3, 1, 2],
        ],
        cAfter: 7,
      }];

      testReadWriteSamples(typeSupport, 'TypeTestseqarrayTopic', jsData);

      done();
    }).catch(function(err){
      done(new Error('Error in read/write TypeTestseqarray test ' + err));
    });

  });

  it('read and write nested struct type samples', function(done) {

    dds.importIDL(idl).then((result) => {

      const typeSupport = result.get('TypeTest::TypeTestnestedstruct');

      const jsData = [{
        key: 2,
        cBefore: 5,
        testData: { // nested struct
          cBefore: 1,
          testData: 3,
          cAfter: 8,
        },
        cAfter: 9,
      },
      {
        key: 3,
        cBefore: 8,
        testData: { // nested struct
          cBefore: 4,
          testData: 7,
          cAfter: 2,
        },
        cAfter: 1,
      },
      {
        key: 4,
        cBefore: 6,
        testData: { // nested struct
          cBefore: 8,
          testData: 2,
          cAfter: 0,
        },
        cAfter: 7,
      }];

      testReadWriteSamples(typeSupport, 'TypeTestnestedstructTopic', jsData);

      done();
    }).catch(function(err){
      done(new Error('Error in read/write TypeTestnestedstruct test ' + err));
    });

  });

  it('read and write nested struct type samples not equal test',
    function(done) {

      dds.importIDL(idl).then((result) => {

        const typeSupport = result.get('TypeTest::TypeTestnestedstruct');

        const jsData = [{
          key: 2,
          cBefore: 5,
          testData: { // nested struct
            cBefore: 1,
            testData: 3,
            cAfter: 8,
            cMore: 100,
          },
          cAfter: 9,
        },
        {
          key: 3,
          cBefore: 8,
          testData: { // nested struct
            cBefore: 4,
            testData: 7,
            cAfter: 2,
            cExtra: 100,
          },
          cAfter: 1,
        }];

        const readArray = getSamplesAfterReadWriteTest(
          typeSupport,
          'TypeTestnestedstructNotEqualTopic',
          jsData);

        // verify that the data read is equivalent to
        // data samples written out
        for (let i = 0; i < readArray.length; i++) {
          const sampleItem = readArray[i].sample;
          expect(sampleItem).deep.not.equal(jsData[i]);
        }

        done();
      }).catch(function(err){
        done(new Error(
          'Error in read/write TypeTestnestedstruct not equal test ' + err
        ));
      });

    });

  it('read and write array of nested struct type samples', function(done) {

    dds.importIDL(idl).then((result) => {

      const typeSupport = result.get('TypeTest::Typearrayofnestedstruct');
      const topic = dp.createTopic('TypearrayofnestedstructTopic', typeSupport);
      expect(topic).to.not.be.null;

      const qos = new dds.QoS({
        reliability: { kind: dds.ReliabilityKind.BestEffort }});

      const reader = dp.createReader(topic, qos);
      expect(reader).to.not.be.null;
      const writer = dp.createWriter(topic, qos);
      expect(writer).to.not.be.null;

      const jsData = [
        {
          key: 2,
          cBefore: 5,
          testData: [
            // Array of nested struct:
            // number of elements in the array is equal to
            // array size in the idl file (2)
            {
              cBefore: 3,
              testData: 6,
              cAfter: 1,
            },
            {
              cBefore: 7,
              testData: 0,
              cAfter: 2,
            },
          ],
          cAfter: 9,
        },
        {
          key: 3,
          cBefore: 6,
          testData: [
            // Array of nested struct:
            // number of elements in the array is equal to
            // array size in the idl file (2)
            {
              cBefore: 1,
              testData: 2,
              cAfter: 3,
            },
            {
              cBefore: 4,
              testData: 5,
              cAfter: 6,
            },
          ],
          cAfter: 10,
        },
      ];

      const numSamples = jsData.length;

      // write samples
      for (let i = 0; i < numSamples; i++) {
        const status = writer.write(jsData[i]);
        expect(status).to.be.equal(0);
      }

      // take samples
      const readArray = reader.take(numSamples);
      expect(readArray).to.not.be.null;
      expect(readArray.length).equals(numSamples);

      // verify that the data read is equivalent to
      // data samples written out
      for (let i = 0; i < readArray.length; i++) {
        const sampleItem = readArray[i].sample;
        expect(sampleItem.testData.length).to.equal(2);
        for (let j = 0; j < sampleItem.testData.length; j++) {
          expect(sampleItem.testData[j]).to.deep.equal(jsData[i].testData[j]);
        }
        expect(sampleItem).to.deep.equal(jsData[i]);
      }

      // write samples
      /* const status = writer.write(jsData1);
      expect(status).to.be.equal(0);


      // take samples
      const readArray = reader.take(2);
      expect(readArray).to.not.be.null;
      expect(readArray.length).equals(2);

      // verify that the data read is equivalent to
      // data samples written out
      const sampleItem = readArray[0].sample;
      expect(sampleItem.testData.length).to.equal(2);
      for (let j = 0; j < sampleItem.testData.length; j++) {
        expect(sampleItem.testData[j]).to.deep.equal(jsData.testData[j]);
      }
      expect(sampleItem).to.deep.equal(jsData);*/

      done();
    }).catch(function(err){
      done(new Error(
        'Error in read/write Typearrayofnestedstruct test: '
        + err
      ));
    });

  });

  it('Attempt to write array of nested structs with ' +
    'array size less than idl declared array size - expect error',
  function(done) {

    dds.importIDL(idl).then((result) => {

      const typeSupport = result.get('TypeTest::Typearrayofnestedstruct');
      const topic = dp.createTopic(
        'TypearrayofnestedstructTopic',
        typeSupport
      );
      expect(topic).to.not.be.null;

      const writer = dp.createWriter(topic);
      expect(writer).to.not.be.null;

      const jsData = {
        key: 2,
        cBefore: 5,
        testData: [
          // Array of nested struct:
          // number of elements in the array (1) is less
          // than the array element size given in the idl file (2)
          {
            cBefore: 7,
            testData: 0,
            cAfter: 2,
          },
        ],
        cAfter: 9,
      };

      expect(function() {
        writer.write(jsData);
      }).to.throw(Error);
      done();
    }).catch(function(err){
      done(new Error('Typearrayofnestedstruct test: ' + err));
    });

  });

  it('Attempt to write array of nested structs with length ' +
    'greater than idl defined array size - expect error',
  function(done) {

    dds.importIDL(idl).then((result) => {

      const typeSupport = result.get('TypeTest::Typearrayofnestedstruct');
      const topic = dp.createTopic(
        'TypearrayofnestedstructTopic',
        typeSupport
      );
      expect(topic).to.not.be.null;

      const writer = dp.createWriter(topic);
      expect(writer).to.not.be.null;

      const jsData = {
        key: 2,
        cBefore: 5,
        testData: [
          // Array of nested struct:
          // number of elements in the array (3) is greater
          // than the array element size given in the idl file (2)
          {
            cBefore: 1,
            testData: 2,
            cAfter: 3,
          },
          {
            cBefore: 4,
            testData: 5,
            cAfter: 6,
          },
          {
            cBefore: 7,
            testData: 8,
            cAfter: 9,
          },
        ],
        cAfter: 10,
      };

      expect(function() {
        writer.write(jsData);
      }).to.throw(Error);
      done();
    }).catch(function(err){
      done(new Error('Typearrayofnestedstruct test: ' + err));
    });

  });

  it('read and write multidimensional array type samples',
    function(done) {

      dds.importIDL(idl).then((result) => {

        const typeSupport = result.get('TypeTest::TypeTestMultiArrayStruct');

        const jsData = [{
          key: 2,
          cBefore: 5,
          testData: [[16, 5, 12], [7, 8, 14]], // array 2x3
          cAfter: 9,
        },
        {
          key: 3,
          cBefore: 8,
          testData: [[30, 11, 70], [18, 12, 72]], // array 2x3
          cAfter: 1,
        },
        {
          key: 4,
          cBefore: 6,
          testData: [[4, 6, 8], [3, 5, 7]], // array 2x3
          cAfter: 7,
        }];

        testReadWriteSamples(typeSupport, 'TypeTestMultiArrayTopic', jsData);

        done();
      }).catch(function(err){
        done(new Error('Error in read/write TypeTestMultiArray test ' + err));
      });

    });

});
