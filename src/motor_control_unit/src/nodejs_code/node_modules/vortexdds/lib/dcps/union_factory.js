/*
 *                         Vortex OpenSplice
 *
 *   This software and documentation are Copyright 2006 to 2019 ADLINK
 *   Technology Limited, its affiliated companies and licensors. All rights
 *   reserved.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

'use strict';
const Enum = require('enum');
const cico = require('./cico');
const ET = require('elementtree');
ET.XML;
const _SWITCHTYPE_TAG = 'SwitchType';
const _CASE_TAG = 'Case';
const _NAME_ATTRIBUTE = 'name';
const _VALUE_ATTRIBUTE = 'value';
const _TYPE_TAG = 'Type';
const _LABEL_TAG = 'Label';
const _ARRAY_TAG = 'Array';
const _DEFAULT_TAG = 'Default';
const _MODULE_SEPARATOR = '::';

module.exports.generateUnionClass = function(element, module, typeSupport){

  const MyUnion = class extends cico.Union {

    constructor(init_obj, discriminator = null) {
      super();
      this._setData(init_obj, discriminator);
    }

    _setData(init_obj, discriminator = null){
      if (typeof init_obj === 'undefined') {
      } else if (Object.keys(init_obj).length === 1) {
        const case_name = Object.keys(init_obj)[0];
        let types = this.constructor['v.types'];
        if (types.get(case_name) !== undefined) {
          this[case_name] = init_obj[case_name];
        } else {
          throw new TypeError('argument property must be a valid case name');
        }

        if (discriminator !== null){
          this._d = discriminator;
        }
        if (this._d === undefined){
          throw new TypeError('discriminator is undefined');
        }
      } else {
        throw new TypeError('argument has have one property, ' +
            'which must be a case name');
      }
    }

    toJSON(arg_ignored) {
      const obj = {};
      // const cases = this.constructor['d.cases'];
      // const case_name = cases.get(this._d);
      const case_name = this.constructor.getCaseName(this._d);
      obj[case_name] = this[case_name];
      return obj;
    }

    get discriminator() {
      return this._d;
    }

  };

  _processXMLElement(element, module, typeSupport, MyUnion);

  return MyUnion;

};

function _processXMLElement(element, module, typeSupport, MyUnion){

  let _SwitchType = null;
  let _SwitchTypeTag = null;
  let _cases = new Map();
  let _types = new Map();

  for (let child of element.getchildren()){
    if (child.tag === _SWITCHTYPE_TAG){
      if (child.getItem(0).tag === _TYPE_TAG){
        // switchType is an Enum
        let typeName = child.getItem(0).attrib[_NAME_ATTRIBUTE];
        if ((module !== null)
          && (module !== '')
          && (!typeName.includes(_MODULE_SEPARATOR))){
          typeName = module + _MODULE_SEPARATOR + typeName;
        }
        let referenceType = typeSupport.getClass(typeName);
        _SwitchType = referenceType;
      } else { // handle primitive types as switch type
        let switchName = child.getItem(0).tag;
        _SwitchType = typeSupport._getPrimitiveRefTypeFor(switchName);
        _SwitchTypeTag = switchName;
      }
    } else if (child.tag === _CASE_TAG){
      // for each case we need to:
      // add a getter and setter
      // add entry to _cases
      // add entry to _types

      let caseName = child.attrib[_NAME_ATTRIBUTE]; // "ui8"
      let caseType;
      let switchValue;
      let switchValues = [];
      let isDefaultCase = false;

      for (let subChild of child.getchildren()){
        let tag = subChild.tag;

        if (tag === _TYPE_TAG){
          let name = subChild.attrib[_NAME_ATTRIBUTE];
          if ((module !== null)
                && (module !== '')
                && (!name.includes(_MODULE_SEPARATOR))){
            name = module + _MODULE_SEPARATOR + name;
          }
          caseType = typeSupport.getClass(name);
        } else if (tag === _LABEL_TAG){
          let value = subChild.attrib[_VALUE_ATTRIBUTE];
          if (_SwitchType instanceof Enum) {
            switchValue = _SwitchType.get(value);
          } else {
            switchValue = value;
            if (_SwitchTypeTag !== null){
              // convert the string switchValue to a number or boolean
              switchValue = _convertSwitchValue(_SwitchTypeTag, value);
            }
          }
          // a case can have more than one label value
          switchValues[switchValues.length] = switchValue;
        } else if (tag === _ARRAY_TAG) {
          caseType = typeSupport._getArrayType(subChild, module);

        // else "Default" tag
        } else if (tag === _DEFAULT_TAG){
          isDefaultCase = true;

        } else { // tag is a primitive
          caseType = typeSupport._getPrimitiveRefTypeFor(tag);
        }

      }

      // for each case we need to :
      //   add entry to _cases
      //   add entry to _types
      //   add a getter and setter

      _types.set(caseName, caseType);

      if (isDefaultCase){
        _processCaseDefault(caseName, _SwitchType, _cases, MyUnion);
      } else {
        _processCase(caseName, switchValues, _cases, MyUnion);
      }

    }
  }

  MyUnion['d.type'] = _SwitchType;
  MyUnion['v.types'] = _types;
  MyUnion['d.cases'] = _cases;

  MyUnion.getCaseName = function(d) {
    let caseName;
    caseName = MyUnion['d.cases'].get(d);

    if (caseName === undefined){
      caseName = MyUnion['d.cases'].get(_DEFAULT_TAG);
    }

    return caseName;
  };

}

function _processCase(caseName, switchValues, _cases, MyUnion){
  for (let index = 0; index < switchValues.length; index++) {
    let v = switchValues[index];
    _cases.set(v, caseName);
  }
  let defaultSwitchValue = switchValues[0];

  Object.defineProperty(MyUnion.prototype, caseName, {
    get() {
      if (!switchValues.includes(this._d)) {
        throw ReferenceError('not selected by discriminator');
      } else {
        return this._v;
      }
    },
    set(v) {
      this._d = defaultSwitchValue;
      this._v = v;
    },
  });

}

function _processCaseDefault(caseName, _SwitchType, _cases, MyUnion){
  _cases.set(_DEFAULT_TAG, caseName);

  // calculate default switch value
  let defaultSwitchValue;

  if (_SwitchType instanceof Enum){
    for (let i = 0; i < _SwitchType.enums.length; i++) {
      let eItem = _SwitchType.enums[i];
      if (_cases.get(eItem) === undefined){
        defaultSwitchValue = eItem;
        break;
      }
    }
  }

  Object.defineProperty(MyUnion.prototype, caseName, {
    get() {
      return this._v;
    },
    set(v) {
      this._d = defaultSwitchValue;
      this._v = v;
    },
  });
}

function _convertSwitchValue(switchTypeTag, switchValue){
  let convertedSwitchValue;
  // Need to convert switchValue into
  if (switchTypeTag === 'Boolean'){
    convertedSwitchValue = (switchValue === 'True');
  } else if (switchTypeTag === 'Char'){
    convertedSwitchValue = switchValue.charCodeAt(0);
  } else {
    // convert to number
    convertedSwitchValue = Number(switchValue);
  }
  return convertedSwitchValue;
}
