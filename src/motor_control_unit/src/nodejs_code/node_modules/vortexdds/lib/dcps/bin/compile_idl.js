#!/usr/bin/env node

/*
 *                         Vortex OpenSplice
 *
 *   This software and documentation are Copyright 2006 to 2019 ADLINK
 *   Technology Limited, its affiliated companies and licensors. All rights
 *   reserved.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

/**
  * The purpose of this script is to find all the idl files in
  * the current working directory, compile them and write the
  * parse result to the 'cache' file location
  */

'use strict';
const path = require('path');
const fs = require('fs');
const { spawn } = require('child_process');

/**
 * This function parses idl file from the given path and writes
 * the result to an xml file.
 * For invalid idl file it returns a promise with an
 * error code.
 * @param {string} idlPath path of the idl file
 * @returns {Promise}
 * @ignore
 */
function parseIdlAndGenerateXML(idlPath) {

  const promise = new Promise(function(resolve, reject) {

    let result = '';
    // No, didn't find the file, spawn idlpp...
    const childProcess = spawn('idlpp', ['-l', 'pythondesc', idlPath]);

    childProcess.stdout.on('data', function(data) {
      result += data.toString();
    });

    childProcess.stderr.on('data', function(data) {
      result += data.toString();
    });

    childProcess.on('close', function(code) {
      if (code !== 0) {
        console.log(result);
        let error = new Error(result);
        error.code = code;
        reject(error);
      }
      // check for evaluation header, which is problematic
      const evalHeaderRE = /[^\n]*EVALUATION VERSION\r?\n/;
      if (evalHeaderRE.test(result)) {
        result = result.replace(evalHeaderRE, '');
      }

      // write the parse result to the 'cache' file location
      fs.writeFileSync(idlPath + '.xml', result);
      resolve(0);
    });
  });

  return promise;
}

/**
 * This asynchonous function starts with the current working
 * directory path, finds all the idl files recursively and
 * calls the parseIdlAndGenerateXML function.
 * @param {string} [startPath] file or directory path
 * @returns {number} On success returns 0, otherwise, returns
 * a non zero exitcode
 * @ignore
 */
async function compileIDL(startPath = process.cwd()) {
  let exitcode = 0;
  try {
    let retcode = 0;
    const filter = '.idl';

    if (!fs.existsSync(startPath)) {
      console.log(startPath + ' dir not found');
      return 1;
    }

    const files = fs.readdirSync(startPath);

    for (let i = 0; i < files.length; i++) {
      const filepath = path.join(startPath, files[i]);
      const stat = fs.statSync(filepath);

      if (stat.isDirectory() && files[i] !== 'node_modules') {
        retcode = await compileIDL(filepath); // recurse
        if (retcode !== 0) {
          exitcode = retcode;
        }
      } else if (filepath.endsWith(filter)) {
        try {
          await parseIdlAndGenerateXML(filepath);
        } catch (err) {
          exitcode = err.code;
        }
      }
    }
  } catch (error) {
    console.log('Error: ' + error.message);
    if (error.code !== undefined) {
      exitcode = error.code;
    }
  }

  return exitcode;
}

async function main() {
  let code = 0;
  try {
    code = await compileIDL();
  } catch (error) {
    console.log('Error: ' + error.message);
    if (error.code !== undefined) {
      code = error.code;
    }
  }
  process.exit(code);
}

main();
