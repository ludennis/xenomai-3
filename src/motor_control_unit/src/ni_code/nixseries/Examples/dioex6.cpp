/*
 * dioex6.cpp
 *   Continuous hardware-timed digital output with the Watchdog Timer
 *
 * dioex6 generates a digital waveform using hardware timing and monitors
 * device communication using the Watchdog Timer. After configuring the
 * Watchdog Timer, dioex6 programs the DO subsystem's timing and channel
 * parameters. dioex6 then creates a simple incrementing digital waveform, and
 * configures and starts the DMA channel before sending a software start
 * trigger. For 10 seconds, data is written to an optimized DMA buffer and
 * generated by the device until dioex6 trips the Watchdog. For the next 2
 * seconds, dioex6 waits and shows the programmed safe states before stopping
 * the timing engine and shutting down DMA. Finally, dioex6 restores the
 * hardware's previous state.
 *
 * Example Features (! means highlighted, * means default)
 * Device
 *   Operation       : digital output
 * ! Safety          : Watchdog Timer (WDT)
 * ! WDT mode        : safe states (*), tri-state, or freeze
 * ! WDT safe states : 0x55555555
 * ! WDT timeout     : 1e6 bus clock cycles
 * Channel
 *   Channels        : port0
 *   Scaling         : none
 *   Line mask       : all lines
 * Timing
 *   Sample mode     : continuous
 *   Timing mode     : hardware-timed
 *   Clock source    : on-board oscillator
 *   Clock rate      : 200 Hz
 * Trigger
 *   Start trigger   : software
 *   Reference trig  : not supported
 *   Pause trigger   : none
 * Write Buffer
 *   Data transfer   : optimized scatter-gather DMA ring
 * ! DMA transfer    : the buffer is optimized to maximize throughput
 *   DMA buffer      : wait for new data
 * Behavior
 *   Runtime         : 10 seconds
 * ! WDT hold        : 2 seconds in safe state
 *
 * External Connections
 *   port0           : observe with a logic analyzer
 *
 * Copyright 2011 National Instruments
 * License: NATIONAL INSTRUMENTS SOFTWARE LICENSE AGREEMENT
 *   Refer to "MHDDK License Agreement.pdf" in the root of this distribution.
 *
 */

#include <memory> // For auto_ptr<T>
#include <stdio.h>
#include <time.h>
#include <vector>

// OS Interface
#include "osiBus.h"

// Chip Objects
#include "tXSeries.h"

// Chip Object Helpers
#include "dataHelper.h"
#include "devices.h"
#include "dio/dioHelper.h"
#include "outTimer/doHelper.h"
#include "simultaneousInit.h"
#include "streamHelper.h"

// DMA Support
#include "CHInCh/dmaErrors.h"
#include "CHInCh/dmaProperties.h"
#include "CHInCh/tCHInChDMAChannel.h"

void test(iBus* bus)
{
   /*********************************************************************\
   |
   |   Example parameters
   |
   \*********************************************************************/

   //
   // Feature Parameters (modify these to exercise the example)
   //

   // Device parameters
   const nDO::tDO_WDT_Mode_t wdtMode = nDO::kWDT_SafeValue; // Arbitrary, go to safe states when timer expires
   const u32 safeStates = 0x55555555; // Arbitrary, alternating high-low in this example
   const u32 wdtTimeout = 1000000;    // Arbitrary, 1M bus clock periods

   // Channel parameters
   u32 lineMaskPort0 = 0xFFFFFFFF; // Use all of the lines in port0
   tBoolean tristateOnExit = kTrue;
   u32 defaultState = 0x0;

   // Timing parameters
   const u32 samplePeriod = 500000; // Rate: 100 MHz / 500e3 = 200 Hz

   // Buffer parameters
   u32 sampsPerChan = 1024;
   const u32 dmaBufferFactor = 16;

   // Behavior parameters
   const f64 runTime = 10;
   const f64 watchdogTime = 2;

   //
   // Fixed or calculated parameters (do not modify these)
   //

   // Device parameters
   u32 watchdogToggle = 0;
   const u16 FEED = 0xFEED;    // 1st control value to reset the timer
   const u16 FOOD = 0xF00D;    // 2nd control value to reset the timer
   const u16 PAUSE = 0x1234;   // Control value that will pause the timer
   const u16 START = 0x5678;   // Control value that will resume the timer
   const u16 KILL = 0xDEAD;    // Control value to expire the timer immediately
   const u16 RESET = 0xACED;   // Control value to reset the timer
   nNIOSINT100_mUnused(PAUSE);

   // Channel parameters
   u32 port0Length = 0;

   // Timing parameters
   const nOutTimer::tOutTimer_Continuous_t operationType = nOutTimer::kContinuousOp;
   const u32 sampleDelay = 2; // Wait N TB3 ticks after the start trigger before clocking (N must be >= 2)

   // Trigger parameters
   const tBoolean triggerOnce = kTrue;

   // Buffer parameters
   tBoolean allowRegeneration = kFalse;
   tBoolean dataRegenerated = kFalse; // Has the DMA channel regenerated old data?
   u32 bytesWritten = 0;   // Bytes written so far to the DMA buffer
   u32 availableSpace = 0; // Space in the DMA buffer
   const nNISTC3::tDMAChannelNumber dmaChannel = nNISTC3::kDO_DMAChannel;

   u32 sampleSizeInBytes;
   u32 writeSizeInBytes;
   u32 dmaSizeInBytes;
   nDO::tDO_DataWidth_t dataWidth;
   nDO::tDO_Data_Lane_t dataLane;

   // Using a vector as a self deleting byte buffer
   std::vector<u8> rawData;
   u8* rawData8 = NULL;
   u32* rawData32 = NULL;

   // Behavior parameters
   f64 elapsedTime = 0; // How long has the generation been running?
   clock_t start;
   const f64 rlpTimeout = 5; // Wait 5 seconds for a register operation before breaking
   clock_t rlpStart;
   f64 rlpElapsedTime;

   // Bookkeeping
   nMDBG::tStatus2 status;
   nBrdServices::tBrdSrv_WatchdogTimerStateMachineSt_t wdtStatus;
   tBoolean doErrored = kFalse; // Did the DO subsystem have an error?
   nOutTimer::tOutTimer_Error_t fifoUnderflow = nOutTimer::kNo_error;
   nOutTimer::tOutTimer_Error_t clkOverrun = nOutTimer::kNo_error;
   tBoolean dmaErrored = kFalse; // Did the DMA channel have an error?
   nMDBG::tStatus2 dmaErr;
   tAddressSpace bar0;
   bar0 = bus->createAddressSpace(kPCI_BAR0);

   /*********************************************************************\
   |
   |   Initialize the generation
   |
   \*********************************************************************/

   //
   // Open, detect, and initialize the X Series device
   //

   tXSeries device(bar0, &status);

   const nNISTC3::tDeviceInfo* deviceInfo = nNISTC3::getDeviceInfo(device, status);
   if (status.isFatal())
   {
      printf("Error: Cannot identify device (%d).\n", status.statusCode);
      return;
   }

   if (deviceInfo->isSimultaneous) nNISTC3::initializeSimultaneousXSeries(device, status);

   // Determine the size of Port 0
   port0Length = deviceInfo->port0Length;

   if (port0Length == 32)
   {
      // Port 0 has 32 lines for hardware-timed DIO
      lineMaskPort0 &= static_cast<u32>(nDI::nDI_FIFO_Data_Register::nCDI_FIFO_Data::kMask);
      dataWidth = nDO::kDO_FourBytes;
      dataLane = nDO::kDO_DataLane0;  // Doesn't matter with 4-byte data, ignored
      sampleSizeInBytes = 4;
   }
   else
   {
      // Port 0 has 8 lines for hardware-timed DIO
      lineMaskPort0 &= static_cast<u32>(nDI::nDI_FIFO_Data_Register8::nCDI_FIFO_Data8::kMask);
      dataWidth = nDO::kDO_OneByte;
      dataLane = nDO::kDO_DataLane0;
      sampleSizeInBytes = 1;
   }

   // Set the buffer parameters
   writeSizeInBytes = sampsPerChan * sampleSizeInBytes;
   dmaSizeInBytes = dmaBufferFactor * writeSizeInBytes;
   rawData.assign(writeSizeInBytes, 0);
   rawData8 = &rawData[0];
   rawData32 = reinterpret_cast<u32*>(&rawData[0]);

   //
   // Create subsystem helpers
   //

   nNISTC3::doHelper doHelper(device.DO, device.DO.DO_Timer, status);
   nNISTC3::dioHelper dioHelper(device.DI, device.DO, status);
   dioHelper.setTristate(tristateOnExit, status);
   nNISTC3::streamHelper streamHelper(device.DOStreamCircuit, device.CHInCh, status);

   //
   // Validate the Feature Parameters
   //

   // Ensure at least two updates
   if (sampsPerChan < 2)
   {
      printf("Error: Samples per channel (%u) must be 2 or greater.\n", sampsPerChan);
      status.setCode(kStatusBadParameter);
      return;
   }

   /*********************************************************************\
   |
   |   Program peripheral subsystems
   |
   \*********************************************************************/

   //
   // Program the Watchdog Timer
   //

   // Outstanding Watchdog Timer expirations prevent hardware programming, so
   // acknowledge any that may have asserted and disable the Watchdog Timer
   // for programming.
   device.BrdServices.WatchdogConfiguration.writeWatchdogIntTrigEn(kFalse, &status);
   device.BrdServices.WatchdogControl.writeRegister(RESET, &status);

   // Set the timeout in bus clock period
   device.BrdServices.WatchdogTimeoutRegister.writeRegister(wdtTimeout, &status);

   // Set the timeout action
   device.DO.DO_WDT_ModeSelect1_Register.setDO_WDT_ModeD0(wdtMode, &status);
   device.DO.DO_WDT_ModeSelect1_Register.setDO_WDT_ModeD1(wdtMode, &status);
   device.DO.DO_WDT_ModeSelect1_Register.setDO_WDT_ModeD2(wdtMode, &status);
   device.DO.DO_WDT_ModeSelect1_Register.setDO_WDT_ModeD3(wdtMode, &status);
   device.DO.DO_WDT_ModeSelect1_Register.setDO_WDT_ModeD4(wdtMode, &status);
   device.DO.DO_WDT_ModeSelect1_Register.setDO_WDT_ModeD5(wdtMode, &status);
   device.DO.DO_WDT_ModeSelect1_Register.setDO_WDT_ModeD6(wdtMode, &status);
   device.DO.DO_WDT_ModeSelect1_Register.setDO_WDT_ModeD7(wdtMode, &status);
   if (port0Length == 32)
   {
      device.DO.DO_WDT_ModeSelect1_Register.setDO_WDT_ModeD8(wdtMode, &status);
      device.DO.DO_WDT_ModeSelect1_Register.setDO_WDT_ModeD9(wdtMode, &status);
      device.DO.DO_WDT_ModeSelect1_Register.setDO_WDT_ModeD10(wdtMode, &status);
      device.DO.DO_WDT_ModeSelect1_Register.setDO_WDT_ModeD11(wdtMode, &status);
      device.DO.DO_WDT_ModeSelect1_Register.setDO_WDT_ModeD12(wdtMode, &status);
      device.DO.DO_WDT_ModeSelect1_Register.setDO_WDT_ModeD13(wdtMode, &status);
      device.DO.DO_WDT_ModeSelect1_Register.setDO_WDT_ModeD14(wdtMode, &status);
      device.DO.DO_WDT_ModeSelect1_Register.setDO_WDT_ModeD15(wdtMode, &status);
   }
   device.DO.DO_WDT_ModeSelect1_Register.flush(&status);

   if (port0Length == 32)
   {
      device.DO.DO_WDT_ModeSelect2_Register.setDO_WDT_ModeD16(wdtMode, &status);
      device.DO.DO_WDT_ModeSelect2_Register.setDO_WDT_ModeD17(wdtMode, &status);
      device.DO.DO_WDT_ModeSelect2_Register.setDO_WDT_ModeD18(wdtMode, &status);
      device.DO.DO_WDT_ModeSelect2_Register.setDO_WDT_ModeD19(wdtMode, &status);
      device.DO.DO_WDT_ModeSelect2_Register.setDO_WDT_ModeD20(wdtMode, &status);
      device.DO.DO_WDT_ModeSelect2_Register.setDO_WDT_ModeD21(wdtMode, &status);
      device.DO.DO_WDT_ModeSelect2_Register.setDO_WDT_ModeD22(wdtMode, &status);
      device.DO.DO_WDT_ModeSelect2_Register.setDO_WDT_ModeD23(wdtMode, &status);
      device.DO.DO_WDT_ModeSelect2_Register.setDO_WDT_ModeD24(wdtMode, &status);
      device.DO.DO_WDT_ModeSelect2_Register.setDO_WDT_ModeD25(wdtMode, &status);
      device.DO.DO_WDT_ModeSelect2_Register.setDO_WDT_ModeD26(wdtMode, &status);
      device.DO.DO_WDT_ModeSelect2_Register.setDO_WDT_ModeD27(wdtMode, &status);
      device.DO.DO_WDT_ModeSelect2_Register.setDO_WDT_ModeD28(wdtMode, &status);
      device.DO.DO_WDT_ModeSelect2_Register.setDO_WDT_ModeD29(wdtMode, &status);
      device.DO.DO_WDT_ModeSelect2_Register.setDO_WDT_ModeD30(wdtMode, &status);
      device.DO.DO_WDT_ModeSelect2_Register.setDO_WDT_ModeD31(wdtMode, &status);
      device.DO.DO_WDT_ModeSelect2_Register.flush(&status);
   }

   // Set the safe states
   device.DO.DO_WDT_SafeStateRegister.writeRegister(safeStates, &status);

   /*********************************************************************\
   |
   |   Program the DO subsystem
   |
   \*********************************************************************/

   //
   // Reset the DO subsystem
   //

   doHelper.reset(status);
   dioHelper.reset(NULL, 0, status);

   // Prepare the default output state of the digital output lines
   // The default output state will not be output until configureLines is called
   device.DO.DO_DirectDataRegister.writeRegister(defaultState&lineMaskPort0, &status);
   device.DO.DO_Timer.Command_1_Register.writeRegister(nOutTimer::nUpdate_Pulse::kMask, &status);

   //
   // Program DO timing
   //

   // Enter timing configuration mode
   device.DO.DO_Timer.Reset_Register.writeConfiguration_Start(kTrue, &status);

   // Disable external gating of the sample clock
   doHelper.programExternalGate(
      nDO::kGate_Disabled,  // No external pause signal
      nDO::kRising_Edge,    // Don't care
      kFalse,               // Disable external gating
      status);

   // Program the START1 signal (start trigger) to assert from a software rising edge
   doHelper.programStart1(
      nDO::kStart1_Pulse,   // Set the line to software-driven
      nDO::kRising_Edge,    // Make line active on rising...
      kTrue,                //   ...edge (not high level)
      status);

   // Program the START1 signal to be used immediately
   doHelper.getOutTimerHelper(status).programStart1(
      nOutTimer::kSyncDefault,                // The trigger is synchronized to the source of the timer
      nOutTimer::kExportSynchronizedTriggers, // Exported triggers will be synchronized to the Update Interval source
      status);

   // Program the number of times that a buffer should be regenerated
   doHelper.getOutTimerHelper(status).programBufferCount(
      2,                    // Operation is continuous so the Buffer Counter is ignored
      status);

   // Program the number of samples in each buffer
   doHelper.getOutTimerHelper(status).programUpdateCount(
      sampsPerChan,         // Each buffer will contain a complete incrementing waveform
      0,                    // Switching between different buffer sizes will not be used
      status);

   // Load the update count register
   doHelper.getOutTimerHelper(status).loadUC(status);

   // Disable Buffer Counter gating
   doHelper.getOutTimerHelper(status).programBCGate(
      nOutTimer::kDisabled,
      status);

   // Program the Update signal (sample clock) to derive from the on-board clock
   doHelper.programUpdate(
      nDO::kUpdate_UI_TC,   // Drive the clock line from the Update Interval Terminal Count
      nDO::kRising_Edge,    // Make the line active on rising edge
      status);

   // Program the Update Interval counter
   doHelper.getOutTimerHelper(status).programUICounter(
      nOutTimer::kUI_Src_TB3,   // Derive the Update Interval from the internal timebase
      nOutTimer::kRising_Edge,  // Make the line active on rising edge
      operationType,            // Continuous operation
      status);

   // Set the number of clock DO UI clock intervals between updates
   doHelper.getOutTimerHelper(status).loadUI(
      sampleDelay,          // Number of clock intervals after the start trigger before the first update
      samplePeriod,         // Number of clock intervals between successive updates
      status);

   // Set any errors that should stop the operation
   doHelper.getOutTimerHelper(status).programStopCondition(
      triggerOnce,                    // kTrue since this is a continuous operation
      operationType,                  // Continuous operation
      nOutTimer::kContinue_on_Error,  // BC will reach its terminal count in a continuous operation, so don't stop when it does
      nOutTimer::kContinue_on_Error,  // Ignore additional start triggers
      nOutTimer::kStop_on_Error,      // Stop on Overrun_Error
      status);

   // Set the DO FIFO properties
   doHelper.getOutTimerHelper(status).programFIFO(
      kTrue,                                // Enable the FIFO
      nOutTimer::kFifoMode_Less_Than_Full,  // Request data from DMA when FIFO is less than full
      nOutTimer::kDisabled,                 // Do not use on-board memory only
      status);

   // Set the FIFO layout
   device.DO.DO_Mode_Register.setDO_DataWidth(dataWidth, &status);
   device.DO.DO_Mode_Register.setDO_Data_Lane(dataLane, &status);
   device.DO.DO_Mode_Register.flush(&status);

   // Clear the DO FIFO
   doHelper.getOutTimerHelper(status).clearFIFO(status);

   //
   // Program DO channels
   //

   // Set the number of channels in this operation
   doHelper.getOutTimerHelper(status).programNumberOfChannels(
      1,       // Correlated digital output has only one channel -- port0
      status);

   dioHelper.configureLines(lineMaskPort0, nNISTC3::kCorrOutput, status);

   // Leave timing configuration mode
   device.DO.DO_Timer.Reset_Register.writeConfiguration_End(kTrue, &status);

   /*********************************************************************\
   |
   |   Program DMA
   |
   \*********************************************************************/

   //
   // Create and print output values
   //

   // Fill rawData with a simple incrementing waveform
   for (u32 j=0; j<sampsPerChan; ++j)
   {
      if (sampleSizeInBytes == 1)
      {
         rawData8[j] = static_cast<u8>(j);
      }
      else
      {
         rawData32[j] = j;
      }
   }

   nNISTC3::nDIODataHelper::printHeader(0);
   nNISTC3::nDIODataHelper::printData(rawData, writeSizeInBytes, sampleSizeInBytes);

   //
   // Configure DMA channel
   //

   std::auto_ptr<nNISTC3::tCHInChDMAChannel> dma(new nNISTC3::tCHInChDMAChannel(device, dmaChannel, status));
   if (status.isFatal())
   {
      printf("Error: DMA channel initialization (%d).\n", status);
      return;
   }
   dma->reset(status);

   // Use the optimized 2-link SGL ring buffer
   dma->configure(bus, nNISTC3::kReuseLinkRing, nNISTC3::kOut, dmaSizeInBytes, status);
   if (status.isFatal())
   {
      printf("Error: DMA channel configuration (%d).\n", status);
      return;
   }

   //
   // Prime DMA buffer
   //

   for (u32 i=0; i<dmaBufferFactor; ++i)
   {
      dma->write(writeSizeInBytes, &rawData[0], &availableSpace, allowRegeneration, &dataRegenerated, status);
      if (status.isFatal())
      {
         printf("Error: DMA write (%d).\n", status);
         return;
      }

      bytesWritten += writeSizeInBytes;
   }

   //
   // Start DMA channel
   //

   dma->start(status);
   if (status.isFatal())
   {
      printf("Error: DMA channel start (%d).\n", status);
      return;
   }

   streamHelper.configureForOutput(!allowRegeneration, dmaChannel, status);
   if (!allowRegeneration)
   {
      streamHelper.modifyTransferSize(dmaSizeInBytes, status);
   }
   streamHelper.enable(status);

   /*********************************************************************\
   |
   |   Start the digital generation
   |
   \*********************************************************************/

   //
   // Wait for data to enter the FIFO
   //

   // Wait for data to enter the DO FIFO
   rlpElapsedTime = 0;
   rlpStart = clock();
   while (device.DO.DO_Timer.Status_1_Register.readFIFO_Empty_St(&status) == nOutTimer::kEmpty)
   {
      // Spin until the DO FIFO is no longer empty
      if (rlpElapsedTime > rlpTimeout)
      {
         printf("Error: DO FIFO did not receive data within timeout.\n");
         status.setCode(kStatusRLPTimeout);
         return;
      }
      rlpElapsedTime = static_cast<f64>(clock() - rlpStart) / CLOCKS_PER_SEC;
   }

   //
   // Arm the DO subsystem
   //

   doHelper.getOutTimerHelper(status).setArmUI(kTrue, status);
   doHelper.getOutTimerHelper(status).setArmUC(kTrue, status);
   doHelper.getOutTimerHelper(status).setArmBC(kTrue, status);
   doHelper.getOutTimerHelper(status).armTiming(status);

   // Enable, reset and feed the Watchdog Timer
   device.BrdServices.WatchdogConfiguration.writeWatchdogIntTrigEn(kTrue, &status);
   device.BrdServices.WatchdogControl.writeRegister(RESET, &status);
   device.BrdServices.WatchdogControl.writeRegister(START, &status);
   device.BrdServices.WatchdogControl.writeRegister(FEED, &status);

   //
   // Start the DO subsystem
   //

   printf("Generating continuous hardware-timed digital updates for %.2f seconds.\n", runTime);
   device.DO.DO_Timer.Command_1_Register.writeSTART1_Pulse(kTrue, &status);

   /*********************************************************************\
   |
   |   Write data
   |
   \*********************************************************************/

   start = clock();
   while (elapsedTime < runTime)
   {
      // 1. Use the write() method to query the number of bytes in the DMA buffer
      dma->write(0, NULL, &availableSpace, allowRegeneration, &dataRegenerated, status);
      if (status.isFatal())
      {
         dmaErr = status;
         dmaErrored = kTrue;
      }

      // 2. If there is enough space, write
      else if (availableSpace >= writeSizeInBytes)
      {
         dma->write(writeSizeInBytes, &rawData[0], &availableSpace, allowRegeneration, &dataRegenerated, status);
         if (status.isNotFatal())
         {
            bytesWritten += writeSizeInBytes;

            // Permit the Stream Circuit to transfer another writeSizeInBytes bytes
            if (!allowRegeneration)
            {
               streamHelper.modifyTransferSize(writeSizeInBytes, status);
            }
         }
         else
         {
            dmaErr = status;
            dmaErrored = kTrue;
         }
      }

      // 3. Check for DO subsystem errors
      device.DO.DO_Timer.Status_1_Register.refresh(&status);
      fifoUnderflow = device.DO.DO_Timer.Status_1_Register.getUnderflow_St(&status);
      clkOverrun = device.DO.DO_Timer.Status_1_Register.getOverrun_St(&status);

      if (fifoUnderflow || clkOverrun)
      {
         doErrored = kTrue;
      }

      if (doErrored || dmaErrored)
      {
         break;
      }

      // 4. Check the Watchdog Timer status
      wdtStatus = device.BrdServices.WatchdogStatusRegister.readWatchdogSM_State(&status);
      if (wdtStatus == nBrdServices::kWdtSt_Expired)
      {
         printf("Warning: The Watchdog Timer tripped early.\n");
         break;
      }

      // 5. Feed the Watchdog Timer
      if (watchdogToggle % 2)
      {
         device.BrdServices.WatchdogControl.writeRegister(FEED, &status);
      }
      else
      {
         device.BrdServices.WatchdogControl.writeRegister(FOOD, &status);
      }
      ++watchdogToggle;

      // 6. Update the run time for this generation
      elapsedTime = static_cast<f64>(clock() - start) / CLOCKS_PER_SEC;
   }

   if (! (doErrored || dmaErrored))
   {
      printf("Generation complete.\n");
   }

   //
   // Trip the Watchdog Timer and hold safe states
   //

   printf("Tripping Watchdog Timer and holding safe states for %.2f seconds.\n", watchdogTime);
   device.BrdServices.WatchdogControl.writeRegister(KILL, &status);
   elapsedTime = 0;
   start = clock();
   while (elapsedTime < watchdogTime)
   {
      // Just wait and show safe states
      elapsedTime = static_cast<f64>(clock() - start) / CLOCKS_PER_SEC;
   }

   /*********************************************************************\
   |
   |   Stop the digital generation
   |
   \*********************************************************************/

   //
   // Stop the DO subsystem
   //

   if (!doErrored)
   {
      // Issue the stop command to end the operation when the update counter terminates
      device.DO.DO_Timer.Command_1_Register.writeEnd_On_UC_TC(kTrue, &status);

      // Wait for DO Operation to stop before disabling DMA
      rlpElapsedTime = 0;
      rlpStart = clock();
      while (device.DO.DO_Timer.Status_1_Register.readUC_Armed_St(&status) == nOutTimer::kArmed)
      {
         // Spin until the update counter reaches the terminal count and disarms or there is an error
         if (rlpElapsedTime > rlpTimeout)
         {
            printf("Error: DO timing engine did not stop within timeout.\n");
            device.BrdServices.WatchdogConfiguration.writeWatchdogIntTrigEn(kFalse, &status);
            device.BrdServices.WatchdogControl.writeRegister(RESET, &status);
            status.setCode(kStatusRLPTimeout);
            return;
         }
         rlpElapsedTime = static_cast<f64>(clock() - rlpStart) / CLOCKS_PER_SEC;
      }
   }

   //
   // Disable DMA on the device and stop the CHInCh DMA channel
   //

   streamHelper.disable(status);
   dma->stop(status);

   /*********************************************************************\
   |
   |   Finalize the generation
   |
   \*********************************************************************/

   //
   // Print run-time summary
   //

   if (dmaErrored)
   {
      printf("Error: DMA write (%d).\n", dmaErr);
      status.setCode(kStatusRuntimeError);
   }
   if (fifoUnderflow)
   {
      printf("Error: DO FIFO underflow.\n");
      status.setCode(kStatusRuntimeError);
   }
   if (clkOverrun)
   {
      printf("Error: Sample clock overrun.\n");
      status.setCode(kStatusRuntimeError);
   }
   if (! (doErrored || dmaErrored))
   {
      printf("Finished generating continuous hardware-timed digital updates for %.2f seconds.\n", runTime);
      printf("Generated %u %u-sample waveforms (%u total samples) %s.\n",
         bytesWritten/(sampsPerChan*sampleSizeInBytes),
         sampsPerChan,
         bytesWritten/sampleSizeInBytes,
         dataRegenerated ? "by regenerating old data" : "without regenerating old data");
   }

   //
   // Restore the state of the device
   //

   device.BrdServices.WatchdogConfiguration.writeWatchdogIntTrigEn(kFalse, &status);
   device.BrdServices.WatchdogControl.writeRegister(RESET, &status);

   // Nothing else to do: the helpers' destructors safely unwind device state.
}
