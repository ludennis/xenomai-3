// Copyright 2011 National Instruments
// License: NATIONAL INSTRUMENTS SOFTWARE LICENSE AGREEMENT
//   Refer to "MHDDK License Agreement.pdf" in the root of this distribution.

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// This file is autogenerated!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#ifndef ___tTriggers_h___
#include "tTriggers.h"
#endif

tTriggers::tTriggers(tBusSpaceReference addrSpace, nMDBG::tStatus2* s)

{
   _addressOffset = 0;
   _addrSpace = addrSpace;

   _initialize(s);
}

tTriggers::tTriggers()

{
   _addressOffset = 0;

}

void tTriggers::initialize(tBusSpaceReference addrSpace, u32 addressOffset, nMDBG::tStatus2* s)
{

   _addrSpace = addrSpace;
   _addressOffset = addressOffset;

   _initialize(s);
}

void tTriggers::reset(nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;

   AnalogTrigControlRegister.setRegister(u16(0x0), s);
   AnalogTrigControlRegister.markDirty(s);
   FOUT_Register.setRegister(u16(0x0), s);
   FOUT_Register.markDirty(s);
   PFI_Direction_Register.setRegister(u16(0x0), s);
   PFI_Direction_Register.markDirty(s);
   RTSI_Trig_Direction_Register.setRegister(u16(0x0), s);
   RTSI_Trig_Direction_Register.markDirty(s);
   unsigned int i;
   for(i = 0; i < 8; ++i) {
      RTSI_OutputSelectRegister_i[i].setRegister(u8(0x0), s);
      RTSI_OutputSelectRegister_i[i].markDirty(s);
   }
   PFI_Filter_Register_0.setRegister(u16(0x0), s);
   PFI_Filter_Register_0.markDirty(s);
   PFI_Filter_Register_1.setRegister(u16(0x0), s);
   PFI_Filter_Register_1.markDirty(s);
   PFI_Filter_Register_2.setRegister(u16(0x0), s);
   PFI_Filter_Register_2.markDirty(s);
   PFI_Filter_Register_3.setRegister(u16(0x0), s);
   PFI_Filter_Register_3.markDirty(s);
   STAR_Trig_Register.setRegister(u16(0x0), s);
   STAR_Trig_Register.markDirty(s);
   for(i = 0; i < 16; ++i) {
      PFI_OutputSelectRegister_i[i].setRegister(u8(0x0), s);
      PFI_OutputSelectRegister_i[i].markDirty(s);
   }
   DStarC_Trig_Register.setRegister(u16(0x0), s);
   DStarC_Trig_Register.markDirty(s);
   Clock_And_Fout2_Register.setRegister(u16(0x0), s);
   Clock_And_Fout2_Register.markDirty(s);
   PLL_Control_Register.setRegister(0x6000, s);
   PLL_Control_Register.markDirty(s);
   PLL_Status_Register.setRegister(u16(0x0), s);
   PFI_DI_Register.setRegister(u16(0x0), s);
   PFI_DO_Register.setRegister(u16(0x0), s);
   PFI_DO_Register.markDirty(s);
   PFI_WDT_SafeStateRegister.setRegister(u16(0x0), s);
   PFI_WDT_SafeStateRegister.markDirty(s);
   PFI_WDT_ModeSelect_Register.setRegister(u32(0x0), s);
   PFI_WDT_ModeSelect_Register.markDirty(s);
   for(i = 0; i < 8; ++i) {
      IntTriggerA_OutputSelectRegister_i[i].setRegister(u8(0x0), s);
      IntTriggerA_OutputSelectRegister_i[i].markDirty(s);
   }
   IntTrigA_Filter_Register_Lo.setRegister(u16(0x0), s);
   IntTrigA_Filter_Register_Lo.markDirty(s);
   IntTrigA_Filter_Register_Hi.setRegister(u16(0x0), s);
   IntTrigA_Filter_Register_Hi.markDirty(s);
   Trig_Filter_Settings1_Register.setRegister(u16(0x0), s);
   Trig_Filter_Settings1_Register.markDirty(s);
   Trig_Filter_Settings2_Register.setRegister(u16(0x0), s);
   Trig_Filter_Settings2_Register.markDirty(s);
   PLL_LockCount_Register.setRegister(0xd6d8, s);
   PLL_LockCount_Register.markDirty(s);
   Sync100_Repeat_Count_Register.setRegister(0x8, s);
   Sync100_Repeat_Count_Register.markDirty(s);
}

void tTriggers::_initialize(nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;

   {
      unsigned int i;
      for (i=0; i<8; ++i) {
         RTSI_OutputSelectRegister_i[i].initialize(0xa8 + (0x1 * i), 0x4 + i);
      }
      for (i=0; i<16; ++i) {
         PFI_OutputSelectRegister_i[i].initialize(0xba + (0x1 * i), 0x11 + i);
      }
      for (i=0; i<8; ++i) {
         IntTriggerA_OutputSelectRegister_i[i].initialize(0xe8 + (0x1 * i), 0x29 + i);
      }
   }


   //----------------------------------------
   // set register maps of all registers
   //----------------------------------------
   AnalogTrigControlRegister.setRegisterMap(this);
   FOUT_Register.setRegisterMap(this);
   PFI_Direction_Register.setRegisterMap(this);
   RTSI_Trig_Direction_Register.setRegisterMap(this);
   {
      unsigned int i;
      for(i = 0; i < 8; ++i) {
         RTSI_OutputSelectRegister_i[i].setRegisterMap(this);
      }
   }
   PFI_Filter_Register_0.setRegisterMap(this);
   PFI_Filter_Register_1.setRegisterMap(this);
   PFI_Filter_Register_2.setRegisterMap(this);
   PFI_Filter_Register_3.setRegisterMap(this);
   STAR_Trig_Register.setRegisterMap(this);
   {
      unsigned int i;
      for(i = 0; i < 16; ++i) {
         PFI_OutputSelectRegister_i[i].setRegisterMap(this);
      }
   }
   DStarC_Trig_Register.setRegisterMap(this);
   Clock_And_Fout2_Register.setRegisterMap(this);
   PLL_Control_Register.setRegisterMap(this);
   PLL_Status_Register.setRegisterMap(this);
   PFI_DI_Register.setRegisterMap(this);
   PFI_DO_Register.setRegisterMap(this);
   PFI_WDT_SafeStateRegister.setRegisterMap(this);
   PFI_WDT_ModeSelect_Register.setRegisterMap(this);
   {
      unsigned int i;
      for(i = 0; i < 8; ++i) {
         IntTriggerA_OutputSelectRegister_i[i].setRegisterMap(this);
      }
   }
   IntTrigA_Filter_Register_Lo.setRegisterMap(this);
   IntTrigA_Filter_Register_Hi.setRegisterMap(this);
   Trig_Filter_Settings1_Register.setRegisterMap(this);
   Trig_Filter_Settings2_Register.setRegisterMap(this);
   PLL_LockCount_Register.setRegisterMap(this);
   Sync100_Repeat_Count_Register.setRegisterMap(this);

   //----------------------------------------
   // initialize dirty flags
   //----------------------------------------
   for (unsigned int i = 0; i < sizeof(_dirtyVector)/sizeof(_dirtyVector[0]); i++) {
      _dirtyVector[i] = 0;
   }

   //----------------------------------------
   // reset registers
   //----------------------------------------
   reset(s);
}

tTriggers::~tTriggers()
{
}



// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// This file is autogenerated!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

