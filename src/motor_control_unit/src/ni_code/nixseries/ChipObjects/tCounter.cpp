// Copyright 2011 National Instruments
// License: NATIONAL INSTRUMENTS SOFTWARE LICENSE AGREEMENT
//   Refer to "MHDDK License Agreement.pdf" in the root of this distribution.

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// This file is autogenerated!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#ifndef ___tCounter_h___
#include "tCounter.h"
#endif

tCounter::tCounter(tBusSpaceReference addrSpace, nMDBG::tStatus2* s)

{
   _addressOffset = 0;
   _addrSpace = addrSpace;

   _initialize(s);
}

tCounter::tCounter()

{
   _addressOffset = 0;

}

void tCounter::initialize(tBusSpaceReference addrSpace, u32 addressOffset, nMDBG::tStatus2* s)
{

   _addrSpace = addrSpace;
   _addressOffset = addressOffset;

   _initialize(s);
}

void tCounter::reset(nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;

   Gi_Command_Register.setRegister(u16(0x0), s);
   Gi_Command_Register.markDirty(s);
   Gi_Mode_Register.setRegister(u16(0x0), s);
   Gi_Mode_Register.markDirty(s);
   Gi_HW_Save_Register.setRegister(u32(0x0), s);
   Gi_Load_A_Register.setRegister(u32(0x0), s);
   Gi_Load_A_Register.markDirty(s);
   Gi_Load_B_Register.setRegister(u32(0x0), s);
   Gi_Load_B_Register.markDirty(s);
   Gi_Save_Register.setRegister(u32(0x0), s);
   Gi_Input_Select_Register.setRegister(u16(0x0), s);
   Gi_Input_Select_Register.markDirty(s);
   Gi_Status_Register.setRegister(u32(0x0), s);
   Gi_Autoincrement_Register.setRegister(u16(0x0), s);
   Gi_Autoincrement_Register.markDirty(s);
   Gi_Counting_Mode_Register.setRegister(u16(0x0), s);
   Gi_Counting_Mode_Register.markDirty(s);
   Gi_FifoStatusRegister.setRegister(u32(0x0), s);
   Gi_Second_Gate_Register.setRegister(u16(0x0), s);
   Gi_Second_Gate_Register.markDirty(s);
   Gi_DMA_Config_Register.setRegister(0x0, s);
   Gi_DMA_Config_Register.markDirty(s);
   Gi_SampleClockCountRegister.setRegister(u32(0x0), s);
   Gi_RdFifoRegister.setRegister(u32(0x0), s);
   Gi_SampleClockRegister.setRegister(u16(0x0), s);
   Gi_SampleClockRegister.markDirty(s);
   Gi_AuxCtrRegister.setRegister(u16(0x0), s);
   Gi_AuxCtrRegister.markDirty(s);
   Gi_AuxCtrLoadA_Register.setRegister(u32(0x0), s);
   Gi_AuxCtrLoadA_Register.markDirty(s);
   Gi_AuxCtrLoadB_Register.setRegister(u32(0x0), s);
   Gi_AuxCtrLoadB_Register.markDirty(s);
   Gi_ABZ_Select_Register.setRegister(u32(0x0), s);
   Gi_ABZ_Select_Register.markDirty(s);
   Gi_Mode3_Register.setRegister(u16(0x0), s);
   Gi_Mode3_Register.markDirty(s);
   Gi_Mode2_Register.setRegister(u16(0x0), s);
   Gi_Mode2_Register.markDirty(s);
}

void tCounter::_initialize(nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;



   //----------------------------------------
   // set register maps of all registers
   //----------------------------------------
   Gi_Command_Register.setRegisterMap(this);
   Gi_Mode_Register.setRegisterMap(this);
   Gi_HW_Save_Register.setRegisterMap(this);
   Gi_Load_A_Register.setRegisterMap(this);
   Gi_Load_B_Register.setRegisterMap(this);
   Gi_Save_Register.setRegisterMap(this);
   Gi_Input_Select_Register.setRegisterMap(this);
   Gi_Status_Register.setRegisterMap(this);
   Gi_Autoincrement_Register.setRegisterMap(this);
   Gi_Counting_Mode_Register.setRegisterMap(this);
   Gi_FifoStatusRegister.setRegisterMap(this);
   Gi_Second_Gate_Register.setRegisterMap(this);
   Gi_DMA_Config_Register.setRegisterMap(this);
   Gi_SampleClockCountRegister.setRegisterMap(this);
   Gi_RdFifoRegister.setRegisterMap(this);
   Gi_WrFifoRegister.setRegisterMap(this);
   Gi_SampleClockRegister.setRegisterMap(this);
   Gi_AuxCtrRegister.setRegisterMap(this);
   Gi_AuxCtrLoadA_Register.setRegisterMap(this);
   Gi_AuxCtrLoadB_Register.setRegisterMap(this);
   Gi_AutomaticLoadRegister.setRegisterMap(this);
   Gi_Interrupt1_Register.setRegisterMap(this);
   Gi_Interrupt2_Register.setRegisterMap(this);
   Gi_ABZ_Select_Register.setRegisterMap(this);
   Gi_Mode3_Register.setRegisterMap(this);
   Gi_Mode2_Register.setRegisterMap(this);

   //----------------------------------------
   // initialize dirty flags
   //----------------------------------------
   for (unsigned int i = 0; i < sizeof(_dirtyVector)/sizeof(_dirtyVector[0]); i++) {
      _dirtyVector[i] = 0;
   }

   //----------------------------------------
   // reset registers
   //----------------------------------------
   reset(s);
}

tCounter::~tCounter()
{
}



// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// This file is autogenerated!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

